# Generated from JavaScriptParser.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

if __name__ is not None and "." in __name__:
    from .JavaScriptParserBase import JavaScriptParserBase
else:
    from JavaScriptParserBase import JavaScriptParserBase

def serializedATN():
    return [
        4,1,128,1035,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,1,0,3,0,156,8,0,
        1,0,3,0,159,8,0,1,0,1,0,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
        1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,185,8,2,1,3,
        1,3,3,3,189,8,3,1,3,1,3,1,4,4,4,194,8,4,11,4,12,4,195,1,5,1,5,1,
        5,1,6,3,6,202,8,6,1,6,1,6,3,6,206,8,6,1,6,1,6,1,6,1,6,1,6,3,6,213,
        8,6,1,7,1,7,1,7,1,7,5,7,219,8,7,10,7,12,7,222,9,7,1,7,1,7,3,7,226,
        8,7,3,7,228,8,7,1,7,1,7,1,8,1,8,1,8,1,9,1,9,3,9,237,8,9,1,9,1,9,
        3,9,241,8,9,1,10,1,10,1,10,1,11,1,11,1,11,3,11,249,8,11,1,12,1,12,
        1,12,3,12,254,8,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,263,8,
        12,1,13,1,13,1,13,1,13,1,13,1,13,3,13,271,8,13,1,13,1,13,3,13,275,
        8,13,1,14,1,14,1,14,3,14,280,8,14,1,15,1,15,1,15,1,16,1,16,1,16,
        1,16,5,16,289,8,16,10,16,12,16,292,9,16,1,17,1,17,1,17,3,17,297,
        8,17,1,18,1,18,1,19,1,19,1,19,1,19,1,20,1,20,1,20,1,20,1,20,1,20,
        1,20,3,20,312,8,20,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,
        1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,332,8,21,1,21,
        1,21,3,21,336,8,21,1,21,1,21,3,21,340,8,21,1,21,1,21,1,21,1,21,1,
        21,1,21,3,21,348,8,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,357,
        8,21,1,21,1,21,1,21,3,21,362,8,21,1,21,1,21,1,21,1,21,1,21,1,21,
        3,21,370,8,21,1,22,1,22,1,22,3,22,375,8,22,1,23,1,23,1,23,3,23,380,
        8,23,1,23,1,23,1,24,1,24,1,24,3,24,387,8,24,1,24,1,24,1,25,1,25,
        1,25,3,25,394,8,25,1,25,1,25,1,26,1,26,1,26,3,26,401,8,26,1,26,1,
        26,1,27,1,27,1,27,1,27,1,27,1,27,1,28,1,28,1,28,1,28,1,28,1,28,1,
        29,1,29,3,29,419,8,29,1,29,1,29,3,29,423,8,29,3,29,425,8,29,1,29,
        1,29,1,30,4,30,430,8,30,11,30,12,30,431,1,31,1,31,1,31,1,31,3,31,
        438,8,31,1,32,1,32,1,32,3,32,443,8,32,1,33,1,33,1,33,1,33,1,34,1,
        34,1,34,1,34,1,34,1,35,1,35,1,35,1,35,3,35,458,8,35,1,35,3,35,461,
        8,35,1,36,1,36,1,36,3,36,466,8,36,1,36,3,36,469,8,36,1,36,1,36,1,
        37,1,37,1,37,1,38,1,38,1,38,1,39,3,39,480,8,39,1,39,1,39,3,39,484,
        8,39,1,39,1,39,1,39,3,39,489,8,39,1,39,1,39,1,39,1,40,1,40,1,40,
        1,40,1,41,1,41,3,41,500,8,41,1,41,1,41,5,41,504,8,41,10,41,12,41,
        507,9,41,1,41,1,41,1,42,1,42,1,42,1,42,5,42,515,8,42,10,42,12,42,
        518,9,42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,526,8,42,1,42,1,42,3,
        42,530,8,42,1,42,1,42,1,42,1,42,3,42,536,8,42,1,43,3,43,539,8,43,
        1,43,3,43,542,8,43,1,43,1,43,1,43,3,43,547,8,43,1,43,1,43,1,43,1,
        43,3,43,553,8,43,1,43,3,43,556,8,43,1,43,1,43,1,43,1,43,1,43,1,43,
        3,43,564,8,43,1,43,3,43,567,8,43,1,43,1,43,1,43,3,43,572,8,43,1,
        43,1,43,1,43,3,43,577,8,43,1,44,1,44,1,44,5,44,582,8,44,10,44,12,
        44,585,9,44,1,44,1,44,3,44,589,8,44,1,44,3,44,592,8,44,1,45,1,45,
        1,45,3,45,597,8,45,1,46,1,46,1,46,1,47,1,47,3,47,604,8,47,1,47,1,
        47,1,48,4,48,609,8,48,11,48,12,48,610,1,49,1,49,1,49,1,49,1,50,5,
        50,618,8,50,10,50,12,50,621,9,50,1,50,3,50,624,8,50,1,50,4,50,627,
        8,50,11,50,12,50,628,1,50,5,50,632,8,50,10,50,12,50,635,9,50,1,50,
        5,50,638,8,50,10,50,12,50,641,9,50,1,51,3,51,644,8,51,1,51,1,51,
        1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,3,52,659,
        8,52,1,52,3,52,662,8,52,1,52,1,52,1,52,3,52,667,8,52,1,52,1,52,1,
        52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,3,
        52,684,8,52,1,52,3,52,687,8,52,1,53,1,53,1,53,1,53,1,53,1,53,1,53,
        3,53,696,8,53,1,54,1,54,1,54,1,54,5,54,702,8,54,10,54,12,54,705,
        9,54,1,54,3,54,708,8,54,3,54,710,8,54,1,54,1,54,1,55,3,55,715,8,
        55,1,55,1,55,3,55,719,8,55,1,56,1,56,1,56,5,56,724,8,56,10,56,12,
        56,727,9,56,1,57,1,57,1,57,1,57,3,57,733,8,57,1,57,1,57,1,57,1,57,
        1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
        1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
        1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
        1,57,1,57,1,57,3,57,781,8,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
        1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
        1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
        1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
        1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
        1,57,3,57,843,8,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,851,8,57,1,
        57,1,57,3,57,855,8,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
        57,1,57,1,57,5,57,868,8,57,10,57,12,57,871,9,57,1,58,1,58,1,58,3,
        58,876,8,58,1,59,1,59,1,59,1,59,5,59,882,8,59,10,59,12,59,885,9,
        59,1,59,3,59,888,8,59,3,59,890,8,59,1,59,1,59,1,60,1,60,3,60,896,
        8,60,1,60,1,60,3,60,900,8,60,1,60,1,60,3,60,904,8,60,1,60,1,60,1,
        60,3,60,909,8,60,1,60,1,60,1,60,1,60,3,60,915,8,60,1,61,1,61,1,61,
        3,61,920,8,61,1,61,3,61,923,8,61,1,62,1,62,3,62,927,8,62,1,63,1,
        63,1,64,1,64,1,64,1,64,1,64,1,64,1,64,3,64,938,8,64,1,65,1,65,5,
        65,942,8,65,10,65,12,65,945,9,65,1,65,1,65,1,66,1,66,1,66,1,66,1,
        66,3,66,954,8,66,1,67,1,67,1,68,1,68,1,69,1,69,1,69,1,69,1,70,1,
        70,1,70,1,70,1,71,1,71,3,71,970,8,71,1,72,1,72,1,73,1,73,1,73,3,
        73,977,8,73,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,
        74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,
        74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,
        74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,1025,8,74,1,
        75,1,75,1,76,1,76,1,76,1,76,3,76,1033,8,76,1,76,0,1,114,77,0,2,4,
        6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,
        50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,
        94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,
        128,130,132,134,136,138,140,142,144,146,148,150,152,0,10,1,0,26,
        28,1,0,22,23,1,0,32,34,1,0,35,38,1,0,39,42,1,0,48,59,1,0,63,67,1,
        0,68,71,4,0,98,98,107,107,112,112,119,119,1,0,111,112,1201,0,155,
        1,0,0,0,2,162,1,0,0,0,4,184,1,0,0,0,6,186,1,0,0,0,8,193,1,0,0,0,
        10,197,1,0,0,0,12,212,1,0,0,0,14,214,1,0,0,0,16,231,1,0,0,0,18,236,
        1,0,0,0,20,242,1,0,0,0,22,245,1,0,0,0,24,262,1,0,0,0,26,274,1,0,
        0,0,28,279,1,0,0,0,30,281,1,0,0,0,32,284,1,0,0,0,34,293,1,0,0,0,
        36,298,1,0,0,0,38,300,1,0,0,0,40,304,1,0,0,0,42,369,1,0,0,0,44,374,
        1,0,0,0,46,376,1,0,0,0,48,383,1,0,0,0,50,390,1,0,0,0,52,397,1,0,
        0,0,54,404,1,0,0,0,56,410,1,0,0,0,58,416,1,0,0,0,60,429,1,0,0,0,
        62,433,1,0,0,0,64,439,1,0,0,0,66,444,1,0,0,0,68,448,1,0,0,0,70,453,
        1,0,0,0,72,462,1,0,0,0,74,472,1,0,0,0,76,475,1,0,0,0,78,479,1,0,
        0,0,80,493,1,0,0,0,82,499,1,0,0,0,84,535,1,0,0,0,86,576,1,0,0,0,
        88,591,1,0,0,0,90,593,1,0,0,0,92,598,1,0,0,0,94,601,1,0,0,0,96,608,
        1,0,0,0,98,612,1,0,0,0,100,619,1,0,0,0,102,643,1,0,0,0,104,686,1,
        0,0,0,106,695,1,0,0,0,108,697,1,0,0,0,110,714,1,0,0,0,112,720,1,
        0,0,0,114,780,1,0,0,0,116,875,1,0,0,0,118,877,1,0,0,0,120,914,1,
        0,0,0,122,922,1,0,0,0,124,926,1,0,0,0,126,928,1,0,0,0,128,937,1,
        0,0,0,130,939,1,0,0,0,132,953,1,0,0,0,134,955,1,0,0,0,136,957,1,
        0,0,0,138,959,1,0,0,0,140,963,1,0,0,0,142,969,1,0,0,0,144,971,1,
        0,0,0,146,976,1,0,0,0,148,1024,1,0,0,0,150,1026,1,0,0,0,152,1032,
        1,0,0,0,154,156,5,1,0,0,155,154,1,0,0,0,155,156,1,0,0,0,156,158,
        1,0,0,0,157,159,3,96,48,0,158,157,1,0,0,0,158,159,1,0,0,0,159,160,
        1,0,0,0,160,161,5,0,0,1,161,1,1,0,0,0,162,163,3,4,2,0,163,3,1,0,
        0,0,164,185,3,6,3,0,165,185,3,30,15,0,166,185,3,10,5,0,167,185,3,
        24,12,0,168,185,3,36,18,0,169,185,3,80,40,0,170,185,3,38,19,0,171,
        185,3,40,20,0,172,185,3,42,21,0,173,185,3,46,23,0,174,185,3,48,24,
        0,175,185,3,50,25,0,176,185,3,52,26,0,177,185,3,54,27,0,178,185,
        3,66,33,0,179,185,3,56,28,0,180,185,3,68,34,0,181,185,3,70,35,0,
        182,185,3,76,38,0,183,185,3,78,39,0,184,164,1,0,0,0,184,165,1,0,
        0,0,184,166,1,0,0,0,184,167,1,0,0,0,184,168,1,0,0,0,184,169,1,0,
        0,0,184,170,1,0,0,0,184,171,1,0,0,0,184,172,1,0,0,0,184,173,1,0,
        0,0,184,174,1,0,0,0,184,175,1,0,0,0,184,176,1,0,0,0,184,177,1,0,
        0,0,184,178,1,0,0,0,184,179,1,0,0,0,184,180,1,0,0,0,184,181,1,0,
        0,0,184,182,1,0,0,0,184,183,1,0,0,0,185,5,1,0,0,0,186,188,5,9,0,
        0,187,189,3,8,4,0,188,187,1,0,0,0,188,189,1,0,0,0,189,190,1,0,0,
        0,190,191,5,11,0,0,191,7,1,0,0,0,192,194,3,4,2,0,193,192,1,0,0,0,
        194,195,1,0,0,0,195,193,1,0,0,0,195,196,1,0,0,0,196,9,1,0,0,0,197,
        198,5,106,0,0,198,199,3,12,6,0,199,11,1,0,0,0,200,202,3,16,8,0,201,
        200,1,0,0,0,201,202,1,0,0,0,202,205,1,0,0,0,203,206,3,18,9,0,204,
        206,3,14,7,0,205,203,1,0,0,0,205,204,1,0,0,0,206,207,1,0,0,0,207,
        208,3,20,10,0,208,209,3,152,76,0,209,213,1,0,0,0,210,211,5,120,0,
        0,211,213,3,152,76,0,212,201,1,0,0,0,212,210,1,0,0,0,213,13,1,0,
        0,0,214,220,5,9,0,0,215,216,3,22,11,0,216,217,5,13,0,0,217,219,1,
        0,0,0,218,215,1,0,0,0,219,222,1,0,0,0,220,218,1,0,0,0,220,221,1,
        0,0,0,221,227,1,0,0,0,222,220,1,0,0,0,223,225,3,22,11,0,224,226,
        5,13,0,0,225,224,1,0,0,0,225,226,1,0,0,0,226,228,1,0,0,0,227,223,
        1,0,0,0,227,228,1,0,0,0,228,229,1,0,0,0,229,230,5,11,0,0,230,15,
        1,0,0,0,231,232,3,22,11,0,232,233,5,13,0,0,233,17,1,0,0,0,234,237,
        5,26,0,0,235,237,3,142,71,0,236,234,1,0,0,0,236,235,1,0,0,0,237,
        240,1,0,0,0,238,239,5,98,0,0,239,241,3,142,71,0,240,238,1,0,0,0,
        240,241,1,0,0,0,241,19,1,0,0,0,242,243,5,99,0,0,243,244,5,120,0,
        0,244,21,1,0,0,0,245,248,3,142,71,0,246,247,5,98,0,0,247,249,3,142,
        71,0,248,246,1,0,0,0,248,249,1,0,0,0,249,23,1,0,0,0,250,253,5,105,
        0,0,251,254,3,26,13,0,252,254,3,28,14,0,253,251,1,0,0,0,253,252,
        1,0,0,0,254,255,1,0,0,0,255,256,3,152,76,0,256,263,1,0,0,0,257,258,
        5,105,0,0,258,259,5,92,0,0,259,260,3,114,57,0,260,261,3,152,76,0,
        261,263,1,0,0,0,262,250,1,0,0,0,262,257,1,0,0,0,263,25,1,0,0,0,264,
        265,3,18,9,0,265,266,3,20,10,0,266,267,3,152,76,0,267,275,1,0,0,
        0,268,270,3,14,7,0,269,271,3,20,10,0,270,269,1,0,0,0,270,271,1,0,
        0,0,271,272,1,0,0,0,272,273,3,152,76,0,273,275,1,0,0,0,274,264,1,
        0,0,0,274,268,1,0,0,0,275,27,1,0,0,0,276,280,3,30,15,0,277,280,3,
        80,40,0,278,280,3,78,39,0,279,276,1,0,0,0,279,277,1,0,0,0,279,278,
        1,0,0,0,280,29,1,0,0,0,281,282,3,32,16,0,282,283,3,152,76,0,283,
        31,1,0,0,0,284,285,3,44,22,0,285,290,3,34,17,0,286,287,5,13,0,0,
        287,289,3,34,17,0,288,286,1,0,0,0,289,292,1,0,0,0,290,288,1,0,0,
        0,290,291,1,0,0,0,291,33,1,0,0,0,292,290,1,0,0,0,293,296,3,116,58,
        0,294,295,5,14,0,0,295,297,3,114,57,0,296,294,1,0,0,0,296,297,1,
        0,0,0,297,35,1,0,0,0,298,299,5,12,0,0,299,37,1,0,0,0,300,301,4,19,
        0,0,301,302,3,112,56,0,302,303,3,152,76,0,303,39,1,0,0,0,304,305,
        5,93,0,0,305,306,5,7,0,0,306,307,3,112,56,0,307,308,5,8,0,0,308,
        311,3,4,2,0,309,310,5,77,0,0,310,312,3,4,2,0,311,309,1,0,0,0,311,
        312,1,0,0,0,312,41,1,0,0,0,313,314,5,73,0,0,314,315,3,4,2,0,315,
        316,5,87,0,0,316,317,5,7,0,0,317,318,3,112,56,0,318,319,5,8,0,0,
        319,320,3,152,76,0,320,370,1,0,0,0,321,322,5,87,0,0,322,323,5,7,
        0,0,323,324,3,112,56,0,324,325,5,8,0,0,325,326,3,4,2,0,326,370,1,
        0,0,0,327,328,5,85,0,0,328,331,5,7,0,0,329,332,3,112,56,0,330,332,
        3,32,16,0,331,329,1,0,0,0,331,330,1,0,0,0,331,332,1,0,0,0,332,333,
        1,0,0,0,333,335,5,12,0,0,334,336,3,112,56,0,335,334,1,0,0,0,335,
        336,1,0,0,0,336,337,1,0,0,0,337,339,5,12,0,0,338,340,3,112,56,0,
        339,338,1,0,0,0,339,340,1,0,0,0,340,341,1,0,0,0,341,342,5,8,0,0,
        342,370,3,4,2,0,343,344,5,85,0,0,344,347,5,7,0,0,345,348,3,114,57,
        0,346,348,3,32,16,0,347,345,1,0,0,0,347,346,1,0,0,0,348,349,1,0,
        0,0,349,350,5,96,0,0,350,351,3,112,56,0,351,352,5,8,0,0,352,353,
        3,4,2,0,353,370,1,0,0,0,354,356,5,85,0,0,355,357,5,108,0,0,356,355,
        1,0,0,0,356,357,1,0,0,0,357,358,1,0,0,0,358,361,5,7,0,0,359,362,
        3,114,57,0,360,362,3,32,16,0,361,359,1,0,0,0,361,360,1,0,0,0,362,
        363,1,0,0,0,363,364,3,144,72,0,364,365,4,21,1,0,365,366,3,112,56,
        0,366,367,5,8,0,0,367,368,3,4,2,0,368,370,1,0,0,0,369,313,1,0,0,
        0,369,321,1,0,0,0,369,327,1,0,0,0,369,343,1,0,0,0,369,354,1,0,0,
        0,370,43,1,0,0,0,371,375,5,79,0,0,372,375,3,150,75,0,373,375,5,104,
        0,0,374,371,1,0,0,0,374,372,1,0,0,0,374,373,1,0,0,0,375,45,1,0,0,
        0,376,379,5,84,0,0,377,378,4,23,2,0,378,380,3,144,72,0,379,377,1,
        0,0,0,379,380,1,0,0,0,380,381,1,0,0,0,381,382,3,152,76,0,382,47,
        1,0,0,0,383,386,5,72,0,0,384,385,4,24,3,0,385,387,3,144,72,0,386,
        384,1,0,0,0,386,387,1,0,0,0,387,388,1,0,0,0,388,389,3,152,76,0,389,
        49,1,0,0,0,390,393,5,82,0,0,391,392,4,25,4,0,392,394,3,112,56,0,
        393,391,1,0,0,0,393,394,1,0,0,0,394,395,1,0,0,0,395,396,3,152,76,
        0,396,51,1,0,0,0,397,400,5,109,0,0,398,399,4,26,5,0,399,401,3,112,
        56,0,400,398,1,0,0,0,400,401,1,0,0,0,401,402,1,0,0,0,402,403,3,152,
        76,0,403,53,1,0,0,0,404,405,5,91,0,0,405,406,5,7,0,0,406,407,3,112,
        56,0,407,408,5,8,0,0,408,409,3,4,2,0,409,55,1,0,0,0,410,411,5,86,
        0,0,411,412,5,7,0,0,412,413,3,112,56,0,413,414,5,8,0,0,414,415,3,
        58,29,0,415,57,1,0,0,0,416,418,5,9,0,0,417,419,3,60,30,0,418,417,
        1,0,0,0,418,419,1,0,0,0,419,424,1,0,0,0,420,422,3,64,32,0,421,423,
        3,60,30,0,422,421,1,0,0,0,422,423,1,0,0,0,423,425,1,0,0,0,424,420,
        1,0,0,0,424,425,1,0,0,0,425,426,1,0,0,0,426,427,5,11,0,0,427,59,
        1,0,0,0,428,430,3,62,31,0,429,428,1,0,0,0,430,431,1,0,0,0,431,429,
        1,0,0,0,431,432,1,0,0,0,432,61,1,0,0,0,433,434,5,76,0,0,434,435,
        3,112,56,0,435,437,5,17,0,0,436,438,3,8,4,0,437,436,1,0,0,0,437,
        438,1,0,0,0,438,63,1,0,0,0,439,440,5,92,0,0,440,442,5,17,0,0,441,
        443,3,8,4,0,442,441,1,0,0,0,442,443,1,0,0,0,443,65,1,0,0,0,444,445,
        3,144,72,0,445,446,5,17,0,0,446,447,3,4,2,0,447,67,1,0,0,0,448,449,
        5,94,0,0,449,450,4,34,6,0,450,451,3,112,56,0,451,452,3,152,76,0,
        452,69,1,0,0,0,453,454,5,97,0,0,454,460,3,6,3,0,455,457,3,72,36,
        0,456,458,3,74,37,0,457,456,1,0,0,0,457,458,1,0,0,0,458,461,1,0,
        0,0,459,461,3,74,37,0,460,455,1,0,0,0,460,459,1,0,0,0,461,71,1,0,
        0,0,462,468,5,80,0,0,463,465,5,7,0,0,464,466,3,116,58,0,465,464,
        1,0,0,0,465,466,1,0,0,0,466,467,1,0,0,0,467,469,5,8,0,0,468,463,
        1,0,0,0,468,469,1,0,0,0,469,470,1,0,0,0,470,471,3,6,3,0,471,73,1,
        0,0,0,472,473,5,81,0,0,473,474,3,6,3,0,474,75,1,0,0,0,475,476,5,
        88,0,0,476,477,3,152,76,0,477,77,1,0,0,0,478,480,5,107,0,0,479,478,
        1,0,0,0,479,480,1,0,0,0,480,481,1,0,0,0,481,483,5,89,0,0,482,484,
        5,26,0,0,483,482,1,0,0,0,483,484,1,0,0,0,484,485,1,0,0,0,485,486,
        3,144,72,0,486,488,5,7,0,0,487,489,3,88,44,0,488,487,1,0,0,0,488,
        489,1,0,0,0,489,490,1,0,0,0,490,491,5,8,0,0,491,492,3,94,47,0,492,
        79,1,0,0,0,493,494,5,100,0,0,494,495,3,144,72,0,495,496,3,82,41,
        0,496,81,1,0,0,0,497,498,5,102,0,0,498,500,3,114,57,0,499,497,1,
        0,0,0,499,500,1,0,0,0,500,501,1,0,0,0,501,505,5,9,0,0,502,504,3,
        84,42,0,503,502,1,0,0,0,504,507,1,0,0,0,505,503,1,0,0,0,505,506,
        1,0,0,0,506,508,1,0,0,0,507,505,1,0,0,0,508,509,5,11,0,0,509,83,
        1,0,0,0,510,515,5,118,0,0,511,512,4,42,7,0,512,515,3,144,72,0,513,
        515,5,107,0,0,514,510,1,0,0,0,514,511,1,0,0,0,514,513,1,0,0,0,515,
        518,1,0,0,0,516,514,1,0,0,0,516,517,1,0,0,0,517,525,1,0,0,0,518,
        516,1,0,0,0,519,526,3,86,43,0,520,521,3,116,58,0,521,522,5,14,0,
        0,522,523,3,118,59,0,523,524,5,12,0,0,524,526,1,0,0,0,525,519,1,
        0,0,0,525,520,1,0,0,0,526,536,1,0,0,0,527,536,3,36,18,0,528,530,
        5,31,0,0,529,528,1,0,0,0,529,530,1,0,0,0,530,531,1,0,0,0,531,532,
        3,106,53,0,532,533,5,14,0,0,533,534,3,114,57,0,534,536,1,0,0,0,535,
        516,1,0,0,0,535,527,1,0,0,0,535,529,1,0,0,0,536,85,1,0,0,0,537,539,
        5,26,0,0,538,537,1,0,0,0,538,539,1,0,0,0,539,541,1,0,0,0,540,542,
        5,31,0,0,541,540,1,0,0,0,541,542,1,0,0,0,542,543,1,0,0,0,543,544,
        3,106,53,0,544,546,5,7,0,0,545,547,3,88,44,0,546,545,1,0,0,0,546,
        547,1,0,0,0,547,548,1,0,0,0,548,549,5,8,0,0,549,550,3,94,47,0,550,
        577,1,0,0,0,551,553,5,26,0,0,552,551,1,0,0,0,552,553,1,0,0,0,553,
        555,1,0,0,0,554,556,5,31,0,0,555,554,1,0,0,0,555,556,1,0,0,0,556,
        557,1,0,0,0,557,558,3,138,69,0,558,559,5,7,0,0,559,560,5,8,0,0,560,
        561,3,94,47,0,561,577,1,0,0,0,562,564,5,26,0,0,563,562,1,0,0,0,563,
        564,1,0,0,0,564,566,1,0,0,0,565,567,5,31,0,0,566,565,1,0,0,0,566,
        567,1,0,0,0,567,568,1,0,0,0,568,569,3,140,70,0,569,571,5,7,0,0,570,
        572,3,88,44,0,571,570,1,0,0,0,571,572,1,0,0,0,572,573,1,0,0,0,573,
        574,5,8,0,0,574,575,3,94,47,0,575,577,1,0,0,0,576,538,1,0,0,0,576,
        552,1,0,0,0,576,563,1,0,0,0,577,87,1,0,0,0,578,583,3,90,45,0,579,
        580,5,13,0,0,580,582,3,90,45,0,581,579,1,0,0,0,582,585,1,0,0,0,583,
        581,1,0,0,0,583,584,1,0,0,0,584,588,1,0,0,0,585,583,1,0,0,0,586,
        587,5,13,0,0,587,589,3,92,46,0,588,586,1,0,0,0,588,589,1,0,0,0,589,
        592,1,0,0,0,590,592,3,92,46,0,591,578,1,0,0,0,591,590,1,0,0,0,592,
        89,1,0,0,0,593,596,3,116,58,0,594,595,5,14,0,0,595,597,3,114,57,
        0,596,594,1,0,0,0,596,597,1,0,0,0,597,91,1,0,0,0,598,599,5,18,0,
        0,599,600,3,114,57,0,600,93,1,0,0,0,601,603,5,9,0,0,602,604,3,96,
        48,0,603,602,1,0,0,0,603,604,1,0,0,0,604,605,1,0,0,0,605,606,5,11,
        0,0,606,95,1,0,0,0,607,609,3,2,1,0,608,607,1,0,0,0,609,610,1,0,0,
        0,610,608,1,0,0,0,610,611,1,0,0,0,611,97,1,0,0,0,612,613,5,5,0,0,
        613,614,3,100,50,0,614,615,5,6,0,0,615,99,1,0,0,0,616,618,5,13,0,
        0,617,616,1,0,0,0,618,621,1,0,0,0,619,617,1,0,0,0,619,620,1,0,0,
        0,620,623,1,0,0,0,621,619,1,0,0,0,622,624,3,102,51,0,623,622,1,0,
        0,0,623,624,1,0,0,0,624,633,1,0,0,0,625,627,5,13,0,0,626,625,1,0,
        0,0,627,628,1,0,0,0,628,626,1,0,0,0,628,629,1,0,0,0,629,630,1,0,
        0,0,630,632,3,102,51,0,631,626,1,0,0,0,632,635,1,0,0,0,633,631,1,
        0,0,0,633,634,1,0,0,0,634,639,1,0,0,0,635,633,1,0,0,0,636,638,5,
        13,0,0,637,636,1,0,0,0,638,641,1,0,0,0,639,637,1,0,0,0,639,640,1,
        0,0,0,640,101,1,0,0,0,641,639,1,0,0,0,642,644,5,18,0,0,643,642,1,
        0,0,0,643,644,1,0,0,0,644,645,1,0,0,0,645,646,3,114,57,0,646,103,
        1,0,0,0,647,648,3,106,53,0,648,649,5,17,0,0,649,650,3,114,57,0,650,
        687,1,0,0,0,651,652,5,5,0,0,652,653,3,114,57,0,653,654,5,6,0,0,654,
        655,5,17,0,0,655,656,3,114,57,0,656,687,1,0,0,0,657,659,5,107,0,
        0,658,657,1,0,0,0,658,659,1,0,0,0,659,661,1,0,0,0,660,662,5,26,0,
        0,661,660,1,0,0,0,661,662,1,0,0,0,662,663,1,0,0,0,663,664,3,106,
        53,0,664,666,5,7,0,0,665,667,3,88,44,0,666,665,1,0,0,0,666,667,1,
        0,0,0,667,668,1,0,0,0,668,669,5,8,0,0,669,670,3,94,47,0,670,687,
        1,0,0,0,671,672,3,138,69,0,672,673,5,7,0,0,673,674,5,8,0,0,674,675,
        3,94,47,0,675,687,1,0,0,0,676,677,3,140,70,0,677,678,5,7,0,0,678,
        679,3,90,45,0,679,680,5,8,0,0,680,681,3,94,47,0,681,687,1,0,0,0,
        682,684,5,18,0,0,683,682,1,0,0,0,683,684,1,0,0,0,684,685,1,0,0,0,
        685,687,3,114,57,0,686,647,1,0,0,0,686,651,1,0,0,0,686,658,1,0,0,
        0,686,671,1,0,0,0,686,676,1,0,0,0,686,683,1,0,0,0,687,105,1,0,0,
        0,688,696,3,142,71,0,689,696,5,120,0,0,690,696,3,134,67,0,691,692,
        5,5,0,0,692,693,3,114,57,0,693,694,5,6,0,0,694,696,1,0,0,0,695,688,
        1,0,0,0,695,689,1,0,0,0,695,690,1,0,0,0,695,691,1,0,0,0,696,107,
        1,0,0,0,697,709,5,7,0,0,698,703,3,110,55,0,699,700,5,13,0,0,700,
        702,3,110,55,0,701,699,1,0,0,0,702,705,1,0,0,0,703,701,1,0,0,0,703,
        704,1,0,0,0,704,707,1,0,0,0,705,703,1,0,0,0,706,708,5,13,0,0,707,
        706,1,0,0,0,707,708,1,0,0,0,708,710,1,0,0,0,709,698,1,0,0,0,709,
        710,1,0,0,0,710,711,1,0,0,0,711,712,5,8,0,0,712,109,1,0,0,0,713,
        715,5,18,0,0,714,713,1,0,0,0,714,715,1,0,0,0,715,718,1,0,0,0,716,
        719,3,114,57,0,717,719,3,144,72,0,718,716,1,0,0,0,718,717,1,0,0,
        0,719,111,1,0,0,0,720,725,3,114,57,0,721,722,5,13,0,0,722,724,3,
        114,57,0,723,721,1,0,0,0,724,727,1,0,0,0,725,723,1,0,0,0,725,726,
        1,0,0,0,726,113,1,0,0,0,727,725,1,0,0,0,728,729,6,57,-1,0,729,781,
        3,120,60,0,730,732,5,100,0,0,731,733,3,144,72,0,732,731,1,0,0,0,
        732,733,1,0,0,0,733,734,1,0,0,0,734,781,3,82,41,0,735,736,5,78,0,
        0,736,737,3,114,57,0,737,738,3,108,54,0,738,781,1,0,0,0,739,740,
        5,78,0,0,740,781,3,114,57,42,741,742,5,78,0,0,742,743,5,19,0,0,743,
        781,3,144,72,0,744,745,5,95,0,0,745,781,3,114,57,37,746,747,5,83,
        0,0,747,781,3,114,57,36,748,749,5,75,0,0,749,781,3,114,57,35,750,
        751,5,20,0,0,751,781,3,114,57,34,752,753,5,21,0,0,753,781,3,114,
        57,33,754,755,5,22,0,0,755,781,3,114,57,32,756,757,5,23,0,0,757,
        781,3,114,57,31,758,759,5,24,0,0,759,781,3,114,57,30,760,761,5,25,
        0,0,761,781,3,114,57,29,762,763,5,108,0,0,763,781,3,114,57,28,764,
        765,5,106,0,0,765,766,5,7,0,0,766,767,3,114,57,0,767,768,5,8,0,0,
        768,781,1,0,0,0,769,781,3,52,26,0,770,781,5,90,0,0,771,781,3,144,
        72,0,772,781,5,103,0,0,773,781,3,128,64,0,774,781,3,98,49,0,775,
        781,3,118,59,0,776,777,5,7,0,0,777,778,3,112,56,0,778,779,5,8,0,
        0,779,781,1,0,0,0,780,728,1,0,0,0,780,730,1,0,0,0,780,735,1,0,0,
        0,780,739,1,0,0,0,780,741,1,0,0,0,780,744,1,0,0,0,780,746,1,0,0,
        0,780,748,1,0,0,0,780,750,1,0,0,0,780,752,1,0,0,0,780,754,1,0,0,
        0,780,756,1,0,0,0,780,758,1,0,0,0,780,760,1,0,0,0,780,762,1,0,0,
        0,780,764,1,0,0,0,780,769,1,0,0,0,780,770,1,0,0,0,780,771,1,0,0,
        0,780,772,1,0,0,0,780,773,1,0,0,0,780,774,1,0,0,0,780,775,1,0,0,
        0,780,776,1,0,0,0,781,869,1,0,0,0,782,783,10,46,0,0,783,784,5,16,
        0,0,784,868,3,114,57,47,785,786,10,27,0,0,786,787,5,29,0,0,787,868,
        3,114,57,27,788,789,10,26,0,0,789,790,7,0,0,0,790,868,3,114,57,27,
        791,792,10,25,0,0,792,793,7,1,0,0,793,868,3,114,57,26,794,795,10,
        24,0,0,795,796,5,30,0,0,796,868,3,114,57,25,797,798,10,23,0,0,798,
        799,7,2,0,0,799,868,3,114,57,24,800,801,10,22,0,0,801,802,7,3,0,
        0,802,868,3,114,57,23,803,804,10,21,0,0,804,805,5,74,0,0,805,868,
        3,114,57,22,806,807,10,20,0,0,807,808,5,96,0,0,808,868,3,114,57,
        21,809,810,10,19,0,0,810,811,7,4,0,0,811,868,3,114,57,20,812,813,
        10,18,0,0,813,814,5,43,0,0,814,868,3,114,57,19,815,816,10,17,0,0,
        816,817,5,44,0,0,817,868,3,114,57,18,818,819,10,16,0,0,819,820,5,
        45,0,0,820,868,3,114,57,17,821,822,10,15,0,0,822,823,5,46,0,0,823,
        868,3,114,57,16,824,825,10,14,0,0,825,826,5,47,0,0,826,868,3,114,
        57,15,827,828,10,13,0,0,828,829,5,15,0,0,829,830,3,114,57,0,830,
        831,5,17,0,0,831,832,3,114,57,14,832,868,1,0,0,0,833,834,10,12,0,
        0,834,835,5,14,0,0,835,868,3,114,57,12,836,837,10,11,0,0,837,838,
        3,126,63,0,838,839,3,114,57,11,839,868,1,0,0,0,840,842,10,45,0,0,
        841,843,5,16,0,0,842,841,1,0,0,0,842,843,1,0,0,0,843,844,1,0,0,0,
        844,845,5,5,0,0,845,846,3,112,56,0,846,847,5,6,0,0,847,868,1,0,0,
        0,848,850,10,44,0,0,849,851,5,15,0,0,850,849,1,0,0,0,850,851,1,0,
        0,0,851,852,1,0,0,0,852,854,5,19,0,0,853,855,5,31,0,0,854,853,1,
        0,0,0,854,855,1,0,0,0,855,856,1,0,0,0,856,868,3,142,71,0,857,858,
        10,41,0,0,858,868,3,108,54,0,859,860,10,39,0,0,860,861,4,57,30,0,
        861,868,5,20,0,0,862,863,10,38,0,0,863,864,4,57,32,0,864,868,5,21,
        0,0,865,866,10,9,0,0,866,868,3,130,65,0,867,782,1,0,0,0,867,785,
        1,0,0,0,867,788,1,0,0,0,867,791,1,0,0,0,867,794,1,0,0,0,867,797,
        1,0,0,0,867,800,1,0,0,0,867,803,1,0,0,0,867,806,1,0,0,0,867,809,
        1,0,0,0,867,812,1,0,0,0,867,815,1,0,0,0,867,818,1,0,0,0,867,821,
        1,0,0,0,867,824,1,0,0,0,867,827,1,0,0,0,867,833,1,0,0,0,867,836,
        1,0,0,0,867,840,1,0,0,0,867,848,1,0,0,0,867,857,1,0,0,0,867,859,
        1,0,0,0,867,862,1,0,0,0,867,865,1,0,0,0,868,871,1,0,0,0,869,867,
        1,0,0,0,869,870,1,0,0,0,870,115,1,0,0,0,871,869,1,0,0,0,872,876,
        3,144,72,0,873,876,3,98,49,0,874,876,3,118,59,0,875,872,1,0,0,0,
        875,873,1,0,0,0,875,874,1,0,0,0,876,117,1,0,0,0,877,889,5,9,0,0,
        878,883,3,104,52,0,879,880,5,13,0,0,880,882,3,104,52,0,881,879,1,
        0,0,0,882,885,1,0,0,0,883,881,1,0,0,0,883,884,1,0,0,0,884,887,1,
        0,0,0,885,883,1,0,0,0,886,888,5,13,0,0,887,886,1,0,0,0,887,888,1,
        0,0,0,888,890,1,0,0,0,889,878,1,0,0,0,889,890,1,0,0,0,890,891,1,
        0,0,0,891,892,5,11,0,0,892,119,1,0,0,0,893,915,3,78,39,0,894,896,
        5,107,0,0,895,894,1,0,0,0,895,896,1,0,0,0,896,897,1,0,0,0,897,899,
        5,89,0,0,898,900,5,26,0,0,899,898,1,0,0,0,899,900,1,0,0,0,900,901,
        1,0,0,0,901,903,5,7,0,0,902,904,3,88,44,0,903,902,1,0,0,0,903,904,
        1,0,0,0,904,905,1,0,0,0,905,906,5,8,0,0,906,915,3,94,47,0,907,909,
        5,107,0,0,908,907,1,0,0,0,908,909,1,0,0,0,909,910,1,0,0,0,910,911,
        3,122,61,0,911,912,5,60,0,0,912,913,3,124,62,0,913,915,1,0,0,0,914,
        893,1,0,0,0,914,895,1,0,0,0,914,908,1,0,0,0,915,121,1,0,0,0,916,
        923,3,144,72,0,917,919,5,7,0,0,918,920,3,88,44,0,919,918,1,0,0,0,
        919,920,1,0,0,0,920,921,1,0,0,0,921,923,5,8,0,0,922,916,1,0,0,0,
        922,917,1,0,0,0,923,123,1,0,0,0,924,927,3,114,57,0,925,927,3,94,
        47,0,926,924,1,0,0,0,926,925,1,0,0,0,927,125,1,0,0,0,928,929,7,5,
        0,0,929,127,1,0,0,0,930,938,5,61,0,0,931,938,5,62,0,0,932,938,5,
        120,0,0,933,938,3,130,65,0,934,938,5,4,0,0,935,938,3,134,67,0,936,
        938,3,136,68,0,937,930,1,0,0,0,937,931,1,0,0,0,937,932,1,0,0,0,937,
        933,1,0,0,0,937,934,1,0,0,0,937,935,1,0,0,0,937,936,1,0,0,0,938,
        129,1,0,0,0,939,943,5,121,0,0,940,942,3,132,66,0,941,940,1,0,0,0,
        942,945,1,0,0,0,943,941,1,0,0,0,943,944,1,0,0,0,944,946,1,0,0,0,
        945,943,1,0,0,0,946,947,5,121,0,0,947,131,1,0,0,0,948,954,5,128,
        0,0,949,950,5,127,0,0,950,951,3,114,57,0,951,952,5,10,0,0,952,954,
        1,0,0,0,953,948,1,0,0,0,953,949,1,0,0,0,954,133,1,0,0,0,955,956,
        7,6,0,0,956,135,1,0,0,0,957,958,7,7,0,0,958,137,1,0,0,0,959,960,
        4,69,34,0,960,961,3,144,72,0,961,962,3,106,53,0,962,139,1,0,0,0,
        963,964,4,70,35,0,964,965,3,144,72,0,965,966,3,106,53,0,966,141,
        1,0,0,0,967,970,3,144,72,0,968,970,3,146,73,0,969,967,1,0,0,0,969,
        968,1,0,0,0,970,143,1,0,0,0,971,972,7,8,0,0,972,145,1,0,0,0,973,
        977,3,148,74,0,974,977,5,61,0,0,975,977,5,62,0,0,976,973,1,0,0,0,
        976,974,1,0,0,0,976,975,1,0,0,0,977,147,1,0,0,0,978,1025,5,72,0,
        0,979,1025,5,73,0,0,980,1025,5,74,0,0,981,1025,5,75,0,0,982,1025,
        5,76,0,0,983,1025,5,77,0,0,984,1025,5,78,0,0,985,1025,5,79,0,0,986,
        1025,5,80,0,0,987,1025,5,81,0,0,988,1025,5,82,0,0,989,1025,5,83,
        0,0,990,1025,5,84,0,0,991,1025,5,85,0,0,992,1025,5,86,0,0,993,1025,
        5,87,0,0,994,1025,5,88,0,0,995,1025,5,89,0,0,996,1025,5,90,0,0,997,
        1025,5,91,0,0,998,1025,5,92,0,0,999,1025,5,93,0,0,1000,1025,5,94,
        0,0,1001,1025,5,95,0,0,1002,1025,5,96,0,0,1003,1025,5,97,0,0,1004,
        1025,5,100,0,0,1005,1025,5,101,0,0,1006,1025,5,102,0,0,1007,1025,
        5,103,0,0,1008,1025,5,104,0,0,1009,1025,5,105,0,0,1010,1025,5,106,
        0,0,1011,1025,5,110,0,0,1012,1025,3,150,75,0,1013,1025,5,113,0,0,
        1014,1025,5,114,0,0,1015,1025,5,115,0,0,1016,1025,5,116,0,0,1017,
        1025,5,117,0,0,1018,1025,5,118,0,0,1019,1025,5,109,0,0,1020,1025,
        5,107,0,0,1021,1025,5,108,0,0,1022,1025,5,99,0,0,1023,1025,5,98,
        0,0,1024,978,1,0,0,0,1024,979,1,0,0,0,1024,980,1,0,0,0,1024,981,
        1,0,0,0,1024,982,1,0,0,0,1024,983,1,0,0,0,1024,984,1,0,0,0,1024,
        985,1,0,0,0,1024,986,1,0,0,0,1024,987,1,0,0,0,1024,988,1,0,0,0,1024,
        989,1,0,0,0,1024,990,1,0,0,0,1024,991,1,0,0,0,1024,992,1,0,0,0,1024,
        993,1,0,0,0,1024,994,1,0,0,0,1024,995,1,0,0,0,1024,996,1,0,0,0,1024,
        997,1,0,0,0,1024,998,1,0,0,0,1024,999,1,0,0,0,1024,1000,1,0,0,0,
        1024,1001,1,0,0,0,1024,1002,1,0,0,0,1024,1003,1,0,0,0,1024,1004,
        1,0,0,0,1024,1005,1,0,0,0,1024,1006,1,0,0,0,1024,1007,1,0,0,0,1024,
        1008,1,0,0,0,1024,1009,1,0,0,0,1024,1010,1,0,0,0,1024,1011,1,0,0,
        0,1024,1012,1,0,0,0,1024,1013,1,0,0,0,1024,1014,1,0,0,0,1024,1015,
        1,0,0,0,1024,1016,1,0,0,0,1024,1017,1,0,0,0,1024,1018,1,0,0,0,1024,
        1019,1,0,0,0,1024,1020,1,0,0,0,1024,1021,1,0,0,0,1024,1022,1,0,0,
        0,1024,1023,1,0,0,0,1025,149,1,0,0,0,1026,1027,7,9,0,0,1027,151,
        1,0,0,0,1028,1033,5,12,0,0,1029,1033,5,0,0,1,1030,1033,4,76,36,0,
        1031,1033,4,76,37,0,1032,1028,1,0,0,0,1032,1029,1,0,0,0,1032,1030,
        1,0,0,0,1032,1031,1,0,0,0,1033,153,1,0,0,0,113,155,158,184,188,195,
        201,205,212,220,225,227,236,240,248,253,262,270,274,279,290,296,
        311,331,335,339,347,356,361,369,374,379,386,393,400,418,422,424,
        431,437,442,457,460,465,468,479,483,488,499,505,514,516,525,529,
        535,538,541,546,552,555,563,566,571,576,583,588,591,596,603,610,
        619,623,628,633,639,643,658,661,666,683,686,695,703,707,709,714,
        718,725,732,780,842,850,854,867,869,875,883,887,889,895,899,903,
        908,914,919,922,926,937,943,953,969,976,1024,1032
    ]

class JavaScriptParser ( JavaScriptParserBase ):

    grammarFileName = "JavaScriptParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'['", "']'", "'('", "')'", "'{'", "<INVALID>", 
                     "'}'", "';'", "','", "'='", "'?'", "'?.'", "':'", "'...'", 
                     "'.'", "'++'", "'--'", "'+'", "'-'", "'~'", "'!'", 
                     "'*'", "'/'", "'%'", "'**'", "'??'", "'#'", "'>>'", 
                     "'<<'", "'>>>'", "'<'", "'>'", "'<='", "'>='", "'=='", 
                     "'!='", "'==='", "'!=='", "'&'", "'^'", "'|'", "'&&'", 
                     "'||'", "'*='", "'/='", "'%='", "'+='", "'-='", "'<<='", 
                     "'>>='", "'>>>='", "'&='", "'^='", "'|='", "'**='", 
                     "'=>'", "'null'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'break'", "'do'", 
                     "'instanceof'", "'typeof'", "'case'", "'else'", "'new'", 
                     "'var'", "'catch'", "'finally'", "'return'", "'void'", 
                     "'continue'", "'for'", "'switch'", "'while'", "'debugger'", 
                     "'function'", "'this'", "'with'", "'default'", "'if'", 
                     "'throw'", "'delete'", "'in'", "'try'", "'as'", "'from'", 
                     "'class'", "'enum'", "'extends'", "'super'", "'const'", 
                     "'export'", "'import'", "'async'", "'await'", "'yield'", 
                     "'implements'", "<INVALID>", "<INVALID>", "'private'", 
                     "'public'", "'interface'", "'package'", "'protected'", 
                     "'static'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'${'" ]

    symbolicNames = [ "<INVALID>", "HashBangLine", "MultiLineComment", "SingleLineComment", 
                      "RegularExpressionLiteral", "OpenBracket", "CloseBracket", 
                      "OpenParen", "CloseParen", "OpenBrace", "TemplateCloseBrace", 
                      "CloseBrace", "SemiColon", "Comma", "Assign", "QuestionMark", 
                      "QuestionMarkDot", "Colon", "Ellipsis", "Dot", "PlusPlus", 
                      "MinusMinus", "Plus", "Minus", "BitNot", "Not", "Multiply", 
                      "Divide", "Modulus", "Power", "NullCoalesce", "Hashtag", 
                      "RightShiftArithmetic", "LeftShiftArithmetic", "RightShiftLogical", 
                      "LessThan", "MoreThan", "LessThanEquals", "GreaterThanEquals", 
                      "Equals_", "NotEquals", "IdentityEquals", "IdentityNotEquals", 
                      "BitAnd", "BitXOr", "BitOr", "And", "Or", "MultiplyAssign", 
                      "DivideAssign", "ModulusAssign", "PlusAssign", "MinusAssign", 
                      "LeftShiftArithmeticAssign", "RightShiftArithmeticAssign", 
                      "RightShiftLogicalAssign", "BitAndAssign", "BitXorAssign", 
                      "BitOrAssign", "PowerAssign", "ARROW", "NullLiteral", 
                      "BooleanLiteral", "DecimalLiteral", "HexIntegerLiteral", 
                      "OctalIntegerLiteral", "OctalIntegerLiteral2", "BinaryIntegerLiteral", 
                      "BigHexIntegerLiteral", "BigOctalIntegerLiteral", 
                      "BigBinaryIntegerLiteral", "BigDecimalIntegerLiteral", 
                      "Break", "Do", "Instanceof", "Typeof", "Case", "Else", 
                      "New", "Var", "Catch", "Finally", "Return", "Void", 
                      "Continue", "For", "Switch", "While", "Debugger", 
                      "Function_", "This", "With", "Default", "If", "Throw", 
                      "Delete", "In", "Try", "As", "From", "Class", "Enum", 
                      "Extends", "Super", "Const", "Export", "Import", "Async", 
                      "Await", "Yield", "Implements", "StrictLet", "NonStrictLet", 
                      "Private", "Public", "Interface", "Package", "Protected", 
                      "Static", "Identifier", "StringLiteral", "BackTick", 
                      "WhiteSpaces", "LineTerminator", "HtmlComment", "CDataComment", 
                      "UnexpectedCharacter", "TemplateStringStartExpression", 
                      "TemplateStringAtom" ]

    RULE_program = 0
    RULE_sourceElement = 1
    RULE_statement = 2
    RULE_block = 3
    RULE_statementList = 4
    RULE_importStatement = 5
    RULE_importFromBlock = 6
    RULE_moduleItems = 7
    RULE_importDefault = 8
    RULE_importNamespace = 9
    RULE_importFrom = 10
    RULE_aliasName = 11
    RULE_exportStatement = 12
    RULE_exportFromBlock = 13
    RULE_declaration = 14
    RULE_variableStatement = 15
    RULE_variableDeclarationList = 16
    RULE_variableDeclaration = 17
    RULE_emptyStatement_ = 18
    RULE_expressionStatement = 19
    RULE_ifStatement = 20
    RULE_iterationStatement = 21
    RULE_varModifier = 22
    RULE_continueStatement = 23
    RULE_breakStatement = 24
    RULE_returnStatement = 25
    RULE_yieldStatement = 26
    RULE_withStatement = 27
    RULE_switchStatement = 28
    RULE_caseBlock = 29
    RULE_caseClauses = 30
    RULE_caseClause = 31
    RULE_defaultClause = 32
    RULE_labelledStatement = 33
    RULE_throwStatement = 34
    RULE_tryStatement = 35
    RULE_catchProduction = 36
    RULE_finallyProduction = 37
    RULE_debuggerStatement = 38
    RULE_functionDeclaration = 39
    RULE_classDeclaration = 40
    RULE_classTail = 41
    RULE_classElement = 42
    RULE_methodDefinition = 43
    RULE_formalParameterList = 44
    RULE_formalParameterArg = 45
    RULE_lastFormalParameterArg = 46
    RULE_functionBody = 47
    RULE_sourceElements = 48
    RULE_arrayLiteral = 49
    RULE_elementList = 50
    RULE_arrayElement = 51
    RULE_propertyAssignment = 52
    RULE_propertyName = 53
    RULE_arguments = 54
    RULE_argument = 55
    RULE_expressionSequence = 56
    RULE_singleExpression = 57
    RULE_assignable = 58
    RULE_objectLiteral = 59
    RULE_anonymousFunction = 60
    RULE_arrowFunctionParameters = 61
    RULE_arrowFunctionBody = 62
    RULE_assignmentOperator = 63
    RULE_literal = 64
    RULE_templateStringLiteral = 65
    RULE_templateStringAtom = 66
    RULE_numericLiteral = 67
    RULE_bigintLiteral = 68
    RULE_getter = 69
    RULE_setter = 70
    RULE_identifierName = 71
    RULE_identifier = 72
    RULE_reservedWord = 73
    RULE_keyword = 74
    RULE_let_ = 75
    RULE_eos = 76

    ruleNames =  [ "program", "sourceElement", "statement", "block", "statementList", 
                   "importStatement", "importFromBlock", "moduleItems", 
                   "importDefault", "importNamespace", "importFrom", "aliasName", 
                   "exportStatement", "exportFromBlock", "declaration", 
                   "variableStatement", "variableDeclarationList", "variableDeclaration", 
                   "emptyStatement_", "expressionStatement", "ifStatement", 
                   "iterationStatement", "varModifier", "continueStatement", 
                   "breakStatement", "returnStatement", "yieldStatement", 
                   "withStatement", "switchStatement", "caseBlock", "caseClauses", 
                   "caseClause", "defaultClause", "labelledStatement", "throwStatement", 
                   "tryStatement", "catchProduction", "finallyProduction", 
                   "debuggerStatement", "functionDeclaration", "classDeclaration", 
                   "classTail", "classElement", "methodDefinition", "formalParameterList", 
                   "formalParameterArg", "lastFormalParameterArg", "functionBody", 
                   "sourceElements", "arrayLiteral", "elementList", "arrayElement", 
                   "propertyAssignment", "propertyName", "arguments", "argument", 
                   "expressionSequence", "singleExpression", "assignable", 
                   "objectLiteral", "anonymousFunction", "arrowFunctionParameters", 
                   "arrowFunctionBody", "assignmentOperator", "literal", 
                   "templateStringLiteral", "templateStringAtom", "numericLiteral", 
                   "bigintLiteral", "getter", "setter", "identifierName", 
                   "identifier", "reservedWord", "keyword", "let_", "eos" ]

    EOF = Token.EOF
    HashBangLine=1
    MultiLineComment=2
    SingleLineComment=3
    RegularExpressionLiteral=4
    OpenBracket=5
    CloseBracket=6
    OpenParen=7
    CloseParen=8
    OpenBrace=9
    TemplateCloseBrace=10
    CloseBrace=11
    SemiColon=12
    Comma=13
    Assign=14
    QuestionMark=15
    QuestionMarkDot=16
    Colon=17
    Ellipsis=18
    Dot=19
    PlusPlus=20
    MinusMinus=21
    Plus=22
    Minus=23
    BitNot=24
    Not=25
    Multiply=26
    Divide=27
    Modulus=28
    Power=29
    NullCoalesce=30
    Hashtag=31
    RightShiftArithmetic=32
    LeftShiftArithmetic=33
    RightShiftLogical=34
    LessThan=35
    MoreThan=36
    LessThanEquals=37
    GreaterThanEquals=38
    Equals_=39
    NotEquals=40
    IdentityEquals=41
    IdentityNotEquals=42
    BitAnd=43
    BitXOr=44
    BitOr=45
    And=46
    Or=47
    MultiplyAssign=48
    DivideAssign=49
    ModulusAssign=50
    PlusAssign=51
    MinusAssign=52
    LeftShiftArithmeticAssign=53
    RightShiftArithmeticAssign=54
    RightShiftLogicalAssign=55
    BitAndAssign=56
    BitXorAssign=57
    BitOrAssign=58
    PowerAssign=59
    ARROW=60
    NullLiteral=61
    BooleanLiteral=62
    DecimalLiteral=63
    HexIntegerLiteral=64
    OctalIntegerLiteral=65
    OctalIntegerLiteral2=66
    BinaryIntegerLiteral=67
    BigHexIntegerLiteral=68
    BigOctalIntegerLiteral=69
    BigBinaryIntegerLiteral=70
    BigDecimalIntegerLiteral=71
    Break=72
    Do=73
    Instanceof=74
    Typeof=75
    Case=76
    Else=77
    New=78
    Var=79
    Catch=80
    Finally=81
    Return=82
    Void=83
    Continue=84
    For=85
    Switch=86
    While=87
    Debugger=88
    Function_=89
    This=90
    With=91
    Default=92
    If=93
    Throw=94
    Delete=95
    In=96
    Try=97
    As=98
    From=99
    Class=100
    Enum=101
    Extends=102
    Super=103
    Const=104
    Export=105
    Import=106
    Async=107
    Await=108
    Yield=109
    Implements=110
    StrictLet=111
    NonStrictLet=112
    Private=113
    Public=114
    Interface=115
    Package=116
    Protected=117
    Static=118
    Identifier=119
    StringLiteral=120
    BackTick=121
    WhiteSpaces=122
    LineTerminator=123
    HtmlComment=124
    CDataComment=125
    UnexpectedCharacter=126
    TemplateStringStartExpression=127
    TemplateStringAtom=128

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(JavaScriptParser.EOF, 0)

        def HashBangLine(self):
            return self.getToken(JavaScriptParser.HashBangLine, 0)

        def sourceElements(self):
            return self.getTypedRuleContext(JavaScriptParser.SourceElementsContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = JavaScriptParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 154
                self.match(JavaScriptParser.HashBangLine)


            self.state = 158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 157
                self.sourceElements()


            self.state = 160
            self.match(JavaScriptParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_sourceElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceElement" ):
                listener.enterSourceElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceElement" ):
                listener.exitSourceElement(self)




    def sourceElement(self):

        localctx = JavaScriptParser.SourceElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sourceElement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(JavaScriptParser.BlockContext,0)


        def variableStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableStatementContext,0)


        def importStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportStatementContext,0)


        def exportStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ExportStatementContext,0)


        def emptyStatement_(self):
            return self.getTypedRuleContext(JavaScriptParser.EmptyStatement_Context,0)


        def classDeclaration(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassDeclarationContext,0)


        def expressionStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.IfStatementContext,0)


        def iterationStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.IterationStatementContext,0)


        def continueStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ContinueStatementContext,0)


        def breakStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.BreakStatementContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ReturnStatementContext,0)


        def yieldStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.YieldStatementContext,0)


        def withStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.WithStatementContext,0)


        def labelledStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.LabelledStatementContext,0)


        def switchStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.SwitchStatementContext,0)


        def throwStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ThrowStatementContext,0)


        def tryStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.TryStatementContext,0)


        def debuggerStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.DebuggerStatementContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionDeclarationContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = JavaScriptParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        try:
            self.state = 184
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 164
                self.block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 165
                self.variableStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 166
                self.importStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 167
                self.exportStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 168
                self.emptyStatement_()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 169
                self.classDeclaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 170
                self.expressionStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 171
                self.ifStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 172
                self.iterationStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 173
                self.continueStatement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 174
                self.breakStatement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 175
                self.returnStatement()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 176
                self.yieldStatement()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 177
                self.withStatement()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 178
                self.labelledStatement()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 179
                self.switchStatement()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 180
                self.throwStatement()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 181
                self.tryStatement()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 182
                self.debuggerStatement()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 183
                self.functionDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def statementList(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)




    def block(self):

        localctx = JavaScriptParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(JavaScriptParser.OpenBrace)
            self.state = 188
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 187
                self.statementList()


            self.state = 190
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.StatementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.StatementContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_statementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementList" ):
                listener.enterStatementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementList" ):
                listener.exitStatementList(self)




    def statementList(self):

        localctx = JavaScriptParser.StatementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_statementList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 192
                    self.statement()

                else:
                    raise NoViableAltException(self)
                self.state = 195 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Import(self):
            return self.getToken(JavaScriptParser.Import, 0)

        def importFromBlock(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportFromBlockContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_importStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportStatement" ):
                listener.enterImportStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportStatement" ):
                listener.exitImportStatement(self)




    def importStatement(self):

        localctx = JavaScriptParser.ImportStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_importStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(JavaScriptParser.Import)
            self.state = 198
            self.importFromBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportFromBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importFrom(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportFromContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def importNamespace(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportNamespaceContext,0)


        def moduleItems(self):
            return self.getTypedRuleContext(JavaScriptParser.ModuleItemsContext,0)


        def importDefault(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportDefaultContext,0)


        def StringLiteral(self):
            return self.getToken(JavaScriptParser.StringLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importFromBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportFromBlock" ):
                listener.enterImportFromBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportFromBlock" ):
                listener.exitImportFromBlock(self)




    def importFromBlock(self):

        localctx = JavaScriptParser.ImportFromBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_importFromBlock)
        try:
            self.state = 212
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9, 26, 61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 201
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
                if la_ == 1:
                    self.state = 200
                    self.importDefault()


                self.state = 205
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [26, 61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]:
                    self.state = 203
                    self.importNamespace()
                    pass
                elif token in [9]:
                    self.state = 204
                    self.moduleItems()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 207
                self.importFrom()
                self.state = 208
                self.eos()
                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 2)
                self.state = 210
                self.match(JavaScriptParser.StringLiteral)
                self.state = 211
                self.eos()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModuleItemsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def aliasName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.AliasNameContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.AliasNameContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_moduleItems

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModuleItems" ):
                listener.enterModuleItems(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModuleItems" ):
                listener.exitModuleItems(self)




    def moduleItems(self):

        localctx = JavaScriptParser.ModuleItemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_moduleItems)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(JavaScriptParser.OpenBrace)
            self.state = 220
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 215
                    self.aliasName()
                    self.state = 216
                    self.match(JavaScriptParser.Comma) 
                self.state = 222
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

            self.state = 227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 61)) & ~0x3f) == 0 and ((1 << (_la - 61)) & 576460752303421443) != 0):
                self.state = 223
                self.aliasName()
                self.state = 225
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 224
                    self.match(JavaScriptParser.Comma)




            self.state = 229
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportDefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aliasName(self):
            return self.getTypedRuleContext(JavaScriptParser.AliasNameContext,0)


        def Comma(self):
            return self.getToken(JavaScriptParser.Comma, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importDefault

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportDefault" ):
                listener.enterImportDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportDefault" ):
                listener.exitImportDefault(self)




    def importDefault(self):

        localctx = JavaScriptParser.ImportDefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_importDefault)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.aliasName()
            self.state = 232
            self.match(JavaScriptParser.Comma)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportNamespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)

        def identifierName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.IdentifierNameContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,i)


        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importNamespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportNamespace" ):
                listener.enterImportNamespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportNamespace" ):
                listener.exitImportNamespace(self)




    def importNamespace(self):

        localctx = JavaScriptParser.ImportNamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_importNamespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26]:
                self.state = 234
                self.match(JavaScriptParser.Multiply)
                pass
            elif token in [61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]:
                self.state = 235
                self.identifierName()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 238
                self.match(JavaScriptParser.As)
                self.state = 239
                self.identifierName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportFromContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def From(self):
            return self.getToken(JavaScriptParser.From, 0)

        def StringLiteral(self):
            return self.getToken(JavaScriptParser.StringLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importFrom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportFrom" ):
                listener.enterImportFrom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportFrom" ):
                listener.exitImportFrom(self)




    def importFrom(self):

        localctx = JavaScriptParser.ImportFromContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_importFrom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            self.match(JavaScriptParser.From)
            self.state = 243
            self.match(JavaScriptParser.StringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.IdentifierNameContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,i)


        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_aliasName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAliasName" ):
                listener.enterAliasName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAliasName" ):
                listener.exitAliasName(self)




    def aliasName(self):

        localctx = JavaScriptParser.AliasNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_aliasName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self.identifierName()
            self.state = 248
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 246
                self.match(JavaScriptParser.As)
                self.state = 247
                self.identifierName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExportStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_exportStatement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExportDefaultDeclarationContext(ExportStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.ExportStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Export(self):
            return self.getToken(JavaScriptParser.Export, 0)
        def Default(self):
            return self.getToken(JavaScriptParser.Default, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExportDefaultDeclaration" ):
                listener.enterExportDefaultDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExportDefaultDeclaration" ):
                listener.exitExportDefaultDeclaration(self)


    class ExportDeclarationContext(ExportStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.ExportStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Export(self):
            return self.getToken(JavaScriptParser.Export, 0)
        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)

        def exportFromBlock(self):
            return self.getTypedRuleContext(JavaScriptParser.ExportFromBlockContext,0)

        def declaration(self):
            return self.getTypedRuleContext(JavaScriptParser.DeclarationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExportDeclaration" ):
                listener.enterExportDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExportDeclaration" ):
                listener.exitExportDeclaration(self)



    def exportStatement(self):

        localctx = JavaScriptParser.ExportStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_exportStatement)
        try:
            self.state = 262
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.ExportDeclarationContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 250
                self.match(JavaScriptParser.Export)
                self.state = 253
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
                if la_ == 1:
                    self.state = 251
                    self.exportFromBlock()
                    pass

                elif la_ == 2:
                    self.state = 252
                    self.declaration()
                    pass


                self.state = 255
                self.eos()
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.ExportDefaultDeclarationContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 257
                self.match(JavaScriptParser.Export)
                self.state = 258
                self.match(JavaScriptParser.Default)
                self.state = 259
                self.singleExpression(0)
                self.state = 260
                self.eos()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExportFromBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importNamespace(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportNamespaceContext,0)


        def importFrom(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportFromContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def moduleItems(self):
            return self.getTypedRuleContext(JavaScriptParser.ModuleItemsContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_exportFromBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExportFromBlock" ):
                listener.enterExportFromBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExportFromBlock" ):
                listener.exitExportFromBlock(self)




    def exportFromBlock(self):

        localctx = JavaScriptParser.ExportFromBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_exportFromBlock)
        try:
            self.state = 274
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26, 61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 264
                self.importNamespace()
                self.state = 265
                self.importFrom()
                self.state = 266
                self.eos()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 268
                self.moduleItems()
                self.state = 270
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
                if la_ == 1:
                    self.state = 269
                    self.importFrom()


                self.state = 272
                self.eos()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableStatementContext,0)


        def classDeclaration(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassDeclarationContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionDeclarationContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)




    def declaration(self):

        localctx = JavaScriptParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_declaration)
        try:
            self.state = 279
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [79, 104, 111, 112]:
                self.enterOuterAlt(localctx, 1)
                self.state = 276
                self.variableStatement()
                pass
            elif token in [100]:
                self.enterOuterAlt(localctx, 2)
                self.state = 277
                self.classDeclaration()
                pass
            elif token in [89, 107]:
                self.enterOuterAlt(localctx, 3)
                self.state = 278
                self.functionDeclaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclarationList(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationListContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_variableStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableStatement" ):
                listener.enterVariableStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableStatement" ):
                listener.exitVariableStatement(self)




    def variableStatement(self):

        localctx = JavaScriptParser.VariableStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_variableStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 281
            self.variableDeclarationList()
            self.state = 282
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varModifier(self):
            return self.getTypedRuleContext(JavaScriptParser.VarModifierContext,0)


        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_variableDeclarationList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclarationList" ):
                listener.enterVariableDeclarationList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclarationList" ):
                listener.exitVariableDeclarationList(self)




    def variableDeclarationList(self):

        localctx = JavaScriptParser.VariableDeclarationListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_variableDeclarationList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self.varModifier()
            self.state = 285
            self.variableDeclaration()
            self.state = 290
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 286
                    self.match(JavaScriptParser.Comma)
                    self.state = 287
                    self.variableDeclaration() 
                self.state = 292
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignable(self):
            return self.getTypedRuleContext(JavaScriptParser.AssignableContext,0)


        def Assign(self):
            return self.getToken(JavaScriptParser.Assign, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)




    def variableDeclaration(self):

        localctx = JavaScriptParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_variableDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.assignable()
            self.state = 296
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.state = 294
                self.match(JavaScriptParser.Assign)
                self.state = 295
                self.singleExpression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmptyStatement_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SemiColon(self):
            return self.getToken(JavaScriptParser.SemiColon, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_emptyStatement_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyStatement_" ):
                listener.enterEmptyStatement_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyStatement_" ):
                listener.exitEmptyStatement_(self)




    def emptyStatement_(self):

        localctx = JavaScriptParser.EmptyStatement_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_emptyStatement_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self.match(JavaScriptParser.SemiColon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_expressionStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatement" ):
                listener.enterExpressionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatement" ):
                listener.exitExpressionStatement(self)




    def expressionStatement(self):

        localctx = JavaScriptParser.ExpressionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_expressionStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            if not self.notOpenBraceAndNotFunction():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.notOpenBraceAndNotFunction()")
            self.state = 301
            self.expressionSequence()
            self.state = 302
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def If(self):
            return self.getToken(JavaScriptParser.If, 0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.StatementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.StatementContext,i)


        def Else(self):
            return self.getToken(JavaScriptParser.Else, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)




    def ifStatement(self):

        localctx = JavaScriptParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(JavaScriptParser.If)
            self.state = 305
            self.match(JavaScriptParser.OpenParen)
            self.state = 306
            self.expressionSequence()
            self.state = 307
            self.match(JavaScriptParser.CloseParen)
            self.state = 308
            self.statement()
            self.state = 311
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 309
                self.match(JavaScriptParser.Else)
                self.state = 310
                self.statement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IterationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_iterationStatement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DoStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Do(self):
            return self.getToken(JavaScriptParser.Do, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)

        def While(self):
            return self.getToken(JavaScriptParser.While, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoStatement" ):
                listener.enterDoStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoStatement" ):
                listener.exitDoStatement(self)


    class WhileStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def While(self):
            return self.getToken(JavaScriptParser.While, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStatement" ):
                listener.enterWhileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStatement" ):
                listener.exitWhileStatement(self)


    class ForStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(JavaScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def SemiColon(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.SemiColon)
            else:
                return self.getToken(JavaScriptParser.SemiColon, i)
        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)

        def expressionSequence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ExpressionSequenceContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,i)

        def variableDeclarationList(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStatement" ):
                listener.enterForStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStatement" ):
                listener.exitForStatement(self)


    class ForInStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(JavaScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def In(self):
            return self.getToken(JavaScriptParser.In, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def variableDeclarationList(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForInStatement" ):
                listener.enterForInStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForInStatement" ):
                listener.exitForInStatement(self)


    class ForOfStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(JavaScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def variableDeclarationList(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationListContext,0)

        def Await(self):
            return self.getToken(JavaScriptParser.Await, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForOfStatement" ):
                listener.enterForOfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForOfStatement" ):
                listener.exitForOfStatement(self)



    def iterationStatement(self):

        localctx = JavaScriptParser.IterationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_iterationStatement)
        self._la = 0 # Token type
        try:
            self.state = 369
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.DoStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 313
                self.match(JavaScriptParser.Do)
                self.state = 314
                self.statement()
                self.state = 315
                self.match(JavaScriptParser.While)
                self.state = 316
                self.match(JavaScriptParser.OpenParen)
                self.state = 317
                self.expressionSequence()
                self.state = 318
                self.match(JavaScriptParser.CloseParen)
                self.state = 319
                self.eos()
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.WhileStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 321
                self.match(JavaScriptParser.While)
                self.state = 322
                self.match(JavaScriptParser.OpenParen)
                self.state = 323
                self.expressionSequence()
                self.state = 324
                self.match(JavaScriptParser.CloseParen)
                self.state = 325
                self.statement()
                pass

            elif la_ == 3:
                localctx = JavaScriptParser.ForStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 327
                self.match(JavaScriptParser.For)
                self.state = 328
                self.match(JavaScriptParser.OpenParen)
                self.state = 331
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                if la_ == 1:
                    self.state = 329
                    self.expressionSequence()

                elif la_ == 2:
                    self.state = 330
                    self.variableDeclarationList()


                self.state = 333
                self.match(JavaScriptParser.SemiColon)
                self.state = 335
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009147632976) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 252549662710974719) != 0):
                    self.state = 334
                    self.expressionSequence()


                self.state = 337
                self.match(JavaScriptParser.SemiColon)
                self.state = 339
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009147632976) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 252549662710974719) != 0):
                    self.state = 338
                    self.expressionSequence()


                self.state = 341
                self.match(JavaScriptParser.CloseParen)
                self.state = 342
                self.statement()
                pass

            elif la_ == 4:
                localctx = JavaScriptParser.ForInStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 343
                self.match(JavaScriptParser.For)
                self.state = 344
                self.match(JavaScriptParser.OpenParen)
                self.state = 347
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
                if la_ == 1:
                    self.state = 345
                    self.singleExpression(0)
                    pass

                elif la_ == 2:
                    self.state = 346
                    self.variableDeclarationList()
                    pass


                self.state = 349
                self.match(JavaScriptParser.In)
                self.state = 350
                self.expressionSequence()
                self.state = 351
                self.match(JavaScriptParser.CloseParen)
                self.state = 352
                self.statement()
                pass

            elif la_ == 5:
                localctx = JavaScriptParser.ForOfStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 354
                self.match(JavaScriptParser.For)
                self.state = 356
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==108:
                    self.state = 355
                    self.match(JavaScriptParser.Await)


                self.state = 358
                self.match(JavaScriptParser.OpenParen)
                self.state = 361
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
                if la_ == 1:
                    self.state = 359
                    self.singleExpression(0)
                    pass

                elif la_ == 2:
                    self.state = 360
                    self.variableDeclarationList()
                    pass


                self.state = 363
                self.identifier()
                self.state = 364
                if not self.p("of"):
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.p(\"of\")")
                self.state = 365
                self.expressionSequence()
                self.state = 366
                self.match(JavaScriptParser.CloseParen)
                self.state = 367
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Var(self):
            return self.getToken(JavaScriptParser.Var, 0)

        def let_(self):
            return self.getTypedRuleContext(JavaScriptParser.Let_Context,0)


        def Const(self):
            return self.getToken(JavaScriptParser.Const, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_varModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarModifier" ):
                listener.enterVarModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarModifier" ):
                listener.exitVarModifier(self)




    def varModifier(self):

        localctx = JavaScriptParser.VarModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_varModifier)
        try:
            self.state = 374
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [79]:
                self.enterOuterAlt(localctx, 1)
                self.state = 371
                self.match(JavaScriptParser.Var)
                pass
            elif token in [111, 112]:
                self.enterOuterAlt(localctx, 2)
                self.state = 372
                self.let_()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 3)
                self.state = 373
                self.match(JavaScriptParser.Const)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContinueStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Continue(self):
            return self.getToken(JavaScriptParser.Continue, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_continueStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinueStatement" ):
                listener.enterContinueStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinueStatement" ):
                listener.exitContinueStatement(self)




    def continueStatement(self):

        localctx = JavaScriptParser.ContinueStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_continueStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(JavaScriptParser.Continue)
            self.state = 379
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.state = 377
                if not self.notLineTerminator():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.notLineTerminator()")
                self.state = 378
                self.identifier()


            self.state = 381
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Break(self):
            return self.getToken(JavaScriptParser.Break, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_breakStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakStatement" ):
                listener.enterBreakStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakStatement" ):
                listener.exitBreakStatement(self)




    def breakStatement(self):

        localctx = JavaScriptParser.BreakStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_breakStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.match(JavaScriptParser.Break)
            self.state = 386
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.state = 384
                if not self.notLineTerminator():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.notLineTerminator()")
                self.state = 385
                self.identifier()


            self.state = 388
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Return(self):
            return self.getToken(JavaScriptParser.Return, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)




    def returnStatement(self):

        localctx = JavaScriptParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 390
            self.match(JavaScriptParser.Return)
            self.state = 393
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 391
                if not self.notLineTerminator():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.notLineTerminator()")
                self.state = 392
                self.expressionSequence()


            self.state = 395
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YieldStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Yield(self):
            return self.getToken(JavaScriptParser.Yield, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_yieldStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldStatement" ):
                listener.enterYieldStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldStatement" ):
                listener.exitYieldStatement(self)




    def yieldStatement(self):

        localctx = JavaScriptParser.YieldStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_yieldStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            self.match(JavaScriptParser.Yield)
            self.state = 400
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.state = 398
                if not self.notLineTerminator():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.notLineTerminator()")
                self.state = 399
                self.expressionSequence()


            self.state = 402
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def With(self):
            return self.getToken(JavaScriptParser.With, 0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_withStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithStatement" ):
                listener.enterWithStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithStatement" ):
                listener.exitWithStatement(self)




    def withStatement(self):

        localctx = JavaScriptParser.WithStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_withStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 404
            self.match(JavaScriptParser.With)
            self.state = 405
            self.match(JavaScriptParser.OpenParen)
            self.state = 406
            self.expressionSequence()
            self.state = 407
            self.match(JavaScriptParser.CloseParen)
            self.state = 408
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SwitchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Switch(self):
            return self.getToken(JavaScriptParser.Switch, 0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def caseBlock(self):
            return self.getTypedRuleContext(JavaScriptParser.CaseBlockContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_switchStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitchStatement" ):
                listener.enterSwitchStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitchStatement" ):
                listener.exitSwitchStatement(self)




    def switchStatement(self):

        localctx = JavaScriptParser.SwitchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_switchStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.match(JavaScriptParser.Switch)
            self.state = 411
            self.match(JavaScriptParser.OpenParen)
            self.state = 412
            self.expressionSequence()
            self.state = 413
            self.match(JavaScriptParser.CloseParen)
            self.state = 414
            self.caseBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def caseClauses(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.CaseClausesContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.CaseClausesContext,i)


        def defaultClause(self):
            return self.getTypedRuleContext(JavaScriptParser.DefaultClauseContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_caseBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseBlock" ):
                listener.enterCaseBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseBlock" ):
                listener.exitCaseBlock(self)




    def caseBlock(self):

        localctx = JavaScriptParser.CaseBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_caseBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 416
            self.match(JavaScriptParser.OpenBrace)
            self.state = 418
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==76:
                self.state = 417
                self.caseClauses()


            self.state = 424
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==92:
                self.state = 420
                self.defaultClause()
                self.state = 422
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==76:
                    self.state = 421
                    self.caseClauses()




            self.state = 426
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def caseClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.CaseClauseContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.CaseClauseContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_caseClauses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClauses" ):
                listener.enterCaseClauses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClauses" ):
                listener.exitCaseClauses(self)




    def caseClauses(self):

        localctx = JavaScriptParser.CaseClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_caseClauses)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 429 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 428
                self.caseClause()
                self.state = 431 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==76):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Case(self):
            return self.getToken(JavaScriptParser.Case, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def statementList(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_caseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClause" ):
                listener.enterCaseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClause" ):
                listener.exitCaseClause(self)




    def caseClause(self):

        localctx = JavaScriptParser.CaseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_caseClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            self.match(JavaScriptParser.Case)
            self.state = 434
            self.expressionSequence()
            self.state = 435
            self.match(JavaScriptParser.Colon)
            self.state = 437
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.state = 436
                self.statementList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Default(self):
            return self.getToken(JavaScriptParser.Default, 0)

        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def statementList(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_defaultClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultClause" ):
                listener.enterDefaultClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultClause" ):
                listener.exitDefaultClause(self)




    def defaultClause(self):

        localctx = JavaScriptParser.DefaultClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_defaultClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            self.match(JavaScriptParser.Default)
            self.state = 440
            self.match(JavaScriptParser.Colon)
            self.state = 442
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.state = 441
                self.statementList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelledStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_labelledStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelledStatement" ):
                listener.enterLabelledStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelledStatement" ):
                listener.exitLabelledStatement(self)




    def labelledStatement(self):

        localctx = JavaScriptParser.LabelledStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_labelledStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self.identifier()
            self.state = 445
            self.match(JavaScriptParser.Colon)
            self.state = 446
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThrowStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Throw(self):
            return self.getToken(JavaScriptParser.Throw, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_throwStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThrowStatement" ):
                listener.enterThrowStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThrowStatement" ):
                listener.exitThrowStatement(self)




    def throwStatement(self):

        localctx = JavaScriptParser.ThrowStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_throwStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 448
            self.match(JavaScriptParser.Throw)
            self.state = 449
            if not self.notLineTerminator():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.notLineTerminator()")
            self.state = 450
            self.expressionSequence()
            self.state = 451
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TryStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Try(self):
            return self.getToken(JavaScriptParser.Try, 0)

        def block(self):
            return self.getTypedRuleContext(JavaScriptParser.BlockContext,0)


        def catchProduction(self):
            return self.getTypedRuleContext(JavaScriptParser.CatchProductionContext,0)


        def finallyProduction(self):
            return self.getTypedRuleContext(JavaScriptParser.FinallyProductionContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_tryStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTryStatement" ):
                listener.enterTryStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTryStatement" ):
                listener.exitTryStatement(self)




    def tryStatement(self):

        localctx = JavaScriptParser.TryStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_tryStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 453
            self.match(JavaScriptParser.Try)
            self.state = 454
            self.block()
            self.state = 460
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [80]:
                self.state = 455
                self.catchProduction()
                self.state = 457
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
                if la_ == 1:
                    self.state = 456
                    self.finallyProduction()


                pass
            elif token in [81]:
                self.state = 459
                self.finallyProduction()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CatchProductionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Catch(self):
            return self.getToken(JavaScriptParser.Catch, 0)

        def block(self):
            return self.getTypedRuleContext(JavaScriptParser.BlockContext,0)


        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def assignable(self):
            return self.getTypedRuleContext(JavaScriptParser.AssignableContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_catchProduction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCatchProduction" ):
                listener.enterCatchProduction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCatchProduction" ):
                listener.exitCatchProduction(self)




    def catchProduction(self):

        localctx = JavaScriptParser.CatchProductionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_catchProduction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self.match(JavaScriptParser.Catch)
            self.state = 468
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 463
                self.match(JavaScriptParser.OpenParen)
                self.state = 465
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==5 or _la==9 or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 2114049) != 0):
                    self.state = 464
                    self.assignable()


                self.state = 467
                self.match(JavaScriptParser.CloseParen)


            self.state = 470
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FinallyProductionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Finally(self):
            return self.getToken(JavaScriptParser.Finally, 0)

        def block(self):
            return self.getTypedRuleContext(JavaScriptParser.BlockContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_finallyProduction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFinallyProduction" ):
                listener.enterFinallyProduction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFinallyProduction" ):
                listener.exitFinallyProduction(self)




    def finallyProduction(self):

        localctx = JavaScriptParser.FinallyProductionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_finallyProduction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            self.match(JavaScriptParser.Finally)
            self.state = 473
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DebuggerStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Debugger(self):
            return self.getToken(JavaScriptParser.Debugger, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_debuggerStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDebuggerStatement" ):
                listener.enterDebuggerStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDebuggerStatement" ):
                listener.exitDebuggerStatement(self)




    def debuggerStatement(self):

        localctx = JavaScriptParser.DebuggerStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_debuggerStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            self.match(JavaScriptParser.Debugger)
            self.state = 476
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Function_(self):
            return self.getToken(JavaScriptParser.Function_, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)

        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)

        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_functionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDeclaration" ):
                listener.enterFunctionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDeclaration" ):
                listener.exitFunctionDeclaration(self)




    def functionDeclaration(self):

        localctx = JavaScriptParser.FunctionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_functionDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==107:
                self.state = 478
                self.match(JavaScriptParser.Async)


            self.state = 481
            self.match(JavaScriptParser.Function_)
            self.state = 483
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 482
                self.match(JavaScriptParser.Multiply)


            self.state = 485
            self.identifier()
            self.state = 486
            self.match(JavaScriptParser.OpenParen)
            self.state = 488
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 2114049) != 0):
                self.state = 487
                self.formalParameterList()


            self.state = 490
            self.match(JavaScriptParser.CloseParen)
            self.state = 491
            self.functionBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Class(self):
            return self.getToken(JavaScriptParser.Class, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def classTail(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassTailContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_classDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassDeclaration" ):
                listener.enterClassDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassDeclaration" ):
                listener.exitClassDeclaration(self)




    def classDeclaration(self):

        localctx = JavaScriptParser.ClassDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_classDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            self.match(JavaScriptParser.Class)
            self.state = 494
            self.identifier()
            self.state = 495
            self.classTail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassTailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def Extends(self):
            return self.getToken(JavaScriptParser.Extends, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def classElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ClassElementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ClassElementContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_classTail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassTail" ):
                listener.enterClassTail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassTail" ):
                listener.exitClassTail(self)




    def classTail(self):

        localctx = JavaScriptParser.ClassTailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_classTail)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 499
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==102:
                self.state = 497
                self.match(JavaScriptParser.Extends)
                self.state = 498
                self.singleExpression(0)


            self.state = 501
            self.match(JavaScriptParser.OpenBrace)
            self.state = 505
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,48,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 502
                    self.classElement() 
                self.state = 507
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,48,self._ctx)

            self.state = 508
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodDefinition(self):
            return self.getTypedRuleContext(JavaScriptParser.MethodDefinitionContext,0)


        def assignable(self):
            return self.getTypedRuleContext(JavaScriptParser.AssignableContext,0)


        def Assign(self):
            return self.getToken(JavaScriptParser.Assign, 0)

        def objectLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.ObjectLiteralContext,0)


        def SemiColon(self):
            return self.getToken(JavaScriptParser.SemiColon, 0)

        def Static(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Static)
            else:
                return self.getToken(JavaScriptParser.Static, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,i)


        def Async(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Async)
            else:
                return self.getToken(JavaScriptParser.Async, i)

        def emptyStatement_(self):
            return self.getTypedRuleContext(JavaScriptParser.EmptyStatement_Context,0)


        def propertyName(self):
            return self.getTypedRuleContext(JavaScriptParser.PropertyNameContext,0)


        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def Hashtag(self):
            return self.getToken(JavaScriptParser.Hashtag, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_classElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassElement" ):
                listener.enterClassElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassElement" ):
                listener.exitClassElement(self)




    def classElement(self):

        localctx = JavaScriptParser.ClassElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_classElement)
        self._la = 0 # Token type
        try:
            self.state = 535
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 516
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,50,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 514
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
                        if la_ == 1:
                            self.state = 510
                            self.match(JavaScriptParser.Static)
                            pass

                        elif la_ == 2:
                            self.state = 511
                            if not self.n("static"):
                                from antlr4.error.Errors import FailedPredicateException
                                raise FailedPredicateException(self, "self.n(\"static\")")
                            self.state = 512
                            self.identifier()
                            pass

                        elif la_ == 3:
                            self.state = 513
                            self.match(JavaScriptParser.Async)
                            pass

                 
                    self.state = 518
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,50,self._ctx)

                self.state = 525
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
                if la_ == 1:
                    self.state = 519
                    self.methodDefinition()
                    pass

                elif la_ == 2:
                    self.state = 520
                    self.assignable()
                    self.state = 521
                    self.match(JavaScriptParser.Assign)
                    self.state = 522
                    self.objectLiteral()
                    self.state = 523
                    self.match(JavaScriptParser.SemiColon)
                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 527
                self.emptyStatement_()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 529
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 528
                    self.match(JavaScriptParser.Hashtag)


                self.state = 531
                self.propertyName()
                self.state = 532
                self.match(JavaScriptParser.Assign)
                self.state = 533
                self.singleExpression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyName(self):
            return self.getTypedRuleContext(JavaScriptParser.PropertyNameContext,0)


        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)

        def Hashtag(self):
            return self.getToken(JavaScriptParser.Hashtag, 0)

        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def getter(self):
            return self.getTypedRuleContext(JavaScriptParser.GetterContext,0)


        def setter(self):
            return self.getTypedRuleContext(JavaScriptParser.SetterContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_methodDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodDefinition" ):
                listener.enterMethodDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodDefinition" ):
                listener.exitMethodDefinition(self)




    def methodDefinition(self):

        localctx = JavaScriptParser.MethodDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_methodDefinition)
        self._la = 0 # Token type
        try:
            self.state = 576
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 538
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 537
                    self.match(JavaScriptParser.Multiply)


                self.state = 541
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 540
                    self.match(JavaScriptParser.Hashtag)


                self.state = 543
                self.propertyName()
                self.state = 544
                self.match(JavaScriptParser.OpenParen)
                self.state = 546
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 2114049) != 0):
                    self.state = 545
                    self.formalParameterList()


                self.state = 548
                self.match(JavaScriptParser.CloseParen)
                self.state = 549
                self.functionBody()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 552
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
                if la_ == 1:
                    self.state = 551
                    self.match(JavaScriptParser.Multiply)


                self.state = 555
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                if la_ == 1:
                    self.state = 554
                    self.match(JavaScriptParser.Hashtag)


                self.state = 557
                self.getter()
                self.state = 558
                self.match(JavaScriptParser.OpenParen)
                self.state = 559
                self.match(JavaScriptParser.CloseParen)
                self.state = 560
                self.functionBody()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 563
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
                if la_ == 1:
                    self.state = 562
                    self.match(JavaScriptParser.Multiply)


                self.state = 566
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
                if la_ == 1:
                    self.state = 565
                    self.match(JavaScriptParser.Hashtag)


                self.state = 568
                self.setter()
                self.state = 569
                self.match(JavaScriptParser.OpenParen)
                self.state = 571
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 2114049) != 0):
                    self.state = 570
                    self.formalParameterList()


                self.state = 573
                self.match(JavaScriptParser.CloseParen)
                self.state = 574
                self.functionBody()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormalParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formalParameterArg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.FormalParameterArgContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.FormalParameterArgContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def lastFormalParameterArg(self):
            return self.getTypedRuleContext(JavaScriptParser.LastFormalParameterArgContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_formalParameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormalParameterList" ):
                listener.enterFormalParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormalParameterList" ):
                listener.exitFormalParameterList(self)




    def formalParameterList(self):

        localctx = JavaScriptParser.FormalParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_formalParameterList)
        self._la = 0 # Token type
        try:
            self.state = 591
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 9, 98, 107, 112, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 578
                self.formalParameterArg()
                self.state = 583
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,63,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 579
                        self.match(JavaScriptParser.Comma)
                        self.state = 580
                        self.formalParameterArg() 
                    self.state = 585
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,63,self._ctx)

                self.state = 588
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 586
                    self.match(JavaScriptParser.Comma)
                    self.state = 587
                    self.lastFormalParameterArg()


                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 590
                self.lastFormalParameterArg()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormalParameterArgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignable(self):
            return self.getTypedRuleContext(JavaScriptParser.AssignableContext,0)


        def Assign(self):
            return self.getToken(JavaScriptParser.Assign, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_formalParameterArg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormalParameterArg" ):
                listener.enterFormalParameterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormalParameterArg" ):
                listener.exitFormalParameterArg(self)




    def formalParameterArg(self):

        localctx = JavaScriptParser.FormalParameterArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_formalParameterArg)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.assignable()
            self.state = 596
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 594
                self.match(JavaScriptParser.Assign)
                self.state = 595
                self.singleExpression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LastFormalParameterArgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Ellipsis(self):
            return self.getToken(JavaScriptParser.Ellipsis, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_lastFormalParameterArg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLastFormalParameterArg" ):
                listener.enterLastFormalParameterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLastFormalParameterArg" ):
                listener.exitLastFormalParameterArg(self)




    def lastFormalParameterArg(self):

        localctx = JavaScriptParser.LastFormalParameterArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_lastFormalParameterArg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 598
            self.match(JavaScriptParser.Ellipsis)
            self.state = 599
            self.singleExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def sourceElements(self):
            return self.getTypedRuleContext(JavaScriptParser.SourceElementsContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_functionBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionBody" ):
                listener.enterFunctionBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionBody" ):
                listener.exitFunctionBody(self)




    def functionBody(self):

        localctx = JavaScriptParser.FunctionBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_functionBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 601
            self.match(JavaScriptParser.OpenBrace)
            self.state = 603
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.state = 602
                self.sourceElements()


            self.state = 605
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceElementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sourceElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SourceElementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SourceElementContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_sourceElements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceElements" ):
                listener.enterSourceElements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceElements" ):
                listener.exitSourceElements(self)




    def sourceElements(self):

        localctx = JavaScriptParser.SourceElementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_sourceElements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 608 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 607
                    self.sourceElement()

                else:
                    raise NoViableAltException(self)
                self.state = 610 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,68,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBracket(self):
            return self.getToken(JavaScriptParser.OpenBracket, 0)

        def elementList(self):
            return self.getTypedRuleContext(JavaScriptParser.ElementListContext,0)


        def CloseBracket(self):
            return self.getToken(JavaScriptParser.CloseBracket, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_arrayLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayLiteral" ):
                listener.enterArrayLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayLiteral" ):
                listener.exitArrayLiteral(self)




    def arrayLiteral(self):

        localctx = JavaScriptParser.ArrayLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_arrayLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 612
            self.match(JavaScriptParser.OpenBracket)
            self.state = 613
            self.elementList()
            self.state = 614
            self.match(JavaScriptParser.CloseBracket)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def arrayElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ArrayElementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ArrayElementContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_elementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementList" ):
                listener.enterElementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementList" ):
                listener.exitElementList(self)




    def elementList(self):

        localctx = JavaScriptParser.ElementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_elementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 619
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,69,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 616
                    self.match(JavaScriptParser.Comma) 
                self.state = 621
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,69,self._ctx)

            self.state = 623
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009147370832) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 252549662710974719) != 0):
                self.state = 622
                self.arrayElement()


            self.state = 633
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,72,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 626 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 625
                        self.match(JavaScriptParser.Comma)
                        self.state = 628 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==13):
                            break

                    self.state = 630
                    self.arrayElement() 
                self.state = 635
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,72,self._ctx)

            self.state = 639
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==13:
                self.state = 636
                self.match(JavaScriptParser.Comma)
                self.state = 641
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def Ellipsis(self):
            return self.getToken(JavaScriptParser.Ellipsis, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_arrayElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayElement" ):
                listener.enterArrayElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayElement" ):
                listener.exitArrayElement(self)




    def arrayElement(self):

        localctx = JavaScriptParser.ArrayElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_arrayElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 643
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==18:
                self.state = 642
                self.match(JavaScriptParser.Ellipsis)


            self.state = 645
            self.singleExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_propertyAssignment

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PropertyExpressionAssignmentContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def propertyName(self):
            return self.getTypedRuleContext(JavaScriptParser.PropertyNameContext,0)

        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyExpressionAssignment" ):
                listener.enterPropertyExpressionAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyExpressionAssignment" ):
                listener.exitPropertyExpressionAssignment(self)


    class ComputedPropertyExpressionAssignmentContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OpenBracket(self):
            return self.getToken(JavaScriptParser.OpenBracket, 0)
        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def CloseBracket(self):
            return self.getToken(JavaScriptParser.CloseBracket, 0)
        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComputedPropertyExpressionAssignment" ):
                listener.enterComputedPropertyExpressionAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComputedPropertyExpressionAssignment" ):
                listener.exitComputedPropertyExpressionAssignment(self)


    class PropertyShorthandContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def Ellipsis(self):
            return self.getToken(JavaScriptParser.Ellipsis, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyShorthand" ):
                listener.enterPropertyShorthand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyShorthand" ):
                listener.exitPropertyShorthand(self)


    class PropertySetterContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def setter(self):
            return self.getTypedRuleContext(JavaScriptParser.SetterContext,0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def formalParameterArg(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterArgContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertySetter" ):
                listener.enterPropertySetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertySetter" ):
                listener.exitPropertySetter(self)


    class PropertyGetterContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def getter(self):
            return self.getTypedRuleContext(JavaScriptParser.GetterContext,0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyGetter" ):
                listener.enterPropertyGetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyGetter" ):
                listener.exitPropertyGetter(self)


    class FunctionPropertyContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def propertyName(self):
            return self.getTypedRuleContext(JavaScriptParser.PropertyNameContext,0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)
        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)
        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionProperty" ):
                listener.enterFunctionProperty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionProperty" ):
                listener.exitFunctionProperty(self)



    def propertyAssignment(self):

        localctx = JavaScriptParser.PropertyAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_propertyAssignment)
        self._la = 0 # Token type
        try:
            self.state = 686
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.PropertyExpressionAssignmentContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 647
                self.propertyName()
                self.state = 648
                self.match(JavaScriptParser.Colon)
                self.state = 649
                self.singleExpression(0)
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.ComputedPropertyExpressionAssignmentContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 651
                self.match(JavaScriptParser.OpenBracket)
                self.state = 652
                self.singleExpression(0)
                self.state = 653
                self.match(JavaScriptParser.CloseBracket)
                self.state = 654
                self.match(JavaScriptParser.Colon)
                self.state = 655
                self.singleExpression(0)
                pass

            elif la_ == 3:
                localctx = JavaScriptParser.FunctionPropertyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 658
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
                if la_ == 1:
                    self.state = 657
                    self.match(JavaScriptParser.Async)


                self.state = 661
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 660
                    self.match(JavaScriptParser.Multiply)


                self.state = 663
                self.propertyName()
                self.state = 664
                self.match(JavaScriptParser.OpenParen)
                self.state = 666
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 2114049) != 0):
                    self.state = 665
                    self.formalParameterList()


                self.state = 668
                self.match(JavaScriptParser.CloseParen)
                self.state = 669
                self.functionBody()
                pass

            elif la_ == 4:
                localctx = JavaScriptParser.PropertyGetterContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 671
                self.getter()
                self.state = 672
                self.match(JavaScriptParser.OpenParen)
                self.state = 673
                self.match(JavaScriptParser.CloseParen)
                self.state = 674
                self.functionBody()
                pass

            elif la_ == 5:
                localctx = JavaScriptParser.PropertySetterContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 676
                self.setter()
                self.state = 677
                self.match(JavaScriptParser.OpenParen)
                self.state = 678
                self.formalParameterArg()
                self.state = 679
                self.match(JavaScriptParser.CloseParen)
                self.state = 680
                self.functionBody()
                pass

            elif la_ == 6:
                localctx = JavaScriptParser.PropertyShorthandContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 683
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==18:
                    self.state = 682
                    self.match(JavaScriptParser.Ellipsis)


                self.state = 685
                self.singleExpression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierName(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,0)


        def StringLiteral(self):
            return self.getToken(JavaScriptParser.StringLiteral, 0)

        def numericLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.NumericLiteralContext,0)


        def OpenBracket(self):
            return self.getToken(JavaScriptParser.OpenBracket, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def CloseBracket(self):
            return self.getToken(JavaScriptParser.CloseBracket, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_propertyName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyName" ):
                listener.enterPropertyName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyName" ):
                listener.exitPropertyName(self)




    def propertyName(self):

        localctx = JavaScriptParser.PropertyNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_propertyName)
        try:
            self.state = 695
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 688
                self.identifierName()
                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 2)
                self.state = 689
                self.match(JavaScriptParser.StringLiteral)
                pass
            elif token in [63, 64, 65, 66, 67]:
                self.enterOuterAlt(localctx, 3)
                self.state = 690
                self.numericLiteral()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 4)
                self.state = 691
                self.match(JavaScriptParser.OpenBracket)
                self.state = 692
                self.singleExpression(0)
                self.state = 693
                self.match(JavaScriptParser.CloseBracket)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ArgumentContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArguments" ):
                listener.enterArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArguments" ):
                listener.exitArguments(self)




    def arguments(self):

        localctx = JavaScriptParser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 697
            self.match(JavaScriptParser.OpenParen)
            self.state = 709
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009147370832) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 252549662710974719) != 0):
                self.state = 698
                self.argument()
                self.state = 703
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,81,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 699
                        self.match(JavaScriptParser.Comma)
                        self.state = 700
                        self.argument() 
                    self.state = 705
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,81,self._ctx)

                self.state = 707
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 706
                    self.match(JavaScriptParser.Comma)




            self.state = 711
            self.match(JavaScriptParser.CloseParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def Ellipsis(self):
            return self.getToken(JavaScriptParser.Ellipsis, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)




    def argument(self):

        localctx = JavaScriptParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_argument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 714
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==18:
                self.state = 713
                self.match(JavaScriptParser.Ellipsis)


            self.state = 718
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
            if la_ == 1:
                self.state = 716
                self.singleExpression(0)
                pass

            elif la_ == 2:
                self.state = 717
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionSequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_expressionSequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionSequence" ):
                listener.enterExpressionSequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionSequence" ):
                listener.exitExpressionSequence(self)




    def expressionSequence(self):

        localctx = JavaScriptParser.ExpressionSequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_expressionSequence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 720
            self.singleExpression(0)
            self.state = 725
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 721
                    self.match(JavaScriptParser.Comma)
                    self.state = 722
                    self.singleExpression(0) 
                self.state = 727
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_singleExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TemplateStringExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def templateStringLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.TemplateStringLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplateStringExpression" ):
                listener.enterTemplateStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplateStringExpression" ):
                listener.exitTemplateStringExpression(self)


    class TernaryExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def QuestionMark(self):
            return self.getToken(JavaScriptParser.QuestionMark, 0)
        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTernaryExpression" ):
                listener.enterTernaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTernaryExpression" ):
                listener.exitTernaryExpression(self)


    class LogicalAndExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def And(self):
            return self.getToken(JavaScriptParser.And, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalAndExpression" ):
                listener.enterLogicalAndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalAndExpression" ):
                listener.exitLogicalAndExpression(self)


    class PowerExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Power(self):
            return self.getToken(JavaScriptParser.Power, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)


    class PreIncrementExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PlusPlus(self):
            return self.getToken(JavaScriptParser.PlusPlus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreIncrementExpression" ):
                listener.enterPreIncrementExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreIncrementExpression" ):
                listener.exitPreIncrementExpression(self)


    class ObjectLiteralExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.ObjectLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteralExpression" ):
                listener.enterObjectLiteralExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteralExpression" ):
                listener.exitObjectLiteralExpression(self)


    class MetaExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def New(self):
            return self.getToken(JavaScriptParser.New, 0)
        def Dot(self):
            return self.getToken(JavaScriptParser.Dot, 0)
        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaExpression" ):
                listener.enterMetaExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaExpression" ):
                listener.exitMetaExpression(self)


    class InExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def In(self):
            return self.getToken(JavaScriptParser.In, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInExpression" ):
                listener.enterInExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInExpression" ):
                listener.exitInExpression(self)


    class LogicalOrExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Or(self):
            return self.getToken(JavaScriptParser.Or, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOrExpression" ):
                listener.enterLogicalOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOrExpression" ):
                listener.exitLogicalOrExpression(self)


    class OptionalChainExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def QuestionMarkDot(self):
            return self.getToken(JavaScriptParser.QuestionMarkDot, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionalChainExpression" ):
                listener.enterOptionalChainExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionalChainExpression" ):
                listener.exitOptionalChainExpression(self)


    class NotExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Not(self):
            return self.getToken(JavaScriptParser.Not, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotExpression" ):
                listener.enterNotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotExpression" ):
                listener.exitNotExpression(self)


    class PreDecreaseExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MinusMinus(self):
            return self.getToken(JavaScriptParser.MinusMinus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreDecreaseExpression" ):
                listener.enterPreDecreaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreDecreaseExpression" ):
                listener.exitPreDecreaseExpression(self)


    class ArgumentsExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def arguments(self):
            return self.getTypedRuleContext(JavaScriptParser.ArgumentsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentsExpression" ):
                listener.enterArgumentsExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentsExpression" ):
                listener.exitArgumentsExpression(self)


    class AwaitExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Await(self):
            return self.getToken(JavaScriptParser.Await, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAwaitExpression" ):
                listener.enterAwaitExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAwaitExpression" ):
                listener.exitAwaitExpression(self)


    class ThisExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def This(self):
            return self.getToken(JavaScriptParser.This, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThisExpression" ):
                listener.enterThisExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThisExpression" ):
                listener.exitThisExpression(self)


    class FunctionExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def anonymousFunction(self):
            return self.getTypedRuleContext(JavaScriptParser.AnonymousFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionExpression" ):
                listener.enterFunctionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionExpression" ):
                listener.exitFunctionExpression(self)


    class UnaryMinusExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Minus(self):
            return self.getToken(JavaScriptParser.Minus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinusExpression" ):
                listener.enterUnaryMinusExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinusExpression" ):
                listener.exitUnaryMinusExpression(self)


    class AssignmentExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Assign(self):
            return self.getToken(JavaScriptParser.Assign, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentExpression" ):
                listener.enterAssignmentExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentExpression" ):
                listener.exitAssignmentExpression(self)


    class PostDecreaseExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def MinusMinus(self):
            return self.getToken(JavaScriptParser.MinusMinus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostDecreaseExpression" ):
                listener.enterPostDecreaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostDecreaseExpression" ):
                listener.exitPostDecreaseExpression(self)


    class TypeofExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Typeof(self):
            return self.getToken(JavaScriptParser.Typeof, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeofExpression" ):
                listener.enterTypeofExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeofExpression" ):
                listener.exitTypeofExpression(self)


    class InstanceofExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Instanceof(self):
            return self.getToken(JavaScriptParser.Instanceof, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstanceofExpression" ):
                listener.enterInstanceofExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstanceofExpression" ):
                listener.exitInstanceofExpression(self)


    class UnaryPlusExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Plus(self):
            return self.getToken(JavaScriptParser.Plus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryPlusExpression" ):
                listener.enterUnaryPlusExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryPlusExpression" ):
                listener.exitUnaryPlusExpression(self)


    class DeleteExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Delete(self):
            return self.getToken(JavaScriptParser.Delete, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeleteExpression" ):
                listener.enterDeleteExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeleteExpression" ):
                listener.exitDeleteExpression(self)


    class ImportExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Import(self):
            return self.getToken(JavaScriptParser.Import, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportExpression" ):
                listener.enterImportExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportExpression" ):
                listener.exitImportExpression(self)


    class EqualityExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Equals_(self):
            return self.getToken(JavaScriptParser.Equals_, 0)
        def NotEquals(self):
            return self.getToken(JavaScriptParser.NotEquals, 0)
        def IdentityEquals(self):
            return self.getToken(JavaScriptParser.IdentityEquals, 0)
        def IdentityNotEquals(self):
            return self.getToken(JavaScriptParser.IdentityNotEquals, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEqualityExpression" ):
                listener.enterEqualityExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEqualityExpression" ):
                listener.exitEqualityExpression(self)


    class BitXOrExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def BitXOr(self):
            return self.getToken(JavaScriptParser.BitXOr, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitXOrExpression" ):
                listener.enterBitXOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitXOrExpression" ):
                listener.exitBitXOrExpression(self)


    class SuperExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Super(self):
            return self.getToken(JavaScriptParser.Super, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuperExpression" ):
                listener.enterSuperExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuperExpression" ):
                listener.exitSuperExpression(self)


    class MultiplicativeExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)
        def Divide(self):
            return self.getToken(JavaScriptParser.Divide, 0)
        def Modulus(self):
            return self.getToken(JavaScriptParser.Modulus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)


    class BitShiftExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def LeftShiftArithmetic(self):
            return self.getToken(JavaScriptParser.LeftShiftArithmetic, 0)
        def RightShiftArithmetic(self):
            return self.getToken(JavaScriptParser.RightShiftArithmetic, 0)
        def RightShiftLogical(self):
            return self.getToken(JavaScriptParser.RightShiftLogical, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitShiftExpression" ):
                listener.enterBitShiftExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitShiftExpression" ):
                listener.exitBitShiftExpression(self)


    class ParenthesizedExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)


    class AdditiveExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Plus(self):
            return self.getToken(JavaScriptParser.Plus, 0)
        def Minus(self):
            return self.getToken(JavaScriptParser.Minus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)


    class RelationalExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def LessThan(self):
            return self.getToken(JavaScriptParser.LessThan, 0)
        def MoreThan(self):
            return self.getToken(JavaScriptParser.MoreThan, 0)
        def LessThanEquals(self):
            return self.getToken(JavaScriptParser.LessThanEquals, 0)
        def GreaterThanEquals(self):
            return self.getToken(JavaScriptParser.GreaterThanEquals, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationalExpression" ):
                listener.enterRelationalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationalExpression" ):
                listener.exitRelationalExpression(self)


    class PostIncrementExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def PlusPlus(self):
            return self.getToken(JavaScriptParser.PlusPlus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostIncrementExpression" ):
                listener.enterPostIncrementExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostIncrementExpression" ):
                listener.exitPostIncrementExpression(self)


    class YieldExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def yieldStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.YieldStatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldExpression" ):
                listener.enterYieldExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldExpression" ):
                listener.exitYieldExpression(self)


    class BitNotExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BitNot(self):
            return self.getToken(JavaScriptParser.BitNot, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitNotExpression" ):
                listener.enterBitNotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitNotExpression" ):
                listener.exitBitNotExpression(self)


    class NewExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def New(self):
            return self.getToken(JavaScriptParser.New, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def arguments(self):
            return self.getTypedRuleContext(JavaScriptParser.ArgumentsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNewExpression" ):
                listener.enterNewExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNewExpression" ):
                listener.exitNewExpression(self)


    class LiteralExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(JavaScriptParser.LiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteralExpression" ):
                listener.enterLiteralExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteralExpression" ):
                listener.exitLiteralExpression(self)


    class ArrayLiteralExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def arrayLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.ArrayLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayLiteralExpression" ):
                listener.enterArrayLiteralExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayLiteralExpression" ):
                listener.exitArrayLiteralExpression(self)


    class MemberDotExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def Dot(self):
            return self.getToken(JavaScriptParser.Dot, 0)
        def identifierName(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,0)

        def QuestionMark(self):
            return self.getToken(JavaScriptParser.QuestionMark, 0)
        def Hashtag(self):
            return self.getToken(JavaScriptParser.Hashtag, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberDotExpression" ):
                listener.enterMemberDotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberDotExpression" ):
                listener.exitMemberDotExpression(self)


    class ClassExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Class(self):
            return self.getToken(JavaScriptParser.Class, 0)
        def classTail(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassTailContext,0)

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassExpression" ):
                listener.enterClassExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassExpression" ):
                listener.exitClassExpression(self)


    class MemberIndexExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def OpenBracket(self):
            return self.getToken(JavaScriptParser.OpenBracket, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseBracket(self):
            return self.getToken(JavaScriptParser.CloseBracket, 0)
        def QuestionMarkDot(self):
            return self.getToken(JavaScriptParser.QuestionMarkDot, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberIndexExpression" ):
                listener.enterMemberIndexExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberIndexExpression" ):
                listener.exitMemberIndexExpression(self)


    class IdentifierExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpression" ):
                listener.enterIdentifierExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpression" ):
                listener.exitIdentifierExpression(self)


    class BitAndExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def BitAnd(self):
            return self.getToken(JavaScriptParser.BitAnd, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitAndExpression" ):
                listener.enterBitAndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitAndExpression" ):
                listener.exitBitAndExpression(self)


    class BitOrExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def BitOr(self):
            return self.getToken(JavaScriptParser.BitOr, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitOrExpression" ):
                listener.enterBitOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitOrExpression" ):
                listener.exitBitOrExpression(self)


    class AssignmentOperatorExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def assignmentOperator(self):
            return self.getTypedRuleContext(JavaScriptParser.AssignmentOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentOperatorExpression" ):
                listener.enterAssignmentOperatorExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentOperatorExpression" ):
                listener.exitAssignmentOperatorExpression(self)


    class VoidExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Void(self):
            return self.getToken(JavaScriptParser.Void, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoidExpression" ):
                listener.enterVoidExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoidExpression" ):
                listener.exitVoidExpression(self)


    class CoalesceExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def NullCoalesce(self):
            return self.getToken(JavaScriptParser.NullCoalesce, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoalesceExpression" ):
                listener.enterCoalesceExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoalesceExpression" ):
                listener.exitCoalesceExpression(self)



    def singleExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = JavaScriptParser.SingleExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 114
        self.enterRecursionRule(localctx, 114, self.RULE_singleExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 780
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.FunctionExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 729
                self.anonymousFunction()
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.ClassExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 730
                self.match(JavaScriptParser.Class)
                self.state = 732
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 2114049) != 0):
                    self.state = 731
                    self.identifier()


                self.state = 734
                self.classTail()
                pass

            elif la_ == 3:
                localctx = JavaScriptParser.NewExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 735
                self.match(JavaScriptParser.New)
                self.state = 736
                self.singleExpression(0)
                self.state = 737
                self.arguments()
                pass

            elif la_ == 4:
                localctx = JavaScriptParser.NewExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 739
                self.match(JavaScriptParser.New)
                self.state = 740
                self.singleExpression(42)
                pass

            elif la_ == 5:
                localctx = JavaScriptParser.MetaExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 741
                self.match(JavaScriptParser.New)
                self.state = 742
                self.match(JavaScriptParser.Dot)
                self.state = 743
                self.identifier()
                pass

            elif la_ == 6:
                localctx = JavaScriptParser.DeleteExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 744
                self.match(JavaScriptParser.Delete)
                self.state = 745
                self.singleExpression(37)
                pass

            elif la_ == 7:
                localctx = JavaScriptParser.VoidExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 746
                self.match(JavaScriptParser.Void)
                self.state = 747
                self.singleExpression(36)
                pass

            elif la_ == 8:
                localctx = JavaScriptParser.TypeofExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 748
                self.match(JavaScriptParser.Typeof)
                self.state = 749
                self.singleExpression(35)
                pass

            elif la_ == 9:
                localctx = JavaScriptParser.PreIncrementExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 750
                self.match(JavaScriptParser.PlusPlus)
                self.state = 751
                self.singleExpression(34)
                pass

            elif la_ == 10:
                localctx = JavaScriptParser.PreDecreaseExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 752
                self.match(JavaScriptParser.MinusMinus)
                self.state = 753
                self.singleExpression(33)
                pass

            elif la_ == 11:
                localctx = JavaScriptParser.UnaryPlusExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 754
                self.match(JavaScriptParser.Plus)
                self.state = 755
                self.singleExpression(32)
                pass

            elif la_ == 12:
                localctx = JavaScriptParser.UnaryMinusExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 756
                self.match(JavaScriptParser.Minus)
                self.state = 757
                self.singleExpression(31)
                pass

            elif la_ == 13:
                localctx = JavaScriptParser.BitNotExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 758
                self.match(JavaScriptParser.BitNot)
                self.state = 759
                self.singleExpression(30)
                pass

            elif la_ == 14:
                localctx = JavaScriptParser.NotExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 760
                self.match(JavaScriptParser.Not)
                self.state = 761
                self.singleExpression(29)
                pass

            elif la_ == 15:
                localctx = JavaScriptParser.AwaitExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 762
                self.match(JavaScriptParser.Await)
                self.state = 763
                self.singleExpression(28)
                pass

            elif la_ == 16:
                localctx = JavaScriptParser.ImportExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 764
                self.match(JavaScriptParser.Import)
                self.state = 765
                self.match(JavaScriptParser.OpenParen)
                self.state = 766
                self.singleExpression(0)
                self.state = 767
                self.match(JavaScriptParser.CloseParen)
                pass

            elif la_ == 17:
                localctx = JavaScriptParser.YieldExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 769
                self.yieldStatement()
                pass

            elif la_ == 18:
                localctx = JavaScriptParser.ThisExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 770
                self.match(JavaScriptParser.This)
                pass

            elif la_ == 19:
                localctx = JavaScriptParser.IdentifierExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 771
                self.identifier()
                pass

            elif la_ == 20:
                localctx = JavaScriptParser.SuperExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 772
                self.match(JavaScriptParser.Super)
                pass

            elif la_ == 21:
                localctx = JavaScriptParser.LiteralExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 773
                self.literal()
                pass

            elif la_ == 22:
                localctx = JavaScriptParser.ArrayLiteralExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 774
                self.arrayLiteral()
                pass

            elif la_ == 23:
                localctx = JavaScriptParser.ObjectLiteralExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 775
                self.objectLiteral()
                pass

            elif la_ == 24:
                localctx = JavaScriptParser.ParenthesizedExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 776
                self.match(JavaScriptParser.OpenParen)
                self.state = 777
                self.expressionSequence()
                self.state = 778
                self.match(JavaScriptParser.CloseParen)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 869
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,93,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 867
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
                    if la_ == 1:
                        localctx = JavaScriptParser.OptionalChainExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 782
                        if not self.precpred(self._ctx, 46):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 46)")
                        self.state = 783
                        self.match(JavaScriptParser.QuestionMarkDot)
                        self.state = 784
                        self.singleExpression(47)
                        pass

                    elif la_ == 2:
                        localctx = JavaScriptParser.PowerExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 785
                        if not self.precpred(self._ctx, 27):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 27)")
                        self.state = 786
                        self.match(JavaScriptParser.Power)
                        self.state = 787
                        self.singleExpression(27)
                        pass

                    elif la_ == 3:
                        localctx = JavaScriptParser.MultiplicativeExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 788
                        if not self.precpred(self._ctx, 26):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 26)")
                        self.state = 789
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 469762048) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 790
                        self.singleExpression(27)
                        pass

                    elif la_ == 4:
                        localctx = JavaScriptParser.AdditiveExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 791
                        if not self.precpred(self._ctx, 25):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 25)")
                        self.state = 792
                        _la = self._input.LA(1)
                        if not(_la==22 or _la==23):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 793
                        self.singleExpression(26)
                        pass

                    elif la_ == 5:
                        localctx = JavaScriptParser.CoalesceExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 794
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 795
                        self.match(JavaScriptParser.NullCoalesce)
                        self.state = 796
                        self.singleExpression(25)
                        pass

                    elif la_ == 6:
                        localctx = JavaScriptParser.BitShiftExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 797
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 798
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 30064771072) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 799
                        self.singleExpression(24)
                        pass

                    elif la_ == 7:
                        localctx = JavaScriptParser.RelationalExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 800
                        if not self.precpred(self._ctx, 22):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 22)")
                        self.state = 801
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 515396075520) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 802
                        self.singleExpression(23)
                        pass

                    elif la_ == 8:
                        localctx = JavaScriptParser.InstanceofExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 803
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 804
                        self.match(JavaScriptParser.Instanceof)
                        self.state = 805
                        self.singleExpression(22)
                        pass

                    elif la_ == 9:
                        localctx = JavaScriptParser.InExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 806
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 807
                        self.match(JavaScriptParser.In)
                        self.state = 808
                        self.singleExpression(21)
                        pass

                    elif la_ == 10:
                        localctx = JavaScriptParser.EqualityExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 809
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 810
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8246337208320) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 811
                        self.singleExpression(20)
                        pass

                    elif la_ == 11:
                        localctx = JavaScriptParser.BitAndExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 812
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 813
                        self.match(JavaScriptParser.BitAnd)
                        self.state = 814
                        self.singleExpression(19)
                        pass

                    elif la_ == 12:
                        localctx = JavaScriptParser.BitXOrExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 815
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 816
                        self.match(JavaScriptParser.BitXOr)
                        self.state = 817
                        self.singleExpression(18)
                        pass

                    elif la_ == 13:
                        localctx = JavaScriptParser.BitOrExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 818
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 819
                        self.match(JavaScriptParser.BitOr)
                        self.state = 820
                        self.singleExpression(17)
                        pass

                    elif la_ == 14:
                        localctx = JavaScriptParser.LogicalAndExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 821
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 822
                        self.match(JavaScriptParser.And)
                        self.state = 823
                        self.singleExpression(16)
                        pass

                    elif la_ == 15:
                        localctx = JavaScriptParser.LogicalOrExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 824
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 825
                        self.match(JavaScriptParser.Or)
                        self.state = 826
                        self.singleExpression(15)
                        pass

                    elif la_ == 16:
                        localctx = JavaScriptParser.TernaryExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 827
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 828
                        self.match(JavaScriptParser.QuestionMark)
                        self.state = 829
                        self.singleExpression(0)
                        self.state = 830
                        self.match(JavaScriptParser.Colon)
                        self.state = 831
                        self.singleExpression(14)
                        pass

                    elif la_ == 17:
                        localctx = JavaScriptParser.AssignmentExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 833
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 834
                        self.match(JavaScriptParser.Assign)
                        self.state = 835
                        self.singleExpression(12)
                        pass

                    elif la_ == 18:
                        localctx = JavaScriptParser.AssignmentOperatorExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 836
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 837
                        self.assignmentOperator()
                        self.state = 838
                        self.singleExpression(11)
                        pass

                    elif la_ == 19:
                        localctx = JavaScriptParser.MemberIndexExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 840
                        if not self.precpred(self._ctx, 45):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 45)")
                        self.state = 842
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==16:
                            self.state = 841
                            self.match(JavaScriptParser.QuestionMarkDot)


                        self.state = 844
                        self.match(JavaScriptParser.OpenBracket)
                        self.state = 845
                        self.expressionSequence()
                        self.state = 846
                        self.match(JavaScriptParser.CloseBracket)
                        pass

                    elif la_ == 20:
                        localctx = JavaScriptParser.MemberDotExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 848
                        if not self.precpred(self._ctx, 44):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 44)")
                        self.state = 850
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==15:
                            self.state = 849
                            self.match(JavaScriptParser.QuestionMark)


                        self.state = 852
                        self.match(JavaScriptParser.Dot)
                        self.state = 854
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==31:
                            self.state = 853
                            self.match(JavaScriptParser.Hashtag)


                        self.state = 856
                        self.identifierName()
                        pass

                    elif la_ == 21:
                        localctx = JavaScriptParser.ArgumentsExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 857
                        if not self.precpred(self._ctx, 41):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 41)")
                        self.state = 858
                        self.arguments()
                        pass

                    elif la_ == 22:
                        localctx = JavaScriptParser.PostIncrementExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 859
                        if not self.precpred(self._ctx, 39):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 39)")
                        self.state = 860
                        if not self.notLineTerminator():
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.notLineTerminator()")
                        self.state = 861
                        self.match(JavaScriptParser.PlusPlus)
                        pass

                    elif la_ == 23:
                        localctx = JavaScriptParser.PostDecreaseExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 862
                        if not self.precpred(self._ctx, 38):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 38)")
                        self.state = 863
                        if not self.notLineTerminator():
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.notLineTerminator()")
                        self.state = 864
                        self.match(JavaScriptParser.MinusMinus)
                        pass

                    elif la_ == 24:
                        localctx = JavaScriptParser.TemplateStringExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 865
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 866
                        self.templateStringLiteral()
                        pass

             
                self.state = 871
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,93,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AssignableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def arrayLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.ArrayLiteralContext,0)


        def objectLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.ObjectLiteralContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_assignable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignable" ):
                listener.enterAssignable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignable" ):
                listener.exitAssignable(self)




    def assignable(self):

        localctx = JavaScriptParser.AssignableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_assignable)
        try:
            self.state = 875
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [98, 107, 112, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 872
                self.identifier()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 873
                self.arrayLiteral()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 3)
                self.state = 874
                self.objectLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def propertyAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.PropertyAssignmentContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.PropertyAssignmentContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_objectLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteral" ):
                listener.enterObjectLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteral" ):
                listener.exitObjectLiteral(self)




    def objectLiteral(self):

        localctx = JavaScriptParser.ObjectLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_objectLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 877
            self.match(JavaScriptParser.OpenBrace)
            self.state = 889
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                self.state = 878
                self.propertyAssignment()
                self.state = 883
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,95,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 879
                        self.match(JavaScriptParser.Comma)
                        self.state = 880
                        self.propertyAssignment() 
                    self.state = 885
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,95,self._ctx)

                self.state = 887
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 886
                    self.match(JavaScriptParser.Comma)




            self.state = 891
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnonymousFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_anonymousFunction

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AnonymousFunctionDeclContext(AnonymousFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.AnonymousFunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Function_(self):
            return self.getToken(JavaScriptParser.Function_, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)
        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)
        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnonymousFunctionDecl" ):
                listener.enterAnonymousFunctionDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnonymousFunctionDecl" ):
                listener.exitAnonymousFunctionDecl(self)


    class ArrowFunctionContext(AnonymousFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.AnonymousFunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def arrowFunctionParameters(self):
            return self.getTypedRuleContext(JavaScriptParser.ArrowFunctionParametersContext,0)

        def ARROW(self):
            return self.getToken(JavaScriptParser.ARROW, 0)
        def arrowFunctionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.ArrowFunctionBodyContext,0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrowFunction" ):
                listener.enterArrowFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrowFunction" ):
                listener.exitArrowFunction(self)


    class FunctionDeclContext(AnonymousFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.AnonymousFunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionDeclaration(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionDeclarationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDecl" ):
                listener.enterFunctionDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDecl" ):
                listener.exitFunctionDecl(self)



    def anonymousFunction(self):

        localctx = JavaScriptParser.AnonymousFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_anonymousFunction)
        self._la = 0 # Token type
        try:
            self.state = 914
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.FunctionDeclContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 893
                self.functionDeclaration()
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.AnonymousFunctionDeclContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 895
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==107:
                    self.state = 894
                    self.match(JavaScriptParser.Async)


                self.state = 897
                self.match(JavaScriptParser.Function_)
                self.state = 899
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 898
                    self.match(JavaScriptParser.Multiply)


                self.state = 901
                self.match(JavaScriptParser.OpenParen)
                self.state = 903
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 2114049) != 0):
                    self.state = 902
                    self.formalParameterList()


                self.state = 905
                self.match(JavaScriptParser.CloseParen)
                self.state = 906
                self.functionBody()
                pass

            elif la_ == 3:
                localctx = JavaScriptParser.ArrowFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 908
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
                if la_ == 1:
                    self.state = 907
                    self.match(JavaScriptParser.Async)


                self.state = 910
                self.arrowFunctionParameters()
                self.state = 911
                self.match(JavaScriptParser.ARROW)
                self.state = 912
                self.arrowFunctionBody()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrowFunctionParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_arrowFunctionParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrowFunctionParameters" ):
                listener.enterArrowFunctionParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrowFunctionParameters" ):
                listener.exitArrowFunctionParameters(self)




    def arrowFunctionParameters(self):

        localctx = JavaScriptParser.ArrowFunctionParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_arrowFunctionParameters)
        self._la = 0 # Token type
        try:
            self.state = 922
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [98, 107, 112, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 916
                self.identifier()
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 2)
                self.state = 917
                self.match(JavaScriptParser.OpenParen)
                self.state = 919
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 2114049) != 0):
                    self.state = 918
                    self.formalParameterList()


                self.state = 921
                self.match(JavaScriptParser.CloseParen)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrowFunctionBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_arrowFunctionBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrowFunctionBody" ):
                listener.enterArrowFunctionBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrowFunctionBody" ):
                listener.exitArrowFunctionBody(self)




    def arrowFunctionBody(self):

        localctx = JavaScriptParser.ArrowFunctionBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_arrowFunctionBody)
        try:
            self.state = 926
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 924
                self.singleExpression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 925
                self.functionBody()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MultiplyAssign(self):
            return self.getToken(JavaScriptParser.MultiplyAssign, 0)

        def DivideAssign(self):
            return self.getToken(JavaScriptParser.DivideAssign, 0)

        def ModulusAssign(self):
            return self.getToken(JavaScriptParser.ModulusAssign, 0)

        def PlusAssign(self):
            return self.getToken(JavaScriptParser.PlusAssign, 0)

        def MinusAssign(self):
            return self.getToken(JavaScriptParser.MinusAssign, 0)

        def LeftShiftArithmeticAssign(self):
            return self.getToken(JavaScriptParser.LeftShiftArithmeticAssign, 0)

        def RightShiftArithmeticAssign(self):
            return self.getToken(JavaScriptParser.RightShiftArithmeticAssign, 0)

        def RightShiftLogicalAssign(self):
            return self.getToken(JavaScriptParser.RightShiftLogicalAssign, 0)

        def BitAndAssign(self):
            return self.getToken(JavaScriptParser.BitAndAssign, 0)

        def BitXorAssign(self):
            return self.getToken(JavaScriptParser.BitXorAssign, 0)

        def BitOrAssign(self):
            return self.getToken(JavaScriptParser.BitOrAssign, 0)

        def PowerAssign(self):
            return self.getToken(JavaScriptParser.PowerAssign, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_assignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentOperator" ):
                listener.enterAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentOperator" ):
                listener.exitAssignmentOperator(self)




    def assignmentOperator(self):

        localctx = JavaScriptParser.AssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_assignmentOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 928
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1152640029630136320) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NullLiteral(self):
            return self.getToken(JavaScriptParser.NullLiteral, 0)

        def BooleanLiteral(self):
            return self.getToken(JavaScriptParser.BooleanLiteral, 0)

        def StringLiteral(self):
            return self.getToken(JavaScriptParser.StringLiteral, 0)

        def templateStringLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.TemplateStringLiteralContext,0)


        def RegularExpressionLiteral(self):
            return self.getToken(JavaScriptParser.RegularExpressionLiteral, 0)

        def numericLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.NumericLiteralContext,0)


        def bigintLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.BigintLiteralContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = JavaScriptParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_literal)
        try:
            self.state = 937
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [61]:
                self.enterOuterAlt(localctx, 1)
                self.state = 930
                self.match(JavaScriptParser.NullLiteral)
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 2)
                self.state = 931
                self.match(JavaScriptParser.BooleanLiteral)
                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 3)
                self.state = 932
                self.match(JavaScriptParser.StringLiteral)
                pass
            elif token in [121]:
                self.enterOuterAlt(localctx, 4)
                self.state = 933
                self.templateStringLiteral()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 5)
                self.state = 934
                self.match(JavaScriptParser.RegularExpressionLiteral)
                pass
            elif token in [63, 64, 65, 66, 67]:
                self.enterOuterAlt(localctx, 6)
                self.state = 935
                self.numericLiteral()
                pass
            elif token in [68, 69, 70, 71]:
                self.enterOuterAlt(localctx, 7)
                self.state = 936
                self.bigintLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemplateStringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BackTick(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.BackTick)
            else:
                return self.getToken(JavaScriptParser.BackTick, i)

        def templateStringAtom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.TemplateStringAtomContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.TemplateStringAtomContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_templateStringLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplateStringLiteral" ):
                listener.enterTemplateStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplateStringLiteral" ):
                listener.exitTemplateStringLiteral(self)




    def templateStringLiteral(self):

        localctx = JavaScriptParser.TemplateStringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_templateStringLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 939
            self.match(JavaScriptParser.BackTick)
            self.state = 943
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==127 or _la==128:
                self.state = 940
                self.templateStringAtom()
                self.state = 945
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 946
            self.match(JavaScriptParser.BackTick)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemplateStringAtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TemplateStringAtom(self):
            return self.getToken(JavaScriptParser.TemplateStringAtom, 0)

        def TemplateStringStartExpression(self):
            return self.getToken(JavaScriptParser.TemplateStringStartExpression, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def TemplateCloseBrace(self):
            return self.getToken(JavaScriptParser.TemplateCloseBrace, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_templateStringAtom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplateStringAtom" ):
                listener.enterTemplateStringAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplateStringAtom" ):
                listener.exitTemplateStringAtom(self)




    def templateStringAtom(self):

        localctx = JavaScriptParser.TemplateStringAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_templateStringAtom)
        try:
            self.state = 953
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [128]:
                self.enterOuterAlt(localctx, 1)
                self.state = 948
                self.match(JavaScriptParser.TemplateStringAtom)
                pass
            elif token in [127]:
                self.enterOuterAlt(localctx, 2)
                self.state = 949
                self.match(JavaScriptParser.TemplateStringStartExpression)
                self.state = 950
                self.singleExpression(0)
                self.state = 951
                self.match(JavaScriptParser.TemplateCloseBrace)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DecimalLiteral(self):
            return self.getToken(JavaScriptParser.DecimalLiteral, 0)

        def HexIntegerLiteral(self):
            return self.getToken(JavaScriptParser.HexIntegerLiteral, 0)

        def OctalIntegerLiteral(self):
            return self.getToken(JavaScriptParser.OctalIntegerLiteral, 0)

        def OctalIntegerLiteral2(self):
            return self.getToken(JavaScriptParser.OctalIntegerLiteral2, 0)

        def BinaryIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BinaryIntegerLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_numericLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericLiteral" ):
                listener.enterNumericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericLiteral" ):
                listener.exitNumericLiteral(self)




    def numericLiteral(self):

        localctx = JavaScriptParser.NumericLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_numericLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 955
            _la = self._input.LA(1)
            if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BigintLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BigDecimalIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BigDecimalIntegerLiteral, 0)

        def BigHexIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BigHexIntegerLiteral, 0)

        def BigOctalIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BigOctalIntegerLiteral, 0)

        def BigBinaryIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BigBinaryIntegerLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_bigintLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBigintLiteral" ):
                listener.enterBigintLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBigintLiteral" ):
                listener.exitBigintLiteral(self)




    def bigintLiteral(self):

        localctx = JavaScriptParser.BigintLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_bigintLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 957
            _la = self._input.LA(1)
            if not(((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def propertyName(self):
            return self.getTypedRuleContext(JavaScriptParser.PropertyNameContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_getter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetter" ):
                listener.enterGetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetter" ):
                listener.exitGetter(self)




    def getter(self):

        localctx = JavaScriptParser.GetterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_getter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 959
            if not self.n("get"):
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.n(\"get\")")
            self.state = 960
            self.identifier()
            self.state = 961
            self.propertyName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def propertyName(self):
            return self.getTypedRuleContext(JavaScriptParser.PropertyNameContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_setter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetter" ):
                listener.enterSetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetter" ):
                listener.exitSetter(self)




    def setter(self):

        localctx = JavaScriptParser.SetterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_setter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 963
            if not self.n("set"):
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.n(\"set\")")
            self.state = 964
            self.identifier()
            self.state = 965
            self.propertyName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def reservedWord(self):
            return self.getTypedRuleContext(JavaScriptParser.ReservedWordContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_identifierName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierName" ):
                listener.enterIdentifierName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierName" ):
                listener.exitIdentifierName(self)




    def identifierName(self):

        localctx = JavaScriptParser.IdentifierNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_identifierName)
        try:
            self.state = 969
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 967
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 968
                self.reservedWord()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(JavaScriptParser.Identifier, 0)

        def NonStrictLet(self):
            return self.getToken(JavaScriptParser.NonStrictLet, 0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)

        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = JavaScriptParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 971
            _la = self._input.LA(1)
            if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 2114049) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReservedWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keyword(self):
            return self.getTypedRuleContext(JavaScriptParser.KeywordContext,0)


        def NullLiteral(self):
            return self.getToken(JavaScriptParser.NullLiteral, 0)

        def BooleanLiteral(self):
            return self.getToken(JavaScriptParser.BooleanLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_reservedWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReservedWord" ):
                listener.enterReservedWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReservedWord" ):
                listener.exitReservedWord(self)




    def reservedWord(self):

        localctx = JavaScriptParser.ReservedWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_reservedWord)
        try:
            self.state = 976
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118]:
                self.enterOuterAlt(localctx, 1)
                self.state = 973
                self.keyword()
                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 2)
                self.state = 974
                self.match(JavaScriptParser.NullLiteral)
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 3)
                self.state = 975
                self.match(JavaScriptParser.BooleanLiteral)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Break(self):
            return self.getToken(JavaScriptParser.Break, 0)

        def Do(self):
            return self.getToken(JavaScriptParser.Do, 0)

        def Instanceof(self):
            return self.getToken(JavaScriptParser.Instanceof, 0)

        def Typeof(self):
            return self.getToken(JavaScriptParser.Typeof, 0)

        def Case(self):
            return self.getToken(JavaScriptParser.Case, 0)

        def Else(self):
            return self.getToken(JavaScriptParser.Else, 0)

        def New(self):
            return self.getToken(JavaScriptParser.New, 0)

        def Var(self):
            return self.getToken(JavaScriptParser.Var, 0)

        def Catch(self):
            return self.getToken(JavaScriptParser.Catch, 0)

        def Finally(self):
            return self.getToken(JavaScriptParser.Finally, 0)

        def Return(self):
            return self.getToken(JavaScriptParser.Return, 0)

        def Void(self):
            return self.getToken(JavaScriptParser.Void, 0)

        def Continue(self):
            return self.getToken(JavaScriptParser.Continue, 0)

        def For(self):
            return self.getToken(JavaScriptParser.For, 0)

        def Switch(self):
            return self.getToken(JavaScriptParser.Switch, 0)

        def While(self):
            return self.getToken(JavaScriptParser.While, 0)

        def Debugger(self):
            return self.getToken(JavaScriptParser.Debugger, 0)

        def Function_(self):
            return self.getToken(JavaScriptParser.Function_, 0)

        def This(self):
            return self.getToken(JavaScriptParser.This, 0)

        def With(self):
            return self.getToken(JavaScriptParser.With, 0)

        def Default(self):
            return self.getToken(JavaScriptParser.Default, 0)

        def If(self):
            return self.getToken(JavaScriptParser.If, 0)

        def Throw(self):
            return self.getToken(JavaScriptParser.Throw, 0)

        def Delete(self):
            return self.getToken(JavaScriptParser.Delete, 0)

        def In(self):
            return self.getToken(JavaScriptParser.In, 0)

        def Try(self):
            return self.getToken(JavaScriptParser.Try, 0)

        def Class(self):
            return self.getToken(JavaScriptParser.Class, 0)

        def Enum(self):
            return self.getToken(JavaScriptParser.Enum, 0)

        def Extends(self):
            return self.getToken(JavaScriptParser.Extends, 0)

        def Super(self):
            return self.getToken(JavaScriptParser.Super, 0)

        def Const(self):
            return self.getToken(JavaScriptParser.Const, 0)

        def Export(self):
            return self.getToken(JavaScriptParser.Export, 0)

        def Import(self):
            return self.getToken(JavaScriptParser.Import, 0)

        def Implements(self):
            return self.getToken(JavaScriptParser.Implements, 0)

        def let_(self):
            return self.getTypedRuleContext(JavaScriptParser.Let_Context,0)


        def Private(self):
            return self.getToken(JavaScriptParser.Private, 0)

        def Public(self):
            return self.getToken(JavaScriptParser.Public, 0)

        def Interface(self):
            return self.getToken(JavaScriptParser.Interface, 0)

        def Package(self):
            return self.getToken(JavaScriptParser.Package, 0)

        def Protected(self):
            return self.getToken(JavaScriptParser.Protected, 0)

        def Static(self):
            return self.getToken(JavaScriptParser.Static, 0)

        def Yield(self):
            return self.getToken(JavaScriptParser.Yield, 0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)

        def Await(self):
            return self.getToken(JavaScriptParser.Await, 0)

        def From(self):
            return self.getToken(JavaScriptParser.From, 0)

        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)




    def keyword(self):

        localctx = JavaScriptParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_keyword)
        try:
            self.state = 1024
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [72]:
                self.enterOuterAlt(localctx, 1)
                self.state = 978
                self.match(JavaScriptParser.Break)
                pass
            elif token in [73]:
                self.enterOuterAlt(localctx, 2)
                self.state = 979
                self.match(JavaScriptParser.Do)
                pass
            elif token in [74]:
                self.enterOuterAlt(localctx, 3)
                self.state = 980
                self.match(JavaScriptParser.Instanceof)
                pass
            elif token in [75]:
                self.enterOuterAlt(localctx, 4)
                self.state = 981
                self.match(JavaScriptParser.Typeof)
                pass
            elif token in [76]:
                self.enterOuterAlt(localctx, 5)
                self.state = 982
                self.match(JavaScriptParser.Case)
                pass
            elif token in [77]:
                self.enterOuterAlt(localctx, 6)
                self.state = 983
                self.match(JavaScriptParser.Else)
                pass
            elif token in [78]:
                self.enterOuterAlt(localctx, 7)
                self.state = 984
                self.match(JavaScriptParser.New)
                pass
            elif token in [79]:
                self.enterOuterAlt(localctx, 8)
                self.state = 985
                self.match(JavaScriptParser.Var)
                pass
            elif token in [80]:
                self.enterOuterAlt(localctx, 9)
                self.state = 986
                self.match(JavaScriptParser.Catch)
                pass
            elif token in [81]:
                self.enterOuterAlt(localctx, 10)
                self.state = 987
                self.match(JavaScriptParser.Finally)
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 11)
                self.state = 988
                self.match(JavaScriptParser.Return)
                pass
            elif token in [83]:
                self.enterOuterAlt(localctx, 12)
                self.state = 989
                self.match(JavaScriptParser.Void)
                pass
            elif token in [84]:
                self.enterOuterAlt(localctx, 13)
                self.state = 990
                self.match(JavaScriptParser.Continue)
                pass
            elif token in [85]:
                self.enterOuterAlt(localctx, 14)
                self.state = 991
                self.match(JavaScriptParser.For)
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 15)
                self.state = 992
                self.match(JavaScriptParser.Switch)
                pass
            elif token in [87]:
                self.enterOuterAlt(localctx, 16)
                self.state = 993
                self.match(JavaScriptParser.While)
                pass
            elif token in [88]:
                self.enterOuterAlt(localctx, 17)
                self.state = 994
                self.match(JavaScriptParser.Debugger)
                pass
            elif token in [89]:
                self.enterOuterAlt(localctx, 18)
                self.state = 995
                self.match(JavaScriptParser.Function_)
                pass
            elif token in [90]:
                self.enterOuterAlt(localctx, 19)
                self.state = 996
                self.match(JavaScriptParser.This)
                pass
            elif token in [91]:
                self.enterOuterAlt(localctx, 20)
                self.state = 997
                self.match(JavaScriptParser.With)
                pass
            elif token in [92]:
                self.enterOuterAlt(localctx, 21)
                self.state = 998
                self.match(JavaScriptParser.Default)
                pass
            elif token in [93]:
                self.enterOuterAlt(localctx, 22)
                self.state = 999
                self.match(JavaScriptParser.If)
                pass
            elif token in [94]:
                self.enterOuterAlt(localctx, 23)
                self.state = 1000
                self.match(JavaScriptParser.Throw)
                pass
            elif token in [95]:
                self.enterOuterAlt(localctx, 24)
                self.state = 1001
                self.match(JavaScriptParser.Delete)
                pass
            elif token in [96]:
                self.enterOuterAlt(localctx, 25)
                self.state = 1002
                self.match(JavaScriptParser.In)
                pass
            elif token in [97]:
                self.enterOuterAlt(localctx, 26)
                self.state = 1003
                self.match(JavaScriptParser.Try)
                pass
            elif token in [100]:
                self.enterOuterAlt(localctx, 27)
                self.state = 1004
                self.match(JavaScriptParser.Class)
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 28)
                self.state = 1005
                self.match(JavaScriptParser.Enum)
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 29)
                self.state = 1006
                self.match(JavaScriptParser.Extends)
                pass
            elif token in [103]:
                self.enterOuterAlt(localctx, 30)
                self.state = 1007
                self.match(JavaScriptParser.Super)
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 31)
                self.state = 1008
                self.match(JavaScriptParser.Const)
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 32)
                self.state = 1009
                self.match(JavaScriptParser.Export)
                pass
            elif token in [106]:
                self.enterOuterAlt(localctx, 33)
                self.state = 1010
                self.match(JavaScriptParser.Import)
                pass
            elif token in [110]:
                self.enterOuterAlt(localctx, 34)
                self.state = 1011
                self.match(JavaScriptParser.Implements)
                pass
            elif token in [111, 112]:
                self.enterOuterAlt(localctx, 35)
                self.state = 1012
                self.let_()
                pass
            elif token in [113]:
                self.enterOuterAlt(localctx, 36)
                self.state = 1013
                self.match(JavaScriptParser.Private)
                pass
            elif token in [114]:
                self.enterOuterAlt(localctx, 37)
                self.state = 1014
                self.match(JavaScriptParser.Public)
                pass
            elif token in [115]:
                self.enterOuterAlt(localctx, 38)
                self.state = 1015
                self.match(JavaScriptParser.Interface)
                pass
            elif token in [116]:
                self.enterOuterAlt(localctx, 39)
                self.state = 1016
                self.match(JavaScriptParser.Package)
                pass
            elif token in [117]:
                self.enterOuterAlt(localctx, 40)
                self.state = 1017
                self.match(JavaScriptParser.Protected)
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 41)
                self.state = 1018
                self.match(JavaScriptParser.Static)
                pass
            elif token in [109]:
                self.enterOuterAlt(localctx, 42)
                self.state = 1019
                self.match(JavaScriptParser.Yield)
                pass
            elif token in [107]:
                self.enterOuterAlt(localctx, 43)
                self.state = 1020
                self.match(JavaScriptParser.Async)
                pass
            elif token in [108]:
                self.enterOuterAlt(localctx, 44)
                self.state = 1021
                self.match(JavaScriptParser.Await)
                pass
            elif token in [99]:
                self.enterOuterAlt(localctx, 45)
                self.state = 1022
                self.match(JavaScriptParser.From)
                pass
            elif token in [98]:
                self.enterOuterAlt(localctx, 46)
                self.state = 1023
                self.match(JavaScriptParser.As)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Let_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NonStrictLet(self):
            return self.getToken(JavaScriptParser.NonStrictLet, 0)

        def StrictLet(self):
            return self.getToken(JavaScriptParser.StrictLet, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_let_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLet_" ):
                listener.enterLet_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLet_" ):
                listener.exitLet_(self)




    def let_(self):

        localctx = JavaScriptParser.Let_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_let_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1026
            _la = self._input.LA(1)
            if not(_la==111 or _la==112):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EosContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SemiColon(self):
            return self.getToken(JavaScriptParser.SemiColon, 0)

        def EOF(self):
            return self.getToken(JavaScriptParser.EOF, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_eos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEos" ):
                listener.enterEos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEos" ):
                listener.exitEos(self)




    def eos(self):

        localctx = JavaScriptParser.EosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_eos)
        try:
            self.state = 1032
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1028
                self.match(JavaScriptParser.SemiColon)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1029
                self.match(JavaScriptParser.EOF)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1030
                if not self.lineTerminatorAhead():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.lineTerminatorAhead()")
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1031
                if not self.closeBrace():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.closeBrace()")
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[19] = self.expressionStatement_sempred
        self._predicates[21] = self.iterationStatement_sempred
        self._predicates[23] = self.continueStatement_sempred
        self._predicates[24] = self.breakStatement_sempred
        self._predicates[25] = self.returnStatement_sempred
        self._predicates[26] = self.yieldStatement_sempred
        self._predicates[34] = self.throwStatement_sempred
        self._predicates[42] = self.classElement_sempred
        self._predicates[57] = self.singleExpression_sempred
        self._predicates[69] = self.getter_sempred
        self._predicates[70] = self.setter_sempred
        self._predicates[76] = self.eos_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expressionStatement_sempred(self, localctx:ExpressionStatementContext, predIndex:int):
            if predIndex == 0:
                return self.notOpenBraceAndNotFunction()
         

    def iterationStatement_sempred(self, localctx:IterationStatementContext, predIndex:int):
            if predIndex == 1:
                return self.p("of")
         

    def continueStatement_sempred(self, localctx:ContinueStatementContext, predIndex:int):
            if predIndex == 2:
                return self.notLineTerminator()
         

    def breakStatement_sempred(self, localctx:BreakStatementContext, predIndex:int):
            if predIndex == 3:
                return self.notLineTerminator()
         

    def returnStatement_sempred(self, localctx:ReturnStatementContext, predIndex:int):
            if predIndex == 4:
                return self.notLineTerminator()
         

    def yieldStatement_sempred(self, localctx:YieldStatementContext, predIndex:int):
            if predIndex == 5:
                return self.notLineTerminator()
         

    def throwStatement_sempred(self, localctx:ThrowStatementContext, predIndex:int):
            if predIndex == 6:
                return self.notLineTerminator()
         

    def classElement_sempred(self, localctx:ClassElementContext, predIndex:int):
            if predIndex == 7:
                return self.n("static")
         

    def singleExpression_sempred(self, localctx:SingleExpressionContext, predIndex:int):
            if predIndex == 8:
                return self.precpred(self._ctx, 46)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 27)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 26)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 25)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 24)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 23)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 22)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 20:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 21:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 22:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 23:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 24:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 25:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 26:
                return self.precpred(self._ctx, 45)
         

            if predIndex == 27:
                return self.precpred(self._ctx, 44)
         

            if predIndex == 28:
                return self.precpred(self._ctx, 41)
         

            if predIndex == 29:
                return self.precpred(self._ctx, 39)
         

            if predIndex == 30:
                return self.notLineTerminator()
         

            if predIndex == 31:
                return self.precpred(self._ctx, 38)
         

            if predIndex == 32:
                return self.notLineTerminator()
         

            if predIndex == 33:
                return self.precpred(self._ctx, 9)
         

    def getter_sempred(self, localctx:GetterContext, predIndex:int):
            if predIndex == 34:
                return self.n("get")
         

    def setter_sempred(self, localctx:SetterContext, predIndex:int):
            if predIndex == 35:
                return self.n("set")
         

    def eos_sempred(self, localctx:EosContext, predIndex:int):
            if predIndex == 36:
                return self.lineTerminatorAhead()
         

            if predIndex == 37:
                return self.closeBrace()
         




