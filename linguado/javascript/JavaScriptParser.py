# Generated from JavaScriptParser.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

if "." in __name__:
    from .JavaScriptParserBase import JavaScriptParserBase
else:
    from JavaScriptParserBase import JavaScriptParserBase

def serializedATN():
    return [
        4,1,129,1095,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,1,0,3,0,174,8,0,1,0,3,0,177,8,0,1,0,1,0,1,1,1,1,1,2,1,2,
        1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
        1,2,1,2,3,2,203,8,2,1,3,1,3,3,3,207,8,3,1,3,1,3,1,4,4,4,212,8,4,
        11,4,12,4,213,1,5,1,5,1,5,1,6,3,6,220,8,6,1,6,1,6,3,6,224,8,6,1,
        6,1,6,1,6,1,6,1,6,3,6,231,8,6,1,7,1,7,1,7,1,7,5,7,237,8,7,10,7,12,
        7,240,9,7,1,7,1,7,3,7,244,8,7,3,7,246,8,7,1,7,1,7,1,8,1,8,1,8,3,
        8,253,8,8,1,9,1,9,3,9,257,8,9,1,10,1,10,1,11,1,11,1,11,1,12,1,12,
        3,12,266,8,12,1,12,1,12,3,12,270,8,12,1,13,1,13,1,13,1,14,1,14,1,
        14,3,14,278,8,14,1,15,1,15,3,15,282,8,15,1,15,1,15,3,15,286,8,15,
        1,15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,295,8,15,1,16,1,16,1,16,
        1,16,1,16,1,16,3,16,303,8,16,1,16,1,16,3,16,307,8,16,1,17,1,17,1,
        17,1,17,5,17,313,8,17,10,17,12,17,316,9,17,1,17,1,17,3,17,320,8,
        17,3,17,322,8,17,1,17,1,17,1,18,1,18,1,18,3,18,329,8,18,1,19,1,19,
        1,19,3,19,334,8,19,1,20,1,20,1,20,1,21,1,21,1,21,1,21,5,21,343,8,
        21,10,21,12,21,346,9,21,1,22,1,22,1,22,3,22,351,8,22,1,23,1,23,1,
        24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,25,1,25,1,25,3,25,366,8,
        25,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,
        26,1,26,1,26,1,26,1,26,1,26,3,26,386,8,26,1,26,1,26,3,26,390,8,26,
        1,26,1,26,3,26,394,8,26,1,26,1,26,1,26,1,26,1,26,1,26,3,26,402,8,
        26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,3,26,411,8,26,1,26,1,26,1,
        26,3,26,416,8,26,1,26,1,26,1,26,1,26,1,26,3,26,423,8,26,1,27,1,27,
        1,27,3,27,428,8,27,1,28,1,28,1,28,3,28,433,8,28,1,28,1,28,1,29,1,
        29,1,29,3,29,440,8,29,1,29,1,29,1,30,1,30,1,30,3,30,447,8,30,1,30,
        1,30,1,31,1,31,1,31,3,31,454,8,31,1,31,1,31,1,32,1,32,1,32,1,32,
        1,32,1,32,1,33,1,33,1,33,1,33,1,33,1,33,1,34,1,34,3,34,472,8,34,
        1,34,1,34,3,34,476,8,34,3,34,478,8,34,1,34,1,34,1,35,4,35,483,8,
        35,11,35,12,35,484,1,36,1,36,1,36,1,36,3,36,491,8,36,1,37,1,37,1,
        37,3,37,496,8,37,1,38,1,38,1,38,1,38,1,39,1,39,1,39,1,39,1,39,1,
        40,1,40,1,40,1,40,3,40,511,8,40,1,40,3,40,514,8,40,1,41,1,41,1,41,
        3,41,519,8,41,1,41,3,41,522,8,41,1,41,1,41,1,42,1,42,1,42,1,43,1,
        43,1,43,1,44,3,44,533,8,44,1,44,1,44,3,44,537,8,44,1,44,1,44,1,44,
        3,44,542,8,44,1,44,1,44,1,44,1,45,1,45,1,45,1,45,1,46,1,46,3,46,
        553,8,46,1,46,1,46,5,46,557,8,46,10,46,12,46,560,9,46,1,46,1,46,
        1,47,1,47,1,47,3,47,567,8,47,1,47,1,47,1,47,1,47,3,47,573,8,47,1,
        47,1,47,1,47,1,47,3,47,579,8,47,1,47,1,47,3,47,583,8,47,1,48,1,48,
        3,48,587,8,48,1,48,3,48,590,8,48,1,48,1,48,1,48,3,48,595,8,48,1,
        48,1,48,1,48,1,48,3,48,601,8,48,1,48,1,48,1,48,1,48,1,48,1,48,3,
        48,609,8,48,1,48,1,48,1,48,3,48,614,8,48,1,48,1,48,1,48,3,48,619,
        8,48,1,49,1,49,3,49,623,8,49,1,50,1,50,3,50,627,8,50,1,51,1,51,1,
        51,1,52,1,52,1,52,5,52,635,8,52,10,52,12,52,638,9,52,1,52,1,52,3,
        52,642,8,52,1,52,3,52,645,8,52,1,53,1,53,1,53,3,53,650,8,53,1,54,
        1,54,1,54,1,55,1,55,3,55,657,8,55,1,55,1,55,1,56,4,56,662,8,56,11,
        56,12,56,663,1,57,1,57,1,57,1,57,1,58,5,58,671,8,58,10,58,12,58,
        674,9,58,1,58,3,58,677,8,58,1,58,4,58,680,8,58,11,58,12,58,681,1,
        58,5,58,685,8,58,10,58,12,58,688,9,58,1,58,5,58,691,8,58,10,58,12,
        58,694,9,58,1,59,3,59,697,8,59,1,59,1,59,1,60,1,60,1,60,1,60,1,60,
        1,60,1,60,1,60,1,60,1,60,1,60,3,60,712,8,60,1,60,3,60,715,8,60,1,
        60,1,60,1,60,3,60,720,8,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,
        60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,3,60,737,8,60,1,60,3,60,740,
        8,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,3,61,749,8,61,1,62,1,62,
        1,62,1,62,5,62,755,8,62,10,62,12,62,758,9,62,1,62,3,62,761,8,62,
        3,62,763,8,62,1,62,1,62,1,63,3,63,768,8,63,1,63,1,63,3,63,772,8,
        63,1,64,1,64,1,64,5,64,777,8,64,10,64,12,64,780,9,64,1,65,1,65,1,
        65,1,65,3,65,786,8,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,1,65,1,65,3,65,838,8,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,3,65,900,8,65,1,65,1,65,1,65,1,65,1,65,1,65,3,65,908,8,65,1,65,
        1,65,3,65,912,8,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,
        1,65,1,65,5,65,925,8,65,10,65,12,65,928,9,65,1,66,1,66,1,66,1,67,
        1,67,1,67,3,67,936,8,67,1,68,1,68,1,68,1,68,5,68,942,8,68,10,68,
        12,68,945,9,68,1,68,3,68,948,8,68,3,68,950,8,68,1,68,1,68,1,69,3,
        69,955,8,69,1,69,1,69,3,69,959,8,69,1,69,1,69,3,69,963,8,69,1,69,
        1,69,1,69,3,69,968,8,69,1,69,1,69,1,69,1,69,3,69,974,8,69,1,70,1,
        70,1,70,3,70,979,8,70,1,70,3,70,982,8,70,1,71,1,71,3,71,986,8,71,
        1,72,1,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,997,8,73,1,74,
        1,74,5,74,1001,8,74,10,74,12,74,1004,9,74,1,74,1,74,1,75,1,75,1,
        75,1,75,1,75,3,75,1013,8,75,1,76,1,76,1,77,1,77,1,78,1,78,1,78,1,
        78,1,79,1,79,1,79,1,79,1,80,1,80,3,80,1029,8,80,1,81,1,81,1,82,1,
        82,1,82,3,82,1036,8,82,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,
        83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,
        83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,
        83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,3,
        83,1085,8,83,1,84,1,84,1,85,1,85,1,85,1,85,3,85,1093,8,85,1,85,0,
        1,130,86,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
        40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,
        84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,
        120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,
        152,154,156,158,160,162,164,166,168,170,0,11,2,0,109,110,120,120,
        1,0,26,28,1,0,22,23,1,0,32,34,1,0,35,38,1,0,39,42,1,0,48,59,1,0,
        63,67,1,0,68,71,5,0,98,100,108,108,110,110,113,113,120,120,1,0,112,
        113,1261,0,173,1,0,0,0,2,180,1,0,0,0,4,202,1,0,0,0,6,204,1,0,0,0,
        8,211,1,0,0,0,10,215,1,0,0,0,12,230,1,0,0,0,14,232,1,0,0,0,16,249,
        1,0,0,0,18,256,1,0,0,0,20,258,1,0,0,0,22,260,1,0,0,0,24,265,1,0,
        0,0,26,271,1,0,0,0,28,274,1,0,0,0,30,294,1,0,0,0,32,306,1,0,0,0,
        34,308,1,0,0,0,36,325,1,0,0,0,38,333,1,0,0,0,40,335,1,0,0,0,42,338,
        1,0,0,0,44,347,1,0,0,0,46,352,1,0,0,0,48,354,1,0,0,0,50,358,1,0,
        0,0,52,422,1,0,0,0,54,427,1,0,0,0,56,429,1,0,0,0,58,436,1,0,0,0,
        60,443,1,0,0,0,62,450,1,0,0,0,64,457,1,0,0,0,66,463,1,0,0,0,68,469,
        1,0,0,0,70,482,1,0,0,0,72,486,1,0,0,0,74,492,1,0,0,0,76,497,1,0,
        0,0,78,501,1,0,0,0,80,506,1,0,0,0,82,515,1,0,0,0,84,525,1,0,0,0,
        86,528,1,0,0,0,88,532,1,0,0,0,90,546,1,0,0,0,92,552,1,0,0,0,94,582,
        1,0,0,0,96,618,1,0,0,0,98,620,1,0,0,0,100,626,1,0,0,0,102,628,1,
        0,0,0,104,644,1,0,0,0,106,646,1,0,0,0,108,651,1,0,0,0,110,654,1,
        0,0,0,112,661,1,0,0,0,114,665,1,0,0,0,116,672,1,0,0,0,118,696,1,
        0,0,0,120,739,1,0,0,0,122,748,1,0,0,0,124,750,1,0,0,0,126,767,1,
        0,0,0,128,773,1,0,0,0,130,837,1,0,0,0,132,929,1,0,0,0,134,935,1,
        0,0,0,136,937,1,0,0,0,138,973,1,0,0,0,140,981,1,0,0,0,142,985,1,
        0,0,0,144,987,1,0,0,0,146,996,1,0,0,0,148,998,1,0,0,0,150,1012,1,
        0,0,0,152,1014,1,0,0,0,154,1016,1,0,0,0,156,1018,1,0,0,0,158,1022,
        1,0,0,0,160,1028,1,0,0,0,162,1030,1,0,0,0,164,1035,1,0,0,0,166,1084,
        1,0,0,0,168,1086,1,0,0,0,170,1092,1,0,0,0,172,174,5,1,0,0,173,172,
        1,0,0,0,173,174,1,0,0,0,174,176,1,0,0,0,175,177,3,112,56,0,176,175,
        1,0,0,0,176,177,1,0,0,0,177,178,1,0,0,0,178,179,5,0,0,1,179,1,1,
        0,0,0,180,181,3,4,2,0,181,3,1,0,0,0,182,203,3,6,3,0,183,203,3,40,
        20,0,184,203,3,10,5,0,185,203,3,30,15,0,186,203,3,46,23,0,187,203,
        3,90,45,0,188,203,3,88,44,0,189,203,3,48,24,0,190,203,3,50,25,0,
        191,203,3,52,26,0,192,203,3,56,28,0,193,203,3,58,29,0,194,203,3,
        60,30,0,195,203,3,62,31,0,196,203,3,64,32,0,197,203,3,76,38,0,198,
        203,3,66,33,0,199,203,3,78,39,0,200,203,3,80,40,0,201,203,3,86,43,
        0,202,182,1,0,0,0,202,183,1,0,0,0,202,184,1,0,0,0,202,185,1,0,0,
        0,202,186,1,0,0,0,202,187,1,0,0,0,202,188,1,0,0,0,202,189,1,0,0,
        0,202,190,1,0,0,0,202,191,1,0,0,0,202,192,1,0,0,0,202,193,1,0,0,
        0,202,194,1,0,0,0,202,195,1,0,0,0,202,196,1,0,0,0,202,197,1,0,0,
        0,202,198,1,0,0,0,202,199,1,0,0,0,202,200,1,0,0,0,202,201,1,0,0,
        0,203,5,1,0,0,0,204,206,5,9,0,0,205,207,3,8,4,0,206,205,1,0,0,0,
        206,207,1,0,0,0,207,208,1,0,0,0,208,209,5,11,0,0,209,7,1,0,0,0,210,
        212,3,4,2,0,211,210,1,0,0,0,212,213,1,0,0,0,213,211,1,0,0,0,213,
        214,1,0,0,0,214,9,1,0,0,0,215,216,5,107,0,0,216,217,3,12,6,0,217,
        11,1,0,0,0,218,220,3,22,11,0,219,218,1,0,0,0,219,220,1,0,0,0,220,
        223,1,0,0,0,221,224,3,24,12,0,222,224,3,14,7,0,223,221,1,0,0,0,223,
        222,1,0,0,0,224,225,1,0,0,0,225,226,3,26,13,0,226,227,3,170,85,0,
        227,231,1,0,0,0,228,229,5,121,0,0,229,231,3,170,85,0,230,219,1,0,
        0,0,230,228,1,0,0,0,231,13,1,0,0,0,232,238,5,9,0,0,233,234,3,16,
        8,0,234,235,5,13,0,0,235,237,1,0,0,0,236,233,1,0,0,0,237,240,1,0,
        0,0,238,236,1,0,0,0,238,239,1,0,0,0,239,245,1,0,0,0,240,238,1,0,
        0,0,241,243,3,16,8,0,242,244,5,13,0,0,243,242,1,0,0,0,243,244,1,
        0,0,0,244,246,1,0,0,0,245,241,1,0,0,0,245,246,1,0,0,0,246,247,1,
        0,0,0,247,248,5,11,0,0,248,15,1,0,0,0,249,252,3,18,9,0,250,251,5,
        98,0,0,251,253,3,20,10,0,252,250,1,0,0,0,252,253,1,0,0,0,253,17,
        1,0,0,0,254,257,3,160,80,0,255,257,5,121,0,0,256,254,1,0,0,0,256,
        255,1,0,0,0,257,19,1,0,0,0,258,259,7,0,0,0,259,21,1,0,0,0,260,261,
        3,28,14,0,261,262,5,13,0,0,262,23,1,0,0,0,263,266,5,26,0,0,264,266,
        3,160,80,0,265,263,1,0,0,0,265,264,1,0,0,0,266,269,1,0,0,0,267,268,
        5,98,0,0,268,270,3,160,80,0,269,267,1,0,0,0,269,270,1,0,0,0,270,
        25,1,0,0,0,271,272,5,99,0,0,272,273,5,121,0,0,273,27,1,0,0,0,274,
        277,3,160,80,0,275,276,5,98,0,0,276,278,3,160,80,0,277,275,1,0,0,
        0,277,278,1,0,0,0,278,29,1,0,0,0,279,281,5,106,0,0,280,282,5,92,
        0,0,281,280,1,0,0,0,281,282,1,0,0,0,282,285,1,0,0,0,283,286,3,32,
        16,0,284,286,3,38,19,0,285,283,1,0,0,0,285,284,1,0,0,0,286,287,1,
        0,0,0,287,288,3,170,85,0,288,295,1,0,0,0,289,290,5,106,0,0,290,291,
        5,92,0,0,291,292,3,130,65,0,292,293,3,170,85,0,293,295,1,0,0,0,294,
        279,1,0,0,0,294,289,1,0,0,0,295,31,1,0,0,0,296,297,3,24,12,0,297,
        298,3,26,13,0,298,299,3,170,85,0,299,307,1,0,0,0,300,302,3,34,17,
        0,301,303,3,26,13,0,302,301,1,0,0,0,302,303,1,0,0,0,303,304,1,0,
        0,0,304,305,3,170,85,0,305,307,1,0,0,0,306,296,1,0,0,0,306,300,1,
        0,0,0,307,33,1,0,0,0,308,314,5,9,0,0,309,310,3,36,18,0,310,311,5,
        13,0,0,311,313,1,0,0,0,312,309,1,0,0,0,313,316,1,0,0,0,314,312,1,
        0,0,0,314,315,1,0,0,0,315,321,1,0,0,0,316,314,1,0,0,0,317,319,3,
        36,18,0,318,320,5,13,0,0,319,318,1,0,0,0,319,320,1,0,0,0,320,322,
        1,0,0,0,321,317,1,0,0,0,321,322,1,0,0,0,322,323,1,0,0,0,323,324,
        5,11,0,0,324,35,1,0,0,0,325,328,3,18,9,0,326,327,5,98,0,0,327,329,
        3,18,9,0,328,326,1,0,0,0,328,329,1,0,0,0,329,37,1,0,0,0,330,334,
        3,40,20,0,331,334,3,90,45,0,332,334,3,88,44,0,333,330,1,0,0,0,333,
        331,1,0,0,0,333,332,1,0,0,0,334,39,1,0,0,0,335,336,3,42,21,0,336,
        337,3,170,85,0,337,41,1,0,0,0,338,339,3,54,27,0,339,344,3,44,22,
        0,340,341,5,13,0,0,341,343,3,44,22,0,342,340,1,0,0,0,343,346,1,0,
        0,0,344,342,1,0,0,0,344,345,1,0,0,0,345,43,1,0,0,0,346,344,1,0,0,
        0,347,350,3,134,67,0,348,349,5,14,0,0,349,351,3,130,65,0,350,348,
        1,0,0,0,350,351,1,0,0,0,351,45,1,0,0,0,352,353,5,12,0,0,353,47,1,
        0,0,0,354,355,4,24,0,0,355,356,3,128,64,0,356,357,3,170,85,0,357,
        49,1,0,0,0,358,359,5,93,0,0,359,360,5,7,0,0,360,361,3,128,64,0,361,
        362,5,8,0,0,362,365,3,4,2,0,363,364,5,77,0,0,364,366,3,4,2,0,365,
        363,1,0,0,0,365,366,1,0,0,0,366,51,1,0,0,0,367,368,5,73,0,0,368,
        369,3,4,2,0,369,370,5,87,0,0,370,371,5,7,0,0,371,372,3,128,64,0,
        372,373,5,8,0,0,373,374,3,170,85,0,374,423,1,0,0,0,375,376,5,87,
        0,0,376,377,5,7,0,0,377,378,3,128,64,0,378,379,5,8,0,0,379,380,3,
        4,2,0,380,423,1,0,0,0,381,382,5,85,0,0,382,385,5,7,0,0,383,386,3,
        128,64,0,384,386,3,42,21,0,385,383,1,0,0,0,385,384,1,0,0,0,385,386,
        1,0,0,0,386,387,1,0,0,0,387,389,5,12,0,0,388,390,3,128,64,0,389,
        388,1,0,0,0,389,390,1,0,0,0,390,391,1,0,0,0,391,393,5,12,0,0,392,
        394,3,128,64,0,393,392,1,0,0,0,393,394,1,0,0,0,394,395,1,0,0,0,395,
        396,5,8,0,0,396,423,3,4,2,0,397,398,5,85,0,0,398,401,5,7,0,0,399,
        402,3,130,65,0,400,402,3,42,21,0,401,399,1,0,0,0,401,400,1,0,0,0,
        402,403,1,0,0,0,403,404,5,96,0,0,404,405,3,128,64,0,405,406,5,8,
        0,0,406,407,3,4,2,0,407,423,1,0,0,0,408,410,5,85,0,0,409,411,5,109,
        0,0,410,409,1,0,0,0,410,411,1,0,0,0,411,412,1,0,0,0,412,415,5,7,
        0,0,413,416,3,130,65,0,414,416,3,42,21,0,415,413,1,0,0,0,415,414,
        1,0,0,0,416,417,1,0,0,0,417,418,5,100,0,0,418,419,3,128,64,0,419,
        420,5,8,0,0,420,421,3,4,2,0,421,423,1,0,0,0,422,367,1,0,0,0,422,
        375,1,0,0,0,422,381,1,0,0,0,422,397,1,0,0,0,422,408,1,0,0,0,423,
        53,1,0,0,0,424,428,5,79,0,0,425,428,3,168,84,0,426,428,5,105,0,0,
        427,424,1,0,0,0,427,425,1,0,0,0,427,426,1,0,0,0,428,55,1,0,0,0,429,
        432,5,84,0,0,430,431,4,28,1,0,431,433,3,162,81,0,432,430,1,0,0,0,
        432,433,1,0,0,0,433,434,1,0,0,0,434,435,3,170,85,0,435,57,1,0,0,
        0,436,439,5,72,0,0,437,438,4,29,2,0,438,440,3,162,81,0,439,437,1,
        0,0,0,439,440,1,0,0,0,440,441,1,0,0,0,441,442,3,170,85,0,442,59,
        1,0,0,0,443,446,5,82,0,0,444,445,4,30,3,0,445,447,3,128,64,0,446,
        444,1,0,0,0,446,447,1,0,0,0,447,448,1,0,0,0,448,449,3,170,85,0,449,
        61,1,0,0,0,450,453,5,110,0,0,451,452,4,31,4,0,452,454,3,128,64,0,
        453,451,1,0,0,0,453,454,1,0,0,0,454,455,1,0,0,0,455,456,3,170,85,
        0,456,63,1,0,0,0,457,458,5,91,0,0,458,459,5,7,0,0,459,460,3,128,
        64,0,460,461,5,8,0,0,461,462,3,4,2,0,462,65,1,0,0,0,463,464,5,86,
        0,0,464,465,5,7,0,0,465,466,3,128,64,0,466,467,5,8,0,0,467,468,3,
        68,34,0,468,67,1,0,0,0,469,471,5,9,0,0,470,472,3,70,35,0,471,470,
        1,0,0,0,471,472,1,0,0,0,472,477,1,0,0,0,473,475,3,74,37,0,474,476,
        3,70,35,0,475,474,1,0,0,0,475,476,1,0,0,0,476,478,1,0,0,0,477,473,
        1,0,0,0,477,478,1,0,0,0,478,479,1,0,0,0,479,480,5,11,0,0,480,69,
        1,0,0,0,481,483,3,72,36,0,482,481,1,0,0,0,483,484,1,0,0,0,484,482,
        1,0,0,0,484,485,1,0,0,0,485,71,1,0,0,0,486,487,5,76,0,0,487,488,
        3,128,64,0,488,490,5,17,0,0,489,491,3,8,4,0,490,489,1,0,0,0,490,
        491,1,0,0,0,491,73,1,0,0,0,492,493,5,92,0,0,493,495,5,17,0,0,494,
        496,3,8,4,0,495,494,1,0,0,0,495,496,1,0,0,0,496,75,1,0,0,0,497,498,
        3,162,81,0,498,499,5,17,0,0,499,500,3,4,2,0,500,77,1,0,0,0,501,502,
        5,94,0,0,502,503,4,39,5,0,503,504,3,128,64,0,504,505,3,170,85,0,
        505,79,1,0,0,0,506,507,5,97,0,0,507,513,3,6,3,0,508,510,3,82,41,
        0,509,511,3,84,42,0,510,509,1,0,0,0,510,511,1,0,0,0,511,514,1,0,
        0,0,512,514,3,84,42,0,513,508,1,0,0,0,513,512,1,0,0,0,514,81,1,0,
        0,0,515,521,5,80,0,0,516,518,5,7,0,0,517,519,3,134,67,0,518,517,
        1,0,0,0,518,519,1,0,0,0,519,520,1,0,0,0,520,522,5,8,0,0,521,516,
        1,0,0,0,521,522,1,0,0,0,522,523,1,0,0,0,523,524,3,6,3,0,524,83,1,
        0,0,0,525,526,5,81,0,0,526,527,3,6,3,0,527,85,1,0,0,0,528,529,5,
        88,0,0,529,530,3,170,85,0,530,87,1,0,0,0,531,533,5,108,0,0,532,531,
        1,0,0,0,532,533,1,0,0,0,533,534,1,0,0,0,534,536,5,89,0,0,535,537,
        5,26,0,0,536,535,1,0,0,0,536,537,1,0,0,0,537,538,1,0,0,0,538,539,
        3,162,81,0,539,541,5,7,0,0,540,542,3,104,52,0,541,540,1,0,0,0,541,
        542,1,0,0,0,542,543,1,0,0,0,543,544,5,8,0,0,544,545,3,110,55,0,545,
        89,1,0,0,0,546,547,5,101,0,0,547,548,3,162,81,0,548,549,3,92,46,
        0,549,91,1,0,0,0,550,551,5,103,0,0,551,553,3,130,65,0,552,550,1,
        0,0,0,552,553,1,0,0,0,553,554,1,0,0,0,554,558,5,9,0,0,555,557,3,
        94,47,0,556,555,1,0,0,0,557,560,1,0,0,0,558,556,1,0,0,0,558,559,
        1,0,0,0,559,561,1,0,0,0,560,558,1,0,0,0,561,562,5,11,0,0,562,93,
        1,0,0,0,563,567,5,119,0,0,564,565,4,47,6,0,565,567,3,162,81,0,566,
        563,1,0,0,0,566,564,1,0,0,0,566,567,1,0,0,0,567,568,1,0,0,0,568,
        583,3,96,48,0,569,573,5,119,0,0,570,571,4,47,7,0,571,573,3,162,81,
        0,572,569,1,0,0,0,572,570,1,0,0,0,572,573,1,0,0,0,573,574,1,0,0,
        0,574,583,3,98,49,0,575,579,5,119,0,0,576,577,4,47,8,0,577,579,3,
        162,81,0,578,575,1,0,0,0,578,576,1,0,0,0,579,580,1,0,0,0,580,583,
        3,6,3,0,581,583,3,46,23,0,582,566,1,0,0,0,582,572,1,0,0,0,582,578,
        1,0,0,0,582,581,1,0,0,0,583,95,1,0,0,0,584,585,5,108,0,0,585,587,
        4,48,9,0,586,584,1,0,0,0,586,587,1,0,0,0,587,589,1,0,0,0,588,590,
        5,26,0,0,589,588,1,0,0,0,589,590,1,0,0,0,590,591,1,0,0,0,591,592,
        3,100,50,0,592,594,5,7,0,0,593,595,3,104,52,0,594,593,1,0,0,0,594,
        595,1,0,0,0,595,596,1,0,0,0,596,597,5,8,0,0,597,598,3,110,55,0,598,
        619,1,0,0,0,599,601,5,26,0,0,600,599,1,0,0,0,600,601,1,0,0,0,601,
        602,1,0,0,0,602,603,3,156,78,0,603,604,5,7,0,0,604,605,5,8,0,0,605,
        606,3,110,55,0,606,619,1,0,0,0,607,609,5,26,0,0,608,607,1,0,0,0,
        608,609,1,0,0,0,609,610,1,0,0,0,610,611,3,158,79,0,611,613,5,7,0,
        0,612,614,3,104,52,0,613,612,1,0,0,0,613,614,1,0,0,0,614,615,1,0,
        0,0,615,616,5,8,0,0,616,617,3,110,55,0,617,619,1,0,0,0,618,586,1,
        0,0,0,618,600,1,0,0,0,618,608,1,0,0,0,619,97,1,0,0,0,620,622,3,100,
        50,0,621,623,3,132,66,0,622,621,1,0,0,0,622,623,1,0,0,0,623,99,1,
        0,0,0,624,627,3,122,61,0,625,627,3,102,51,0,626,624,1,0,0,0,626,
        625,1,0,0,0,627,101,1,0,0,0,628,629,5,31,0,0,629,630,3,160,80,0,
        630,103,1,0,0,0,631,636,3,106,53,0,632,633,5,13,0,0,633,635,3,106,
        53,0,634,632,1,0,0,0,635,638,1,0,0,0,636,634,1,0,0,0,636,637,1,0,
        0,0,637,641,1,0,0,0,638,636,1,0,0,0,639,640,5,13,0,0,640,642,3,108,
        54,0,641,639,1,0,0,0,641,642,1,0,0,0,642,645,1,0,0,0,643,645,3,108,
        54,0,644,631,1,0,0,0,644,643,1,0,0,0,645,105,1,0,0,0,646,649,3,134,
        67,0,647,648,5,14,0,0,648,650,3,130,65,0,649,647,1,0,0,0,649,650,
        1,0,0,0,650,107,1,0,0,0,651,652,5,18,0,0,652,653,3,130,65,0,653,
        109,1,0,0,0,654,656,5,9,0,0,655,657,3,112,56,0,656,655,1,0,0,0,656,
        657,1,0,0,0,657,658,1,0,0,0,658,659,5,11,0,0,659,111,1,0,0,0,660,
        662,3,2,1,0,661,660,1,0,0,0,662,663,1,0,0,0,663,661,1,0,0,0,663,
        664,1,0,0,0,664,113,1,0,0,0,665,666,5,5,0,0,666,667,3,116,58,0,667,
        668,5,6,0,0,668,115,1,0,0,0,669,671,5,13,0,0,670,669,1,0,0,0,671,
        674,1,0,0,0,672,670,1,0,0,0,672,673,1,0,0,0,673,676,1,0,0,0,674,
        672,1,0,0,0,675,677,3,118,59,0,676,675,1,0,0,0,676,677,1,0,0,0,677,
        686,1,0,0,0,678,680,5,13,0,0,679,678,1,0,0,0,680,681,1,0,0,0,681,
        679,1,0,0,0,681,682,1,0,0,0,682,683,1,0,0,0,683,685,3,118,59,0,684,
        679,1,0,0,0,685,688,1,0,0,0,686,684,1,0,0,0,686,687,1,0,0,0,687,
        692,1,0,0,0,688,686,1,0,0,0,689,691,5,13,0,0,690,689,1,0,0,0,691,
        694,1,0,0,0,692,690,1,0,0,0,692,693,1,0,0,0,693,117,1,0,0,0,694,
        692,1,0,0,0,695,697,5,18,0,0,696,695,1,0,0,0,696,697,1,0,0,0,697,
        698,1,0,0,0,698,699,3,130,65,0,699,119,1,0,0,0,700,701,3,122,61,
        0,701,702,5,17,0,0,702,703,3,130,65,0,703,740,1,0,0,0,704,705,5,
        5,0,0,705,706,3,130,65,0,706,707,5,6,0,0,707,708,5,17,0,0,708,709,
        3,130,65,0,709,740,1,0,0,0,710,712,5,108,0,0,711,710,1,0,0,0,711,
        712,1,0,0,0,712,714,1,0,0,0,713,715,5,26,0,0,714,713,1,0,0,0,714,
        715,1,0,0,0,715,716,1,0,0,0,716,717,3,122,61,0,717,719,5,7,0,0,718,
        720,3,104,52,0,719,718,1,0,0,0,719,720,1,0,0,0,720,721,1,0,0,0,721,
        722,5,8,0,0,722,723,3,110,55,0,723,740,1,0,0,0,724,725,3,156,78,
        0,725,726,5,7,0,0,726,727,5,8,0,0,727,728,3,110,55,0,728,740,1,0,
        0,0,729,730,3,158,79,0,730,731,5,7,0,0,731,732,3,106,53,0,732,733,
        5,8,0,0,733,734,3,110,55,0,734,740,1,0,0,0,735,737,5,18,0,0,736,
        735,1,0,0,0,736,737,1,0,0,0,737,738,1,0,0,0,738,740,3,130,65,0,739,
        700,1,0,0,0,739,704,1,0,0,0,739,711,1,0,0,0,739,724,1,0,0,0,739,
        729,1,0,0,0,739,736,1,0,0,0,740,121,1,0,0,0,741,749,3,160,80,0,742,
        749,5,121,0,0,743,749,3,152,76,0,744,745,5,5,0,0,745,746,3,130,65,
        0,746,747,5,6,0,0,747,749,1,0,0,0,748,741,1,0,0,0,748,742,1,0,0,
        0,748,743,1,0,0,0,748,744,1,0,0,0,749,123,1,0,0,0,750,762,5,7,0,
        0,751,756,3,126,63,0,752,753,5,13,0,0,753,755,3,126,63,0,754,752,
        1,0,0,0,755,758,1,0,0,0,756,754,1,0,0,0,756,757,1,0,0,0,757,760,
        1,0,0,0,758,756,1,0,0,0,759,761,5,13,0,0,760,759,1,0,0,0,760,761,
        1,0,0,0,761,763,1,0,0,0,762,751,1,0,0,0,762,763,1,0,0,0,763,764,
        1,0,0,0,764,765,5,8,0,0,765,125,1,0,0,0,766,768,5,18,0,0,767,766,
        1,0,0,0,767,768,1,0,0,0,768,771,1,0,0,0,769,772,3,130,65,0,770,772,
        3,162,81,0,771,769,1,0,0,0,771,770,1,0,0,0,772,127,1,0,0,0,773,778,
        3,130,65,0,774,775,5,13,0,0,775,777,3,130,65,0,776,774,1,0,0,0,777,
        780,1,0,0,0,778,776,1,0,0,0,778,779,1,0,0,0,779,129,1,0,0,0,780,
        778,1,0,0,0,781,782,6,65,-1,0,782,838,3,138,69,0,783,785,5,101,0,
        0,784,786,3,162,81,0,785,784,1,0,0,0,785,786,1,0,0,0,786,787,1,0,
        0,0,787,838,3,92,46,0,788,789,5,78,0,0,789,790,3,162,81,0,790,791,
        3,124,62,0,791,838,1,0,0,0,792,793,5,78,0,0,793,794,3,130,65,0,794,
        795,3,124,62,0,795,838,1,0,0,0,796,797,5,78,0,0,797,838,3,130,65,
        42,798,799,5,78,0,0,799,800,5,19,0,0,800,838,3,162,81,0,801,802,
        5,95,0,0,802,838,3,130,65,37,803,804,5,83,0,0,804,838,3,130,65,36,
        805,806,5,75,0,0,806,838,3,130,65,35,807,808,5,20,0,0,808,838,3,
        130,65,34,809,810,5,21,0,0,810,838,3,130,65,33,811,812,5,22,0,0,
        812,838,3,130,65,32,813,814,5,23,0,0,814,838,3,130,65,31,815,816,
        5,24,0,0,816,838,3,130,65,30,817,818,5,25,0,0,818,838,3,130,65,29,
        819,820,5,109,0,0,820,838,3,130,65,28,821,822,5,107,0,0,822,823,
        5,7,0,0,823,824,3,130,65,0,824,825,5,8,0,0,825,838,1,0,0,0,826,838,
        3,62,31,0,827,838,5,90,0,0,828,838,3,162,81,0,829,838,5,104,0,0,
        830,838,3,146,73,0,831,838,3,114,57,0,832,838,3,136,68,0,833,834,
        5,7,0,0,834,835,3,128,64,0,835,836,5,8,0,0,836,838,1,0,0,0,837,781,
        1,0,0,0,837,783,1,0,0,0,837,788,1,0,0,0,837,792,1,0,0,0,837,796,
        1,0,0,0,837,798,1,0,0,0,837,801,1,0,0,0,837,803,1,0,0,0,837,805,
        1,0,0,0,837,807,1,0,0,0,837,809,1,0,0,0,837,811,1,0,0,0,837,813,
        1,0,0,0,837,815,1,0,0,0,837,817,1,0,0,0,837,819,1,0,0,0,837,821,
        1,0,0,0,837,826,1,0,0,0,837,827,1,0,0,0,837,828,1,0,0,0,837,829,
        1,0,0,0,837,830,1,0,0,0,837,831,1,0,0,0,837,832,1,0,0,0,837,833,
        1,0,0,0,838,926,1,0,0,0,839,840,10,47,0,0,840,841,5,16,0,0,841,925,
        3,130,65,48,842,843,10,27,0,0,843,844,5,29,0,0,844,925,3,130,65,
        27,845,846,10,26,0,0,846,847,7,1,0,0,847,925,3,130,65,27,848,849,
        10,25,0,0,849,850,7,2,0,0,850,925,3,130,65,26,851,852,10,24,0,0,
        852,853,5,30,0,0,853,925,3,130,65,25,854,855,10,23,0,0,855,856,7,
        3,0,0,856,925,3,130,65,24,857,858,10,22,0,0,858,859,7,4,0,0,859,
        925,3,130,65,23,860,861,10,21,0,0,861,862,5,74,0,0,862,925,3,130,
        65,22,863,864,10,20,0,0,864,865,5,96,0,0,865,925,3,130,65,21,866,
        867,10,19,0,0,867,868,7,5,0,0,868,925,3,130,65,20,869,870,10,18,
        0,0,870,871,5,43,0,0,871,925,3,130,65,19,872,873,10,17,0,0,873,874,
        5,44,0,0,874,925,3,130,65,18,875,876,10,16,0,0,876,877,5,45,0,0,
        877,925,3,130,65,17,878,879,10,15,0,0,879,880,5,46,0,0,880,925,3,
        130,65,16,881,882,10,14,0,0,882,883,5,47,0,0,883,925,3,130,65,15,
        884,885,10,13,0,0,885,886,5,15,0,0,886,887,3,130,65,0,887,888,5,
        17,0,0,888,889,3,130,65,14,889,925,1,0,0,0,890,891,10,12,0,0,891,
        892,5,14,0,0,892,925,3,130,65,12,893,894,10,11,0,0,894,895,3,144,
        72,0,895,896,3,130,65,11,896,925,1,0,0,0,897,899,10,46,0,0,898,900,
        5,16,0,0,899,898,1,0,0,0,899,900,1,0,0,0,900,901,1,0,0,0,901,902,
        5,5,0,0,902,903,3,128,64,0,903,904,5,6,0,0,904,925,1,0,0,0,905,907,
        10,45,0,0,906,908,5,15,0,0,907,906,1,0,0,0,907,908,1,0,0,0,908,909,
        1,0,0,0,909,911,5,19,0,0,910,912,5,31,0,0,911,910,1,0,0,0,911,912,
        1,0,0,0,912,913,1,0,0,0,913,925,3,160,80,0,914,915,10,41,0,0,915,
        925,3,124,62,0,916,917,10,39,0,0,917,918,4,65,32,0,918,925,5,20,
        0,0,919,920,10,38,0,0,920,921,4,65,34,0,921,925,5,21,0,0,922,923,
        10,9,0,0,923,925,3,148,74,0,924,839,1,0,0,0,924,842,1,0,0,0,924,
        845,1,0,0,0,924,848,1,0,0,0,924,851,1,0,0,0,924,854,1,0,0,0,924,
        857,1,0,0,0,924,860,1,0,0,0,924,863,1,0,0,0,924,866,1,0,0,0,924,
        869,1,0,0,0,924,872,1,0,0,0,924,875,1,0,0,0,924,878,1,0,0,0,924,
        881,1,0,0,0,924,884,1,0,0,0,924,890,1,0,0,0,924,893,1,0,0,0,924,
        897,1,0,0,0,924,905,1,0,0,0,924,914,1,0,0,0,924,916,1,0,0,0,924,
        919,1,0,0,0,924,922,1,0,0,0,925,928,1,0,0,0,926,924,1,0,0,0,926,
        927,1,0,0,0,927,131,1,0,0,0,928,926,1,0,0,0,929,930,5,14,0,0,930,
        931,3,130,65,0,931,133,1,0,0,0,932,936,3,162,81,0,933,936,3,114,
        57,0,934,936,3,136,68,0,935,932,1,0,0,0,935,933,1,0,0,0,935,934,
        1,0,0,0,936,135,1,0,0,0,937,949,5,9,0,0,938,943,3,120,60,0,939,940,
        5,13,0,0,940,942,3,120,60,0,941,939,1,0,0,0,942,945,1,0,0,0,943,
        941,1,0,0,0,943,944,1,0,0,0,944,947,1,0,0,0,945,943,1,0,0,0,946,
        948,5,13,0,0,947,946,1,0,0,0,947,948,1,0,0,0,948,950,1,0,0,0,949,
        938,1,0,0,0,949,950,1,0,0,0,950,951,1,0,0,0,951,952,5,11,0,0,952,
        137,1,0,0,0,953,955,5,108,0,0,954,953,1,0,0,0,954,955,1,0,0,0,955,
        956,1,0,0,0,956,958,5,89,0,0,957,959,5,26,0,0,958,957,1,0,0,0,958,
        959,1,0,0,0,959,960,1,0,0,0,960,962,5,7,0,0,961,963,3,104,52,0,962,
        961,1,0,0,0,962,963,1,0,0,0,963,964,1,0,0,0,964,965,5,8,0,0,965,
        974,3,110,55,0,966,968,5,108,0,0,967,966,1,0,0,0,967,968,1,0,0,0,
        968,969,1,0,0,0,969,970,3,140,70,0,970,971,5,60,0,0,971,972,3,142,
        71,0,972,974,1,0,0,0,973,954,1,0,0,0,973,967,1,0,0,0,974,139,1,0,
        0,0,975,982,3,162,81,0,976,978,5,7,0,0,977,979,3,104,52,0,978,977,
        1,0,0,0,978,979,1,0,0,0,979,980,1,0,0,0,980,982,5,8,0,0,981,975,
        1,0,0,0,981,976,1,0,0,0,982,141,1,0,0,0,983,986,3,130,65,0,984,986,
        3,110,55,0,985,983,1,0,0,0,985,984,1,0,0,0,986,143,1,0,0,0,987,988,
        7,6,0,0,988,145,1,0,0,0,989,997,5,61,0,0,990,997,5,62,0,0,991,997,
        5,121,0,0,992,997,3,148,74,0,993,997,5,4,0,0,994,997,3,152,76,0,
        995,997,3,154,77,0,996,989,1,0,0,0,996,990,1,0,0,0,996,991,1,0,0,
        0,996,992,1,0,0,0,996,993,1,0,0,0,996,994,1,0,0,0,996,995,1,0,0,
        0,997,147,1,0,0,0,998,1002,5,122,0,0,999,1001,3,150,75,0,1000,999,
        1,0,0,0,1001,1004,1,0,0,0,1002,1000,1,0,0,0,1002,1003,1,0,0,0,1003,
        1005,1,0,0,0,1004,1002,1,0,0,0,1005,1006,5,122,0,0,1006,149,1,0,
        0,0,1007,1013,5,129,0,0,1008,1009,5,128,0,0,1009,1010,3,130,65,0,
        1010,1011,5,10,0,0,1011,1013,1,0,0,0,1012,1007,1,0,0,0,1012,1008,
        1,0,0,0,1013,151,1,0,0,0,1014,1015,7,7,0,0,1015,153,1,0,0,0,1016,
        1017,7,8,0,0,1017,155,1,0,0,0,1018,1019,4,78,36,0,1019,1020,3,162,
        81,0,1020,1021,3,100,50,0,1021,157,1,0,0,0,1022,1023,4,79,37,0,1023,
        1024,3,162,81,0,1024,1025,3,100,50,0,1025,159,1,0,0,0,1026,1029,
        3,162,81,0,1027,1029,3,164,82,0,1028,1026,1,0,0,0,1028,1027,1,0,
        0,0,1029,161,1,0,0,0,1030,1031,7,9,0,0,1031,163,1,0,0,0,1032,1036,
        3,166,83,0,1033,1036,5,61,0,0,1034,1036,5,62,0,0,1035,1032,1,0,0,
        0,1035,1033,1,0,0,0,1035,1034,1,0,0,0,1036,165,1,0,0,0,1037,1085,
        5,72,0,0,1038,1085,5,73,0,0,1039,1085,5,74,0,0,1040,1085,5,75,0,
        0,1041,1085,5,76,0,0,1042,1085,5,77,0,0,1043,1085,5,78,0,0,1044,
        1085,5,79,0,0,1045,1085,5,80,0,0,1046,1085,5,81,0,0,1047,1085,5,
        82,0,0,1048,1085,5,83,0,0,1049,1085,5,84,0,0,1050,1085,5,85,0,0,
        1051,1085,5,86,0,0,1052,1085,5,87,0,0,1053,1085,5,88,0,0,1054,1085,
        5,89,0,0,1055,1085,5,90,0,0,1056,1085,5,91,0,0,1057,1085,5,92,0,
        0,1058,1085,5,93,0,0,1059,1085,5,94,0,0,1060,1085,5,95,0,0,1061,
        1085,5,96,0,0,1062,1085,5,97,0,0,1063,1085,5,101,0,0,1064,1085,5,
        102,0,0,1065,1085,5,103,0,0,1066,1085,5,104,0,0,1067,1085,5,105,
        0,0,1068,1085,5,106,0,0,1069,1085,5,107,0,0,1070,1085,5,111,0,0,
        1071,1085,3,168,84,0,1072,1085,5,114,0,0,1073,1085,5,115,0,0,1074,
        1085,5,116,0,0,1075,1085,5,117,0,0,1076,1085,5,118,0,0,1077,1085,
        5,119,0,0,1078,1085,5,110,0,0,1079,1085,5,108,0,0,1080,1085,5,109,
        0,0,1081,1085,5,99,0,0,1082,1085,5,98,0,0,1083,1085,5,100,0,0,1084,
        1037,1,0,0,0,1084,1038,1,0,0,0,1084,1039,1,0,0,0,1084,1040,1,0,0,
        0,1084,1041,1,0,0,0,1084,1042,1,0,0,0,1084,1043,1,0,0,0,1084,1044,
        1,0,0,0,1084,1045,1,0,0,0,1084,1046,1,0,0,0,1084,1047,1,0,0,0,1084,
        1048,1,0,0,0,1084,1049,1,0,0,0,1084,1050,1,0,0,0,1084,1051,1,0,0,
        0,1084,1052,1,0,0,0,1084,1053,1,0,0,0,1084,1054,1,0,0,0,1084,1055,
        1,0,0,0,1084,1056,1,0,0,0,1084,1057,1,0,0,0,1084,1058,1,0,0,0,1084,
        1059,1,0,0,0,1084,1060,1,0,0,0,1084,1061,1,0,0,0,1084,1062,1,0,0,
        0,1084,1063,1,0,0,0,1084,1064,1,0,0,0,1084,1065,1,0,0,0,1084,1066,
        1,0,0,0,1084,1067,1,0,0,0,1084,1068,1,0,0,0,1084,1069,1,0,0,0,1084,
        1070,1,0,0,0,1084,1071,1,0,0,0,1084,1072,1,0,0,0,1084,1073,1,0,0,
        0,1084,1074,1,0,0,0,1084,1075,1,0,0,0,1084,1076,1,0,0,0,1084,1077,
        1,0,0,0,1084,1078,1,0,0,0,1084,1079,1,0,0,0,1084,1080,1,0,0,0,1084,
        1081,1,0,0,0,1084,1082,1,0,0,0,1084,1083,1,0,0,0,1085,167,1,0,0,
        0,1086,1087,7,10,0,0,1087,169,1,0,0,0,1088,1093,5,12,0,0,1089,1093,
        5,0,0,1,1090,1093,4,85,38,0,1091,1093,4,85,39,0,1092,1088,1,0,0,
        0,1092,1089,1,0,0,0,1092,1090,1,0,0,0,1092,1091,1,0,0,0,1093,171,
        1,0,0,0,119,173,176,202,206,213,219,223,230,238,243,245,252,256,
        265,269,277,281,285,294,302,306,314,319,321,328,333,344,350,365,
        385,389,393,401,410,415,422,427,432,439,446,453,471,475,477,484,
        490,495,510,513,518,521,532,536,541,552,558,566,572,578,582,586,
        589,594,600,608,613,618,622,626,636,641,644,649,656,663,672,676,
        681,686,692,696,711,714,719,736,739,748,756,760,762,767,771,778,
        785,837,899,907,911,924,926,935,943,947,949,954,958,962,967,973,
        978,981,985,996,1002,1012,1028,1035,1084,1092
    ]

class JavaScriptParser ( JavaScriptParserBase ):

    grammarFileName = "JavaScriptParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'['", "']'", "'('", "')'", "'{'", "<INVALID>", 
                     "'}'", "';'", "','", "'='", "'?'", "'?.'", "':'", "'...'", 
                     "'.'", "'++'", "'--'", "'+'", "'-'", "'~'", "'!'", 
                     "'*'", "'/'", "'%'", "'**'", "'??'", "'#'", "'>>'", 
                     "'<<'", "'>>>'", "'<'", "'>'", "'<='", "'>='", "'=='", 
                     "'!='", "'==='", "'!=='", "'&'", "'^'", "'|'", "'&&'", 
                     "'||'", "'*='", "'/='", "'%='", "'+='", "'-='", "'<<='", 
                     "'>>='", "'>>>='", "'&='", "'^='", "'|='", "'**='", 
                     "'=>'", "'null'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'break'", "'do'", 
                     "'instanceof'", "'typeof'", "'case'", "'else'", "'new'", 
                     "'var'", "'catch'", "'finally'", "'return'", "'void'", 
                     "'continue'", "'for'", "'switch'", "'while'", "'debugger'", 
                     "'function'", "'this'", "'with'", "'default'", "'if'", 
                     "'throw'", "'delete'", "'in'", "'try'", "'as'", "'from'", 
                     "'of'", "'class'", "'enum'", "'extends'", "'super'", 
                     "'const'", "'export'", "'import'", "'async'", "'await'", 
                     "'yield'", "'implements'", "<INVALID>", "<INVALID>", 
                     "'private'", "'public'", "'interface'", "'package'", 
                     "'protected'", "'static'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'${'" ]

    symbolicNames = [ "<INVALID>", "HashBangLine", "MultiLineComment", "SingleLineComment", 
                      "RegularExpressionLiteral", "OpenBracket", "CloseBracket", 
                      "OpenParen", "CloseParen", "OpenBrace", "TemplateCloseBrace", 
                      "CloseBrace", "SemiColon", "Comma", "Assign", "QuestionMark", 
                      "QuestionMarkDot", "Colon", "Ellipsis", "Dot", "PlusPlus", 
                      "MinusMinus", "Plus", "Minus", "BitNot", "Not", "Multiply", 
                      "Divide", "Modulus", "Power", "NullCoalesce", "Hashtag", 
                      "RightShiftArithmetic", "LeftShiftArithmetic", "RightShiftLogical", 
                      "LessThan", "MoreThan", "LessThanEquals", "GreaterThanEquals", 
                      "Equals_", "NotEquals", "IdentityEquals", "IdentityNotEquals", 
                      "BitAnd", "BitXOr", "BitOr", "And", "Or", "MultiplyAssign", 
                      "DivideAssign", "ModulusAssign", "PlusAssign", "MinusAssign", 
                      "LeftShiftArithmeticAssign", "RightShiftArithmeticAssign", 
                      "RightShiftLogicalAssign", "BitAndAssign", "BitXorAssign", 
                      "BitOrAssign", "PowerAssign", "ARROW", "NullLiteral", 
                      "BooleanLiteral", "DecimalLiteral", "HexIntegerLiteral", 
                      "OctalIntegerLiteral", "OctalIntegerLiteral2", "BinaryIntegerLiteral", 
                      "BigHexIntegerLiteral", "BigOctalIntegerLiteral", 
                      "BigBinaryIntegerLiteral", "BigDecimalIntegerLiteral", 
                      "Break", "Do", "Instanceof", "Typeof", "Case", "Else", 
                      "New", "Var", "Catch", "Finally", "Return", "Void", 
                      "Continue", "For", "Switch", "While", "Debugger", 
                      "Function_", "This", "With", "Default", "If", "Throw", 
                      "Delete", "In", "Try", "As", "From", "Of", "Class", 
                      "Enum", "Extends", "Super", "Const", "Export", "Import", 
                      "Async", "Await", "Yield", "Implements", "StrictLet", 
                      "NonStrictLet", "Private", "Public", "Interface", 
                      "Package", "Protected", "Static", "Identifier", "StringLiteral", 
                      "BackTick", "WhiteSpaces", "LineTerminator", "HtmlComment", 
                      "CDataComment", "UnexpectedCharacter", "TemplateStringStartExpression", 
                      "TemplateStringAtom" ]

    RULE_program = 0
    RULE_sourceElement = 1
    RULE_statement = 2
    RULE_block = 3
    RULE_statementList = 4
    RULE_importStatement = 5
    RULE_importFromBlock = 6
    RULE_importModuleItems = 7
    RULE_importAliasName = 8
    RULE_moduleExportName = 9
    RULE_importedBinding = 10
    RULE_importDefault = 11
    RULE_importNamespace = 12
    RULE_importFrom = 13
    RULE_aliasName = 14
    RULE_exportStatement = 15
    RULE_exportFromBlock = 16
    RULE_exportModuleItems = 17
    RULE_exportAliasName = 18
    RULE_declaration = 19
    RULE_variableStatement = 20
    RULE_variableDeclarationList = 21
    RULE_variableDeclaration = 22
    RULE_emptyStatement_ = 23
    RULE_expressionStatement = 24
    RULE_ifStatement = 25
    RULE_iterationStatement = 26
    RULE_varModifier = 27
    RULE_continueStatement = 28
    RULE_breakStatement = 29
    RULE_returnStatement = 30
    RULE_yieldStatement = 31
    RULE_withStatement = 32
    RULE_switchStatement = 33
    RULE_caseBlock = 34
    RULE_caseClauses = 35
    RULE_caseClause = 36
    RULE_defaultClause = 37
    RULE_labelledStatement = 38
    RULE_throwStatement = 39
    RULE_tryStatement = 40
    RULE_catchProduction = 41
    RULE_finallyProduction = 42
    RULE_debuggerStatement = 43
    RULE_functionDeclaration = 44
    RULE_classDeclaration = 45
    RULE_classTail = 46
    RULE_classElement = 47
    RULE_methodDefinition = 48
    RULE_fieldDefinition = 49
    RULE_classElementName = 50
    RULE_privateIdentifier = 51
    RULE_formalParameterList = 52
    RULE_formalParameterArg = 53
    RULE_lastFormalParameterArg = 54
    RULE_functionBody = 55
    RULE_sourceElements = 56
    RULE_arrayLiteral = 57
    RULE_elementList = 58
    RULE_arrayElement = 59
    RULE_propertyAssignment = 60
    RULE_propertyName = 61
    RULE_arguments = 62
    RULE_argument = 63
    RULE_expressionSequence = 64
    RULE_singleExpression = 65
    RULE_initializer = 66
    RULE_assignable = 67
    RULE_objectLiteral = 68
    RULE_anonymousFunction = 69
    RULE_arrowFunctionParameters = 70
    RULE_arrowFunctionBody = 71
    RULE_assignmentOperator = 72
    RULE_literal = 73
    RULE_templateStringLiteral = 74
    RULE_templateStringAtom = 75
    RULE_numericLiteral = 76
    RULE_bigintLiteral = 77
    RULE_getter = 78
    RULE_setter = 79
    RULE_identifierName = 80
    RULE_identifier = 81
    RULE_reservedWord = 82
    RULE_keyword = 83
    RULE_let_ = 84
    RULE_eos = 85

    ruleNames =  [ "program", "sourceElement", "statement", "block", "statementList", 
                   "importStatement", "importFromBlock", "importModuleItems", 
                   "importAliasName", "moduleExportName", "importedBinding", 
                   "importDefault", "importNamespace", "importFrom", "aliasName", 
                   "exportStatement", "exportFromBlock", "exportModuleItems", 
                   "exportAliasName", "declaration", "variableStatement", 
                   "variableDeclarationList", "variableDeclaration", "emptyStatement_", 
                   "expressionStatement", "ifStatement", "iterationStatement", 
                   "varModifier", "continueStatement", "breakStatement", 
                   "returnStatement", "yieldStatement", "withStatement", 
                   "switchStatement", "caseBlock", "caseClauses", "caseClause", 
                   "defaultClause", "labelledStatement", "throwStatement", 
                   "tryStatement", "catchProduction", "finallyProduction", 
                   "debuggerStatement", "functionDeclaration", "classDeclaration", 
                   "classTail", "classElement", "methodDefinition", "fieldDefinition", 
                   "classElementName", "privateIdentifier", "formalParameterList", 
                   "formalParameterArg", "lastFormalParameterArg", "functionBody", 
                   "sourceElements", "arrayLiteral", "elementList", "arrayElement", 
                   "propertyAssignment", "propertyName", "arguments", "argument", 
                   "expressionSequence", "singleExpression", "initializer", 
                   "assignable", "objectLiteral", "anonymousFunction", "arrowFunctionParameters", 
                   "arrowFunctionBody", "assignmentOperator", "literal", 
                   "templateStringLiteral", "templateStringAtom", "numericLiteral", 
                   "bigintLiteral", "getter", "setter", "identifierName", 
                   "identifier", "reservedWord", "keyword", "let_", "eos" ]

    EOF = Token.EOF
    HashBangLine=1
    MultiLineComment=2
    SingleLineComment=3
    RegularExpressionLiteral=4
    OpenBracket=5
    CloseBracket=6
    OpenParen=7
    CloseParen=8
    OpenBrace=9
    TemplateCloseBrace=10
    CloseBrace=11
    SemiColon=12
    Comma=13
    Assign=14
    QuestionMark=15
    QuestionMarkDot=16
    Colon=17
    Ellipsis=18
    Dot=19
    PlusPlus=20
    MinusMinus=21
    Plus=22
    Minus=23
    BitNot=24
    Not=25
    Multiply=26
    Divide=27
    Modulus=28
    Power=29
    NullCoalesce=30
    Hashtag=31
    RightShiftArithmetic=32
    LeftShiftArithmetic=33
    RightShiftLogical=34
    LessThan=35
    MoreThan=36
    LessThanEquals=37
    GreaterThanEquals=38
    Equals_=39
    NotEquals=40
    IdentityEquals=41
    IdentityNotEquals=42
    BitAnd=43
    BitXOr=44
    BitOr=45
    And=46
    Or=47
    MultiplyAssign=48
    DivideAssign=49
    ModulusAssign=50
    PlusAssign=51
    MinusAssign=52
    LeftShiftArithmeticAssign=53
    RightShiftArithmeticAssign=54
    RightShiftLogicalAssign=55
    BitAndAssign=56
    BitXorAssign=57
    BitOrAssign=58
    PowerAssign=59
    ARROW=60
    NullLiteral=61
    BooleanLiteral=62
    DecimalLiteral=63
    HexIntegerLiteral=64
    OctalIntegerLiteral=65
    OctalIntegerLiteral2=66
    BinaryIntegerLiteral=67
    BigHexIntegerLiteral=68
    BigOctalIntegerLiteral=69
    BigBinaryIntegerLiteral=70
    BigDecimalIntegerLiteral=71
    Break=72
    Do=73
    Instanceof=74
    Typeof=75
    Case=76
    Else=77
    New=78
    Var=79
    Catch=80
    Finally=81
    Return=82
    Void=83
    Continue=84
    For=85
    Switch=86
    While=87
    Debugger=88
    Function_=89
    This=90
    With=91
    Default=92
    If=93
    Throw=94
    Delete=95
    In=96
    Try=97
    As=98
    From=99
    Of=100
    Class=101
    Enum=102
    Extends=103
    Super=104
    Const=105
    Export=106
    Import=107
    Async=108
    Await=109
    Yield=110
    Implements=111
    StrictLet=112
    NonStrictLet=113
    Private=114
    Public=115
    Interface=116
    Package=117
    Protected=118
    Static=119
    Identifier=120
    StringLiteral=121
    BackTick=122
    WhiteSpaces=123
    LineTerminator=124
    HtmlComment=125
    CDataComment=126
    UnexpectedCharacter=127
    TemplateStringStartExpression=128
    TemplateStringAtom=129

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(JavaScriptParser.EOF, 0)

        def HashBangLine(self):
            return self.getToken(JavaScriptParser.HashBangLine, 0)

        def sourceElements(self):
            return self.getTypedRuleContext(JavaScriptParser.SourceElementsContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = JavaScriptParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 172
                self.match(JavaScriptParser.HashBangLine)


            self.state = 176
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 175
                self.sourceElements()


            self.state = 178
            self.match(JavaScriptParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_sourceElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceElement" ):
                listener.enterSourceElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceElement" ):
                listener.exitSourceElement(self)




    def sourceElement(self):

        localctx = JavaScriptParser.SourceElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sourceElement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(JavaScriptParser.BlockContext,0)


        def variableStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableStatementContext,0)


        def importStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportStatementContext,0)


        def exportStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ExportStatementContext,0)


        def emptyStatement_(self):
            return self.getTypedRuleContext(JavaScriptParser.EmptyStatement_Context,0)


        def classDeclaration(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassDeclarationContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionDeclarationContext,0)


        def expressionStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.IfStatementContext,0)


        def iterationStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.IterationStatementContext,0)


        def continueStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ContinueStatementContext,0)


        def breakStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.BreakStatementContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ReturnStatementContext,0)


        def yieldStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.YieldStatementContext,0)


        def withStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.WithStatementContext,0)


        def labelledStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.LabelledStatementContext,0)


        def switchStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.SwitchStatementContext,0)


        def throwStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.ThrowStatementContext,0)


        def tryStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.TryStatementContext,0)


        def debuggerStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.DebuggerStatementContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = JavaScriptParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        try:
            self.state = 202
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 182
                self.block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 183
                self.variableStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 184
                self.importStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 185
                self.exportStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 186
                self.emptyStatement_()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 187
                self.classDeclaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 188
                self.functionDeclaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 189
                self.expressionStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 190
                self.ifStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 191
                self.iterationStatement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 192
                self.continueStatement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 193
                self.breakStatement()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 194
                self.returnStatement()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 195
                self.yieldStatement()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 196
                self.withStatement()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 197
                self.labelledStatement()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 198
                self.switchStatement()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 199
                self.throwStatement()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 200
                self.tryStatement()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 201
                self.debuggerStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def statementList(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)




    def block(self):

        localctx = JavaScriptParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            self.match(JavaScriptParser.OpenBrace)
            self.state = 206
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 205
                self.statementList()


            self.state = 208
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.StatementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.StatementContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_statementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementList" ):
                listener.enterStatementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementList" ):
                listener.exitStatementList(self)




    def statementList(self):

        localctx = JavaScriptParser.StatementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_statementList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 210
                    self.statement()

                else:
                    raise NoViableAltException(self)
                self.state = 213 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Import(self):
            return self.getToken(JavaScriptParser.Import, 0)

        def importFromBlock(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportFromBlockContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_importStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportStatement" ):
                listener.enterImportStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportStatement" ):
                listener.exitImportStatement(self)




    def importStatement(self):

        localctx = JavaScriptParser.ImportStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_importStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            self.match(JavaScriptParser.Import)
            self.state = 216
            self.importFromBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportFromBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importFrom(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportFromContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def importNamespace(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportNamespaceContext,0)


        def importModuleItems(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportModuleItemsContext,0)


        def importDefault(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportDefaultContext,0)


        def StringLiteral(self):
            return self.getToken(JavaScriptParser.StringLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importFromBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportFromBlock" ):
                listener.enterImportFromBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportFromBlock" ):
                listener.exitImportFromBlock(self)




    def importFromBlock(self):

        localctx = JavaScriptParser.ImportFromBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_importFromBlock)
        try:
            self.state = 230
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9, 26, 61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 219
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
                if la_ == 1:
                    self.state = 218
                    self.importDefault()


                self.state = 223
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [26, 61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120]:
                    self.state = 221
                    self.importNamespace()
                    pass
                elif token in [9]:
                    self.state = 222
                    self.importModuleItems()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 225
                self.importFrom()
                self.state = 226
                self.eos()
                pass
            elif token in [121]:
                self.enterOuterAlt(localctx, 2)
                self.state = 228
                self.match(JavaScriptParser.StringLiteral)
                self.state = 229
                self.eos()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportModuleItemsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def importAliasName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ImportAliasNameContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ImportAliasNameContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importModuleItems

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportModuleItems" ):
                listener.enterImportModuleItems(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportModuleItems" ):
                listener.exitImportModuleItems(self)




    def importModuleItems(self):

        localctx = JavaScriptParser.ImportModuleItemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_importModuleItems)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(JavaScriptParser.OpenBrace)
            self.state = 238
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 233
                    self.importAliasName()
                    self.state = 234
                    self.match(JavaScriptParser.Comma) 
                self.state = 240
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

            self.state = 245
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 61)) & ~0x3f) == 0 and ((1 << (_la - 61)) & 2305843009213691907) != 0):
                self.state = 241
                self.importAliasName()
                self.state = 243
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 242
                    self.match(JavaScriptParser.Comma)




            self.state = 247
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportAliasNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def moduleExportName(self):
            return self.getTypedRuleContext(JavaScriptParser.ModuleExportNameContext,0)


        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def importedBinding(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportedBindingContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_importAliasName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportAliasName" ):
                listener.enterImportAliasName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportAliasName" ):
                listener.exitImportAliasName(self)




    def importAliasName(self):

        localctx = JavaScriptParser.ImportAliasNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_importAliasName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.moduleExportName()
            self.state = 252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 250
                self.match(JavaScriptParser.As)
                self.state = 251
                self.importedBinding()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModuleExportNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierName(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,0)


        def StringLiteral(self):
            return self.getToken(JavaScriptParser.StringLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_moduleExportName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModuleExportName" ):
                listener.enterModuleExportName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModuleExportName" ):
                listener.exitModuleExportName(self)




    def moduleExportName(self):

        localctx = JavaScriptParser.ModuleExportNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_moduleExportName)
        try:
            self.state = 256
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 254
                self.identifierName()
                pass
            elif token in [121]:
                self.enterOuterAlt(localctx, 2)
                self.state = 255
                self.match(JavaScriptParser.StringLiteral)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportedBindingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(JavaScriptParser.Identifier, 0)

        def Yield(self):
            return self.getToken(JavaScriptParser.Yield, 0)

        def Await(self):
            return self.getToken(JavaScriptParser.Await, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importedBinding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportedBinding" ):
                listener.enterImportedBinding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportedBinding" ):
                listener.exitImportedBinding(self)




    def importedBinding(self):

        localctx = JavaScriptParser.ImportedBindingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_importedBinding)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            _la = self._input.LA(1)
            if not(((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & 2051) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportDefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aliasName(self):
            return self.getTypedRuleContext(JavaScriptParser.AliasNameContext,0)


        def Comma(self):
            return self.getToken(JavaScriptParser.Comma, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importDefault

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportDefault" ):
                listener.enterImportDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportDefault" ):
                listener.exitImportDefault(self)




    def importDefault(self):

        localctx = JavaScriptParser.ImportDefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_importDefault)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.aliasName()
            self.state = 261
            self.match(JavaScriptParser.Comma)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportNamespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)

        def identifierName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.IdentifierNameContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,i)


        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importNamespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportNamespace" ):
                listener.enterImportNamespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportNamespace" ):
                listener.exitImportNamespace(self)




    def importNamespace(self):

        localctx = JavaScriptParser.ImportNamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_importNamespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26]:
                self.state = 263
                self.match(JavaScriptParser.Multiply)
                pass
            elif token in [61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120]:
                self.state = 264
                self.identifierName()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 269
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 267
                self.match(JavaScriptParser.As)
                self.state = 268
                self.identifierName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportFromContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def From(self):
            return self.getToken(JavaScriptParser.From, 0)

        def StringLiteral(self):
            return self.getToken(JavaScriptParser.StringLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_importFrom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportFrom" ):
                listener.enterImportFrom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportFrom" ):
                listener.exitImportFrom(self)




    def importFrom(self):

        localctx = JavaScriptParser.ImportFromContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_importFrom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.match(JavaScriptParser.From)
            self.state = 272
            self.match(JavaScriptParser.StringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.IdentifierNameContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,i)


        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_aliasName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAliasName" ):
                listener.enterAliasName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAliasName" ):
                listener.exitAliasName(self)




    def aliasName(self):

        localctx = JavaScriptParser.AliasNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_aliasName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.identifierName()
            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 275
                self.match(JavaScriptParser.As)
                self.state = 276
                self.identifierName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExportStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_exportStatement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExportDefaultDeclarationContext(ExportStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.ExportStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Export(self):
            return self.getToken(JavaScriptParser.Export, 0)
        def Default(self):
            return self.getToken(JavaScriptParser.Default, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExportDefaultDeclaration" ):
                listener.enterExportDefaultDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExportDefaultDeclaration" ):
                listener.exitExportDefaultDeclaration(self)


    class ExportDeclarationContext(ExportStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.ExportStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Export(self):
            return self.getToken(JavaScriptParser.Export, 0)
        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)

        def exportFromBlock(self):
            return self.getTypedRuleContext(JavaScriptParser.ExportFromBlockContext,0)

        def declaration(self):
            return self.getTypedRuleContext(JavaScriptParser.DeclarationContext,0)

        def Default(self):
            return self.getToken(JavaScriptParser.Default, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExportDeclaration" ):
                listener.enterExportDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExportDeclaration" ):
                listener.exitExportDeclaration(self)



    def exportStatement(self):

        localctx = JavaScriptParser.ExportStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_exportStatement)
        try:
            self.state = 294
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.ExportDeclarationContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 279
                self.match(JavaScriptParser.Export)
                self.state = 281
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
                if la_ == 1:
                    self.state = 280
                    self.match(JavaScriptParser.Default)


                self.state = 285
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                if la_ == 1:
                    self.state = 283
                    self.exportFromBlock()
                    pass

                elif la_ == 2:
                    self.state = 284
                    self.declaration()
                    pass


                self.state = 287
                self.eos()
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.ExportDefaultDeclarationContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 289
                self.match(JavaScriptParser.Export)
                self.state = 290
                self.match(JavaScriptParser.Default)
                self.state = 291
                self.singleExpression(0)
                self.state = 292
                self.eos()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExportFromBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importNamespace(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportNamespaceContext,0)


        def importFrom(self):
            return self.getTypedRuleContext(JavaScriptParser.ImportFromContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def exportModuleItems(self):
            return self.getTypedRuleContext(JavaScriptParser.ExportModuleItemsContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_exportFromBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExportFromBlock" ):
                listener.enterExportFromBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExportFromBlock" ):
                listener.exitExportFromBlock(self)




    def exportFromBlock(self):

        localctx = JavaScriptParser.ExportFromBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_exportFromBlock)
        try:
            self.state = 306
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26, 61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 296
                self.importNamespace()
                self.state = 297
                self.importFrom()
                self.state = 298
                self.eos()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 300
                self.exportModuleItems()
                self.state = 302
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
                if la_ == 1:
                    self.state = 301
                    self.importFrom()


                self.state = 304
                self.eos()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExportModuleItemsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def exportAliasName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ExportAliasNameContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ExportAliasNameContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_exportModuleItems

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExportModuleItems" ):
                listener.enterExportModuleItems(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExportModuleItems" ):
                listener.exitExportModuleItems(self)




    def exportModuleItems(self):

        localctx = JavaScriptParser.ExportModuleItemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_exportModuleItems)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 308
            self.match(JavaScriptParser.OpenBrace)
            self.state = 314
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,21,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 309
                    self.exportAliasName()
                    self.state = 310
                    self.match(JavaScriptParser.Comma) 
                self.state = 316
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

            self.state = 321
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 61)) & ~0x3f) == 0 and ((1 << (_la - 61)) & 2305843009213691907) != 0):
                self.state = 317
                self.exportAliasName()
                self.state = 319
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 318
                    self.match(JavaScriptParser.Comma)




            self.state = 323
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExportAliasNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def moduleExportName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ModuleExportNameContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ModuleExportNameContext,i)


        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_exportAliasName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExportAliasName" ):
                listener.enterExportAliasName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExportAliasName" ):
                listener.exitExportAliasName(self)




    def exportAliasName(self):

        localctx = JavaScriptParser.ExportAliasNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_exportAliasName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            self.moduleExportName()
            self.state = 328
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 326
                self.match(JavaScriptParser.As)
                self.state = 327
                self.moduleExportName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableStatementContext,0)


        def classDeclaration(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassDeclarationContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionDeclarationContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)




    def declaration(self):

        localctx = JavaScriptParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_declaration)
        try:
            self.state = 333
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [79, 105, 112, 113]:
                self.enterOuterAlt(localctx, 1)
                self.state = 330
                self.variableStatement()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 331
                self.classDeclaration()
                pass
            elif token in [89, 108]:
                self.enterOuterAlt(localctx, 3)
                self.state = 332
                self.functionDeclaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclarationList(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationListContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_variableStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableStatement" ):
                listener.enterVariableStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableStatement" ):
                listener.exitVariableStatement(self)




    def variableStatement(self):

        localctx = JavaScriptParser.VariableStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_variableStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 335
            self.variableDeclarationList()
            self.state = 336
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varModifier(self):
            return self.getTypedRuleContext(JavaScriptParser.VarModifierContext,0)


        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_variableDeclarationList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclarationList" ):
                listener.enterVariableDeclarationList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclarationList" ):
                listener.exitVariableDeclarationList(self)




    def variableDeclarationList(self):

        localctx = JavaScriptParser.VariableDeclarationListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_variableDeclarationList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.varModifier()
            self.state = 339
            self.variableDeclaration()
            self.state = 344
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,26,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 340
                    self.match(JavaScriptParser.Comma)
                    self.state = 341
                    self.variableDeclaration() 
                self.state = 346
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,26,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignable(self):
            return self.getTypedRuleContext(JavaScriptParser.AssignableContext,0)


        def Assign(self):
            return self.getToken(JavaScriptParser.Assign, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)




    def variableDeclaration(self):

        localctx = JavaScriptParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_variableDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 347
            self.assignable()
            self.state = 350
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.state = 348
                self.match(JavaScriptParser.Assign)
                self.state = 349
                self.singleExpression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmptyStatement_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SemiColon(self):
            return self.getToken(JavaScriptParser.SemiColon, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_emptyStatement_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyStatement_" ):
                listener.enterEmptyStatement_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyStatement_" ):
                listener.exitEmptyStatement_(self)




    def emptyStatement_(self):

        localctx = JavaScriptParser.EmptyStatement_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_emptyStatement_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 352
            self.match(JavaScriptParser.SemiColon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_expressionStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatement" ):
                listener.enterExpressionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatement" ):
                listener.exitExpressionStatement(self)




    def expressionStatement(self):

        localctx = JavaScriptParser.ExpressionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_expressionStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 354
            if not self.notOpenBraceAndNotFunction():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.notOpenBraceAndNotFunction()")
            self.state = 355
            self.expressionSequence()
            self.state = 356
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def If(self):
            return self.getToken(JavaScriptParser.If, 0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.StatementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.StatementContext,i)


        def Else(self):
            return self.getToken(JavaScriptParser.Else, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)




    def ifStatement(self):

        localctx = JavaScriptParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            self.match(JavaScriptParser.If)
            self.state = 359
            self.match(JavaScriptParser.OpenParen)
            self.state = 360
            self.expressionSequence()
            self.state = 361
            self.match(JavaScriptParser.CloseParen)
            self.state = 362
            self.statement()
            self.state = 365
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.state = 363
                self.match(JavaScriptParser.Else)
                self.state = 364
                self.statement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IterationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_iterationStatement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DoStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Do(self):
            return self.getToken(JavaScriptParser.Do, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)

        def While(self):
            return self.getToken(JavaScriptParser.While, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoStatement" ):
                listener.enterDoStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoStatement" ):
                listener.exitDoStatement(self)


    class WhileStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def While(self):
            return self.getToken(JavaScriptParser.While, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStatement" ):
                listener.enterWhileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStatement" ):
                listener.exitWhileStatement(self)


    class ForStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(JavaScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def SemiColon(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.SemiColon)
            else:
                return self.getToken(JavaScriptParser.SemiColon, i)
        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)

        def expressionSequence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ExpressionSequenceContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,i)

        def variableDeclarationList(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStatement" ):
                listener.enterForStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStatement" ):
                listener.exitForStatement(self)


    class ForInStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(JavaScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def In(self):
            return self.getToken(JavaScriptParser.In, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def variableDeclarationList(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForInStatement" ):
                listener.enterForInStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForInStatement" ):
                listener.exitForInStatement(self)


    class ForOfStatementContext(IterationStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.IterationStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def For(self):
            return self.getToken(JavaScriptParser.For, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def Of(self):
            return self.getToken(JavaScriptParser.Of, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def variableDeclarationList(self):
            return self.getTypedRuleContext(JavaScriptParser.VariableDeclarationListContext,0)

        def Await(self):
            return self.getToken(JavaScriptParser.Await, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForOfStatement" ):
                listener.enterForOfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForOfStatement" ):
                listener.exitForOfStatement(self)



    def iterationStatement(self):

        localctx = JavaScriptParser.IterationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_iterationStatement)
        self._la = 0 # Token type
        try:
            self.state = 422
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.DoStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 367
                self.match(JavaScriptParser.Do)
                self.state = 368
                self.statement()
                self.state = 369
                self.match(JavaScriptParser.While)
                self.state = 370
                self.match(JavaScriptParser.OpenParen)
                self.state = 371
                self.expressionSequence()
                self.state = 372
                self.match(JavaScriptParser.CloseParen)
                self.state = 373
                self.eos()
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.WhileStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 375
                self.match(JavaScriptParser.While)
                self.state = 376
                self.match(JavaScriptParser.OpenParen)
                self.state = 377
                self.expressionSequence()
                self.state = 378
                self.match(JavaScriptParser.CloseParen)
                self.state = 379
                self.statement()
                pass

            elif la_ == 3:
                localctx = JavaScriptParser.ForStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 381
                self.match(JavaScriptParser.For)
                self.state = 382
                self.match(JavaScriptParser.OpenParen)
                self.state = 385
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
                if la_ == 1:
                    self.state = 383
                    self.expressionSequence()

                elif la_ == 2:
                    self.state = 384
                    self.variableDeclarationList()


                self.state = 387
                self.match(JavaScriptParser.SemiColon)
                self.state = 389
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009147632976) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 505099409072605439) != 0):
                    self.state = 388
                    self.expressionSequence()


                self.state = 391
                self.match(JavaScriptParser.SemiColon)
                self.state = 393
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009147632976) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 505099409072605439) != 0):
                    self.state = 392
                    self.expressionSequence()


                self.state = 395
                self.match(JavaScriptParser.CloseParen)
                self.state = 396
                self.statement()
                pass

            elif la_ == 4:
                localctx = JavaScriptParser.ForInStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 397
                self.match(JavaScriptParser.For)
                self.state = 398
                self.match(JavaScriptParser.OpenParen)
                self.state = 401
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
                if la_ == 1:
                    self.state = 399
                    self.singleExpression(0)
                    pass

                elif la_ == 2:
                    self.state = 400
                    self.variableDeclarationList()
                    pass


                self.state = 403
                self.match(JavaScriptParser.In)
                self.state = 404
                self.expressionSequence()
                self.state = 405
                self.match(JavaScriptParser.CloseParen)
                self.state = 406
                self.statement()
                pass

            elif la_ == 5:
                localctx = JavaScriptParser.ForOfStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 408
                self.match(JavaScriptParser.For)
                self.state = 410
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==109:
                    self.state = 409
                    self.match(JavaScriptParser.Await)


                self.state = 412
                self.match(JavaScriptParser.OpenParen)
                self.state = 415
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
                if la_ == 1:
                    self.state = 413
                    self.singleExpression(0)
                    pass

                elif la_ == 2:
                    self.state = 414
                    self.variableDeclarationList()
                    pass


                self.state = 417
                self.match(JavaScriptParser.Of)
                self.state = 418
                self.expressionSequence()
                self.state = 419
                self.match(JavaScriptParser.CloseParen)
                self.state = 420
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Var(self):
            return self.getToken(JavaScriptParser.Var, 0)

        def let_(self):
            return self.getTypedRuleContext(JavaScriptParser.Let_Context,0)


        def Const(self):
            return self.getToken(JavaScriptParser.Const, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_varModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarModifier" ):
                listener.enterVarModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarModifier" ):
                listener.exitVarModifier(self)




    def varModifier(self):

        localctx = JavaScriptParser.VarModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_varModifier)
        try:
            self.state = 427
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [79]:
                self.enterOuterAlt(localctx, 1)
                self.state = 424
                self.match(JavaScriptParser.Var)
                pass
            elif token in [112, 113]:
                self.enterOuterAlt(localctx, 2)
                self.state = 425
                self.let_()
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 3)
                self.state = 426
                self.match(JavaScriptParser.Const)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContinueStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Continue(self):
            return self.getToken(JavaScriptParser.Continue, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_continueStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinueStatement" ):
                listener.enterContinueStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinueStatement" ):
                listener.exitContinueStatement(self)




    def continueStatement(self):

        localctx = JavaScriptParser.ContinueStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_continueStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 429
            self.match(JavaScriptParser.Continue)
            self.state = 432
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.state = 430
                if not self.notLineTerminator():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.notLineTerminator()")
                self.state = 431
                self.identifier()


            self.state = 434
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Break(self):
            return self.getToken(JavaScriptParser.Break, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_breakStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakStatement" ):
                listener.enterBreakStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakStatement" ):
                listener.exitBreakStatement(self)




    def breakStatement(self):

        localctx = JavaScriptParser.BreakStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_breakStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 436
            self.match(JavaScriptParser.Break)
            self.state = 439
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.state = 437
                if not self.notLineTerminator():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.notLineTerminator()")
                self.state = 438
                self.identifier()


            self.state = 441
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Return(self):
            return self.getToken(JavaScriptParser.Return, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)




    def returnStatement(self):

        localctx = JavaScriptParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 443
            self.match(JavaScriptParser.Return)
            self.state = 446
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.state = 444
                if not self.notLineTerminator():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.notLineTerminator()")
                self.state = 445
                self.expressionSequence()


            self.state = 448
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YieldStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Yield(self):
            return self.getToken(JavaScriptParser.Yield, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_yieldStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldStatement" ):
                listener.enterYieldStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldStatement" ):
                listener.exitYieldStatement(self)




    def yieldStatement(self):

        localctx = JavaScriptParser.YieldStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_yieldStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 450
            self.match(JavaScriptParser.Yield)
            self.state = 453
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                self.state = 451
                if not self.notLineTerminator():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.notLineTerminator()")
                self.state = 452
                self.expressionSequence()


            self.state = 455
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def With(self):
            return self.getToken(JavaScriptParser.With, 0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_withStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithStatement" ):
                listener.enterWithStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithStatement" ):
                listener.exitWithStatement(self)




    def withStatement(self):

        localctx = JavaScriptParser.WithStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_withStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 457
            self.match(JavaScriptParser.With)
            self.state = 458
            self.match(JavaScriptParser.OpenParen)
            self.state = 459
            self.expressionSequence()
            self.state = 460
            self.match(JavaScriptParser.CloseParen)
            self.state = 461
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SwitchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Switch(self):
            return self.getToken(JavaScriptParser.Switch, 0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def caseBlock(self):
            return self.getTypedRuleContext(JavaScriptParser.CaseBlockContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_switchStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitchStatement" ):
                listener.enterSwitchStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitchStatement" ):
                listener.exitSwitchStatement(self)




    def switchStatement(self):

        localctx = JavaScriptParser.SwitchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_switchStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self.match(JavaScriptParser.Switch)
            self.state = 464
            self.match(JavaScriptParser.OpenParen)
            self.state = 465
            self.expressionSequence()
            self.state = 466
            self.match(JavaScriptParser.CloseParen)
            self.state = 467
            self.caseBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def caseClauses(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.CaseClausesContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.CaseClausesContext,i)


        def defaultClause(self):
            return self.getTypedRuleContext(JavaScriptParser.DefaultClauseContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_caseBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseBlock" ):
                listener.enterCaseBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseBlock" ):
                listener.exitCaseBlock(self)




    def caseBlock(self):

        localctx = JavaScriptParser.CaseBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_caseBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 469
            self.match(JavaScriptParser.OpenBrace)
            self.state = 471
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==76:
                self.state = 470
                self.caseClauses()


            self.state = 477
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==92:
                self.state = 473
                self.defaultClause()
                self.state = 475
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==76:
                    self.state = 474
                    self.caseClauses()




            self.state = 479
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def caseClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.CaseClauseContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.CaseClauseContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_caseClauses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClauses" ):
                listener.enterCaseClauses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClauses" ):
                listener.exitCaseClauses(self)




    def caseClauses(self):

        localctx = JavaScriptParser.CaseClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_caseClauses)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 482 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 481
                self.caseClause()
                self.state = 484 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==76):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Case(self):
            return self.getToken(JavaScriptParser.Case, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def statementList(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_caseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClause" ):
                listener.enterCaseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClause" ):
                listener.exitCaseClause(self)




    def caseClause(self):

        localctx = JavaScriptParser.CaseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_caseClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 486
            self.match(JavaScriptParser.Case)
            self.state = 487
            self.expressionSequence()
            self.state = 488
            self.match(JavaScriptParser.Colon)
            self.state = 490
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.state = 489
                self.statementList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Default(self):
            return self.getToken(JavaScriptParser.Default, 0)

        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def statementList(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_defaultClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultClause" ):
                listener.enterDefaultClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultClause" ):
                listener.exitDefaultClause(self)




    def defaultClause(self):

        localctx = JavaScriptParser.DefaultClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_defaultClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 492
            self.match(JavaScriptParser.Default)
            self.state = 493
            self.match(JavaScriptParser.Colon)
            self.state = 495
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.state = 494
                self.statementList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelledStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def statement(self):
            return self.getTypedRuleContext(JavaScriptParser.StatementContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_labelledStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelledStatement" ):
                listener.enterLabelledStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelledStatement" ):
                listener.exitLabelledStatement(self)




    def labelledStatement(self):

        localctx = JavaScriptParser.LabelledStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_labelledStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 497
            self.identifier()
            self.state = 498
            self.match(JavaScriptParser.Colon)
            self.state = 499
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThrowStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Throw(self):
            return self.getToken(JavaScriptParser.Throw, 0)

        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)


        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_throwStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThrowStatement" ):
                listener.enterThrowStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThrowStatement" ):
                listener.exitThrowStatement(self)




    def throwStatement(self):

        localctx = JavaScriptParser.ThrowStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_throwStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 501
            self.match(JavaScriptParser.Throw)
            self.state = 502
            if not self.notLineTerminator():
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.notLineTerminator()")
            self.state = 503
            self.expressionSequence()
            self.state = 504
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TryStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Try(self):
            return self.getToken(JavaScriptParser.Try, 0)

        def block(self):
            return self.getTypedRuleContext(JavaScriptParser.BlockContext,0)


        def catchProduction(self):
            return self.getTypedRuleContext(JavaScriptParser.CatchProductionContext,0)


        def finallyProduction(self):
            return self.getTypedRuleContext(JavaScriptParser.FinallyProductionContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_tryStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTryStatement" ):
                listener.enterTryStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTryStatement" ):
                listener.exitTryStatement(self)




    def tryStatement(self):

        localctx = JavaScriptParser.TryStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_tryStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 506
            self.match(JavaScriptParser.Try)
            self.state = 507
            self.block()
            self.state = 513
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [80]:
                self.state = 508
                self.catchProduction()
                self.state = 510
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                if la_ == 1:
                    self.state = 509
                    self.finallyProduction()


                pass
            elif token in [81]:
                self.state = 512
                self.finallyProduction()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CatchProductionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Catch(self):
            return self.getToken(JavaScriptParser.Catch, 0)

        def block(self):
            return self.getTypedRuleContext(JavaScriptParser.BlockContext,0)


        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def assignable(self):
            return self.getTypedRuleContext(JavaScriptParser.AssignableContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_catchProduction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCatchProduction" ):
                listener.enterCatchProduction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCatchProduction" ):
                listener.exitCatchProduction(self)




    def catchProduction(self):

        localctx = JavaScriptParser.CatchProductionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_catchProduction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            self.match(JavaScriptParser.Catch)
            self.state = 521
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 516
                self.match(JavaScriptParser.OpenParen)
                self.state = 518
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==5 or _la==9 or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 4232199) != 0):
                    self.state = 517
                    self.assignable()


                self.state = 520
                self.match(JavaScriptParser.CloseParen)


            self.state = 523
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FinallyProductionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Finally(self):
            return self.getToken(JavaScriptParser.Finally, 0)

        def block(self):
            return self.getTypedRuleContext(JavaScriptParser.BlockContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_finallyProduction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFinallyProduction" ):
                listener.enterFinallyProduction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFinallyProduction" ):
                listener.exitFinallyProduction(self)




    def finallyProduction(self):

        localctx = JavaScriptParser.FinallyProductionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_finallyProduction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 525
            self.match(JavaScriptParser.Finally)
            self.state = 526
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DebuggerStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Debugger(self):
            return self.getToken(JavaScriptParser.Debugger, 0)

        def eos(self):
            return self.getTypedRuleContext(JavaScriptParser.EosContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_debuggerStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDebuggerStatement" ):
                listener.enterDebuggerStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDebuggerStatement" ):
                listener.exitDebuggerStatement(self)




    def debuggerStatement(self):

        localctx = JavaScriptParser.DebuggerStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_debuggerStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            self.match(JavaScriptParser.Debugger)
            self.state = 529
            self.eos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Function_(self):
            return self.getToken(JavaScriptParser.Function_, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)

        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)

        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_functionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDeclaration" ):
                listener.enterFunctionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDeclaration" ):
                listener.exitFunctionDeclaration(self)




    def functionDeclaration(self):

        localctx = JavaScriptParser.FunctionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_functionDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 532
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 531
                self.match(JavaScriptParser.Async)


            self.state = 534
            self.match(JavaScriptParser.Function_)
            self.state = 536
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 535
                self.match(JavaScriptParser.Multiply)


            self.state = 538
            self.identifier()
            self.state = 539
            self.match(JavaScriptParser.OpenParen)
            self.state = 541
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 4232199) != 0):
                self.state = 540
                self.formalParameterList()


            self.state = 543
            self.match(JavaScriptParser.CloseParen)
            self.state = 544
            self.functionBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Class(self):
            return self.getToken(JavaScriptParser.Class, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def classTail(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassTailContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_classDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassDeclaration" ):
                listener.enterClassDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassDeclaration" ):
                listener.exitClassDeclaration(self)




    def classDeclaration(self):

        localctx = JavaScriptParser.ClassDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_classDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 546
            self.match(JavaScriptParser.Class)
            self.state = 547
            self.identifier()
            self.state = 548
            self.classTail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassTailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def Extends(self):
            return self.getToken(JavaScriptParser.Extends, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def classElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ClassElementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ClassElementContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_classTail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassTail" ):
                listener.enterClassTail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassTail" ):
                listener.exitClassTail(self)




    def classTail(self):

        localctx = JavaScriptParser.ClassTailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_classTail)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 552
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==103:
                self.state = 550
                self.match(JavaScriptParser.Extends)
                self.state = 551
                self.singleExpression(0)


            self.state = 554
            self.match(JavaScriptParser.OpenBrace)
            self.state = 558
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,55,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 555
                    self.classElement() 
                self.state = 560
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,55,self._ctx)

            self.state = 561
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodDefinition(self):
            return self.getTypedRuleContext(JavaScriptParser.MethodDefinitionContext,0)


        def Static(self):
            return self.getToken(JavaScriptParser.Static, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def fieldDefinition(self):
            return self.getTypedRuleContext(JavaScriptParser.FieldDefinitionContext,0)


        def block(self):
            return self.getTypedRuleContext(JavaScriptParser.BlockContext,0)


        def emptyStatement_(self):
            return self.getTypedRuleContext(JavaScriptParser.EmptyStatement_Context,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_classElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassElement" ):
                listener.enterClassElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassElement" ):
                listener.exitClassElement(self)




    def classElement(self):

        localctx = JavaScriptParser.ClassElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_classElement)
        try:
            self.state = 582
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 566
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
                if la_ == 1:
                    self.state = 563
                    self.match(JavaScriptParser.Static)

                elif la_ == 2:
                    self.state = 564
                    if not self.n("static"):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.n(\"static\")")
                    self.state = 565
                    self.identifier()


                self.state = 568
                self.methodDefinition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 572
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
                if la_ == 1:
                    self.state = 569
                    self.match(JavaScriptParser.Static)

                elif la_ == 2:
                    self.state = 570
                    if not self.n("static"):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.n(\"static\")")
                    self.state = 571
                    self.identifier()


                self.state = 574
                self.fieldDefinition()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 578
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                if la_ == 1:
                    self.state = 575
                    self.match(JavaScriptParser.Static)
                    pass

                elif la_ == 2:
                    self.state = 576
                    if not self.n("static"):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.n(\"static\")")
                    self.state = 577
                    self.identifier()
                    pass


                self.state = 580
                self.block()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 581
                self.emptyStatement_()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classElementName(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassElementNameContext,0)


        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)

        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)

        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def getter(self):
            return self.getTypedRuleContext(JavaScriptParser.GetterContext,0)


        def setter(self):
            return self.getTypedRuleContext(JavaScriptParser.SetterContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_methodDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodDefinition" ):
                listener.enterMethodDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodDefinition" ):
                listener.exitMethodDefinition(self)




    def methodDefinition(self):

        localctx = JavaScriptParser.MethodDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_methodDefinition)
        self._la = 0 # Token type
        try:
            self.state = 618
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 586
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
                if la_ == 1:
                    self.state = 584
                    self.match(JavaScriptParser.Async)
                    self.state = 585
                    if not self.notLineTerminator():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.notLineTerminator()")


                self.state = 589
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 588
                    self.match(JavaScriptParser.Multiply)


                self.state = 591
                self.classElementName()
                self.state = 592
                self.match(JavaScriptParser.OpenParen)
                self.state = 594
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 4232199) != 0):
                    self.state = 593
                    self.formalParameterList()


                self.state = 596
                self.match(JavaScriptParser.CloseParen)
                self.state = 597
                self.functionBody()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 600
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
                if la_ == 1:
                    self.state = 599
                    self.match(JavaScriptParser.Multiply)


                self.state = 602
                self.getter()
                self.state = 603
                self.match(JavaScriptParser.OpenParen)
                self.state = 604
                self.match(JavaScriptParser.CloseParen)
                self.state = 605
                self.functionBody()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 608
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
                if la_ == 1:
                    self.state = 607
                    self.match(JavaScriptParser.Multiply)


                self.state = 610
                self.setter()
                self.state = 611
                self.match(JavaScriptParser.OpenParen)
                self.state = 613
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 4232199) != 0):
                    self.state = 612
                    self.formalParameterList()


                self.state = 615
                self.match(JavaScriptParser.CloseParen)
                self.state = 616
                self.functionBody()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classElementName(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassElementNameContext,0)


        def initializer(self):
            return self.getTypedRuleContext(JavaScriptParser.InitializerContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_fieldDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldDefinition" ):
                listener.enterFieldDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldDefinition" ):
                listener.exitFieldDefinition(self)




    def fieldDefinition(self):

        localctx = JavaScriptParser.FieldDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_fieldDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 620
            self.classElementName()
            self.state = 622
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.state = 621
                self.initializer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassElementNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyName(self):
            return self.getTypedRuleContext(JavaScriptParser.PropertyNameContext,0)


        def privateIdentifier(self):
            return self.getTypedRuleContext(JavaScriptParser.PrivateIdentifierContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_classElementName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassElementName" ):
                listener.enterClassElementName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassElementName" ):
                listener.exitClassElementName(self)




    def classElementName(self):

        localctx = JavaScriptParser.ClassElementNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_classElementName)
        try:
            self.state = 626
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 61, 62, 63, 64, 65, 66, 67, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121]:
                self.enterOuterAlt(localctx, 1)
                self.state = 624
                self.propertyName()
                pass
            elif token in [31]:
                self.enterOuterAlt(localctx, 2)
                self.state = 625
                self.privateIdentifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrivateIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Hashtag(self):
            return self.getToken(JavaScriptParser.Hashtag, 0)

        def identifierName(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_privateIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrivateIdentifier" ):
                listener.enterPrivateIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrivateIdentifier" ):
                listener.exitPrivateIdentifier(self)




    def privateIdentifier(self):

        localctx = JavaScriptParser.PrivateIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_privateIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 628
            self.match(JavaScriptParser.Hashtag)
            self.state = 629
            self.identifierName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormalParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formalParameterArg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.FormalParameterArgContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.FormalParameterArgContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def lastFormalParameterArg(self):
            return self.getTypedRuleContext(JavaScriptParser.LastFormalParameterArgContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_formalParameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormalParameterList" ):
                listener.enterFormalParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormalParameterList" ):
                listener.exitFormalParameterList(self)




    def formalParameterList(self):

        localctx = JavaScriptParser.FormalParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_formalParameterList)
        self._la = 0 # Token type
        try:
            self.state = 644
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 9, 98, 99, 100, 108, 110, 113, 120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 631
                self.formalParameterArg()
                self.state = 636
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,69,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 632
                        self.match(JavaScriptParser.Comma)
                        self.state = 633
                        self.formalParameterArg() 
                    self.state = 638
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,69,self._ctx)

                self.state = 641
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 639
                    self.match(JavaScriptParser.Comma)
                    self.state = 640
                    self.lastFormalParameterArg()


                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 643
                self.lastFormalParameterArg()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormalParameterArgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignable(self):
            return self.getTypedRuleContext(JavaScriptParser.AssignableContext,0)


        def Assign(self):
            return self.getToken(JavaScriptParser.Assign, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_formalParameterArg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormalParameterArg" ):
                listener.enterFormalParameterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormalParameterArg" ):
                listener.exitFormalParameterArg(self)




    def formalParameterArg(self):

        localctx = JavaScriptParser.FormalParameterArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_formalParameterArg)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 646
            self.assignable()
            self.state = 649
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 647
                self.match(JavaScriptParser.Assign)
                self.state = 648
                self.singleExpression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LastFormalParameterArgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Ellipsis(self):
            return self.getToken(JavaScriptParser.Ellipsis, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_lastFormalParameterArg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLastFormalParameterArg" ):
                listener.enterLastFormalParameterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLastFormalParameterArg" ):
                listener.exitLastFormalParameterArg(self)




    def lastFormalParameterArg(self):

        localctx = JavaScriptParser.LastFormalParameterArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_lastFormalParameterArg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 651
            self.match(JavaScriptParser.Ellipsis)
            self.state = 652
            self.singleExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def sourceElements(self):
            return self.getTypedRuleContext(JavaScriptParser.SourceElementsContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_functionBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionBody" ):
                listener.enterFunctionBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionBody" ):
                listener.exitFunctionBody(self)




    def functionBody(self):

        localctx = JavaScriptParser.FunctionBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_functionBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 654
            self.match(JavaScriptParser.OpenBrace)
            self.state = 656
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
            if la_ == 1:
                self.state = 655
                self.sourceElements()


            self.state = 658
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceElementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sourceElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SourceElementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SourceElementContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_sourceElements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceElements" ):
                listener.enterSourceElements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceElements" ):
                listener.exitSourceElements(self)




    def sourceElements(self):

        localctx = JavaScriptParser.SourceElementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_sourceElements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 661 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 660
                    self.sourceElement()

                else:
                    raise NoViableAltException(self)
                self.state = 663 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,74,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBracket(self):
            return self.getToken(JavaScriptParser.OpenBracket, 0)

        def elementList(self):
            return self.getTypedRuleContext(JavaScriptParser.ElementListContext,0)


        def CloseBracket(self):
            return self.getToken(JavaScriptParser.CloseBracket, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_arrayLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayLiteral" ):
                listener.enterArrayLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayLiteral" ):
                listener.exitArrayLiteral(self)




    def arrayLiteral(self):

        localctx = JavaScriptParser.ArrayLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_arrayLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 665
            self.match(JavaScriptParser.OpenBracket)
            self.state = 666
            self.elementList()
            self.state = 667
            self.match(JavaScriptParser.CloseBracket)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def arrayElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ArrayElementContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ArrayElementContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_elementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementList" ):
                listener.enterElementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementList" ):
                listener.exitElementList(self)




    def elementList(self):

        localctx = JavaScriptParser.ElementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_elementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 672
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,75,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 669
                    self.match(JavaScriptParser.Comma) 
                self.state = 674
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,75,self._ctx)

            self.state = 676
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009147370832) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 505099409072605439) != 0):
                self.state = 675
                self.arrayElement()


            self.state = 686
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,78,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 679 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 678
                        self.match(JavaScriptParser.Comma)
                        self.state = 681 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==13):
                            break

                    self.state = 683
                    self.arrayElement() 
                self.state = 688
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,78,self._ctx)

            self.state = 692
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==13:
                self.state = 689
                self.match(JavaScriptParser.Comma)
                self.state = 694
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def Ellipsis(self):
            return self.getToken(JavaScriptParser.Ellipsis, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_arrayElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayElement" ):
                listener.enterArrayElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayElement" ):
                listener.exitArrayElement(self)




    def arrayElement(self):

        localctx = JavaScriptParser.ArrayElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_arrayElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 696
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==18:
                self.state = 695
                self.match(JavaScriptParser.Ellipsis)


            self.state = 698
            self.singleExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_propertyAssignment

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PropertyExpressionAssignmentContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def propertyName(self):
            return self.getTypedRuleContext(JavaScriptParser.PropertyNameContext,0)

        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyExpressionAssignment" ):
                listener.enterPropertyExpressionAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyExpressionAssignment" ):
                listener.exitPropertyExpressionAssignment(self)


    class ComputedPropertyExpressionAssignmentContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OpenBracket(self):
            return self.getToken(JavaScriptParser.OpenBracket, 0)
        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def CloseBracket(self):
            return self.getToken(JavaScriptParser.CloseBracket, 0)
        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComputedPropertyExpressionAssignment" ):
                listener.enterComputedPropertyExpressionAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComputedPropertyExpressionAssignment" ):
                listener.exitComputedPropertyExpressionAssignment(self)


    class PropertyShorthandContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def Ellipsis(self):
            return self.getToken(JavaScriptParser.Ellipsis, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyShorthand" ):
                listener.enterPropertyShorthand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyShorthand" ):
                listener.exitPropertyShorthand(self)


    class PropertySetterContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def setter(self):
            return self.getTypedRuleContext(JavaScriptParser.SetterContext,0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def formalParameterArg(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterArgContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertySetter" ):
                listener.enterPropertySetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertySetter" ):
                listener.exitPropertySetter(self)


    class PropertyGetterContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def getter(self):
            return self.getTypedRuleContext(JavaScriptParser.GetterContext,0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyGetter" ):
                listener.enterPropertyGetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyGetter" ):
                listener.exitPropertyGetter(self)


    class FunctionPropertyContext(PropertyAssignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.PropertyAssignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def propertyName(self):
            return self.getTypedRuleContext(JavaScriptParser.PropertyNameContext,0)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)
        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)
        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionProperty" ):
                listener.enterFunctionProperty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionProperty" ):
                listener.exitFunctionProperty(self)



    def propertyAssignment(self):

        localctx = JavaScriptParser.PropertyAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_propertyAssignment)
        self._la = 0 # Token type
        try:
            self.state = 739
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.PropertyExpressionAssignmentContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 700
                self.propertyName()
                self.state = 701
                self.match(JavaScriptParser.Colon)
                self.state = 702
                self.singleExpression(0)
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.ComputedPropertyExpressionAssignmentContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 704
                self.match(JavaScriptParser.OpenBracket)
                self.state = 705
                self.singleExpression(0)
                self.state = 706
                self.match(JavaScriptParser.CloseBracket)
                self.state = 707
                self.match(JavaScriptParser.Colon)
                self.state = 708
                self.singleExpression(0)
                pass

            elif la_ == 3:
                localctx = JavaScriptParser.FunctionPropertyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 711
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
                if la_ == 1:
                    self.state = 710
                    self.match(JavaScriptParser.Async)


                self.state = 714
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 713
                    self.match(JavaScriptParser.Multiply)


                self.state = 716
                self.propertyName()
                self.state = 717
                self.match(JavaScriptParser.OpenParen)
                self.state = 719
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 4232199) != 0):
                    self.state = 718
                    self.formalParameterList()


                self.state = 721
                self.match(JavaScriptParser.CloseParen)
                self.state = 722
                self.functionBody()
                pass

            elif la_ == 4:
                localctx = JavaScriptParser.PropertyGetterContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 724
                self.getter()
                self.state = 725
                self.match(JavaScriptParser.OpenParen)
                self.state = 726
                self.match(JavaScriptParser.CloseParen)
                self.state = 727
                self.functionBody()
                pass

            elif la_ == 5:
                localctx = JavaScriptParser.PropertySetterContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 729
                self.setter()
                self.state = 730
                self.match(JavaScriptParser.OpenParen)
                self.state = 731
                self.formalParameterArg()
                self.state = 732
                self.match(JavaScriptParser.CloseParen)
                self.state = 733
                self.functionBody()
                pass

            elif la_ == 6:
                localctx = JavaScriptParser.PropertyShorthandContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 736
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==18:
                    self.state = 735
                    self.match(JavaScriptParser.Ellipsis)


                self.state = 738
                self.singleExpression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierName(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,0)


        def StringLiteral(self):
            return self.getToken(JavaScriptParser.StringLiteral, 0)

        def numericLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.NumericLiteralContext,0)


        def OpenBracket(self):
            return self.getToken(JavaScriptParser.OpenBracket, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def CloseBracket(self):
            return self.getToken(JavaScriptParser.CloseBracket, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_propertyName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyName" ):
                listener.enterPropertyName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyName" ):
                listener.exitPropertyName(self)




    def propertyName(self):

        localctx = JavaScriptParser.PropertyNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_propertyName)
        try:
            self.state = 748
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [61, 62, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 741
                self.identifierName()
                pass
            elif token in [121]:
                self.enterOuterAlt(localctx, 2)
                self.state = 742
                self.match(JavaScriptParser.StringLiteral)
                pass
            elif token in [63, 64, 65, 66, 67]:
                self.enterOuterAlt(localctx, 3)
                self.state = 743
                self.numericLiteral()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 4)
                self.state = 744
                self.match(JavaScriptParser.OpenBracket)
                self.state = 745
                self.singleExpression(0)
                self.state = 746
                self.match(JavaScriptParser.CloseBracket)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.ArgumentContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArguments" ):
                listener.enterArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArguments" ):
                listener.exitArguments(self)




    def arguments(self):

        localctx = JavaScriptParser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 750
            self.match(JavaScriptParser.OpenParen)
            self.state = 762
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -2305843009147370832) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 505099409072605439) != 0):
                self.state = 751
                self.argument()
                self.state = 756
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,87,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 752
                        self.match(JavaScriptParser.Comma)
                        self.state = 753
                        self.argument() 
                    self.state = 758
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,87,self._ctx)

                self.state = 760
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 759
                    self.match(JavaScriptParser.Comma)




            self.state = 764
            self.match(JavaScriptParser.CloseParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def Ellipsis(self):
            return self.getToken(JavaScriptParser.Ellipsis, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)




    def argument(self):

        localctx = JavaScriptParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_argument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 767
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==18:
                self.state = 766
                self.match(JavaScriptParser.Ellipsis)


            self.state = 771
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.state = 769
                self.singleExpression(0)
                pass

            elif la_ == 2:
                self.state = 770
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionSequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_expressionSequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionSequence" ):
                listener.enterExpressionSequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionSequence" ):
                listener.exitExpressionSequence(self)




    def expressionSequence(self):

        localctx = JavaScriptParser.ExpressionSequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_expressionSequence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 773
            self.singleExpression(0)
            self.state = 778
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,92,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 774
                    self.match(JavaScriptParser.Comma)
                    self.state = 775
                    self.singleExpression(0) 
                self.state = 780
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,92,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_singleExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TemplateStringExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def templateStringLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.TemplateStringLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplateStringExpression" ):
                listener.enterTemplateStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplateStringExpression" ):
                listener.exitTemplateStringExpression(self)


    class TernaryExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def QuestionMark(self):
            return self.getToken(JavaScriptParser.QuestionMark, 0)
        def Colon(self):
            return self.getToken(JavaScriptParser.Colon, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTernaryExpression" ):
                listener.enterTernaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTernaryExpression" ):
                listener.exitTernaryExpression(self)


    class LogicalAndExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def And(self):
            return self.getToken(JavaScriptParser.And, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalAndExpression" ):
                listener.enterLogicalAndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalAndExpression" ):
                listener.exitLogicalAndExpression(self)


    class PowerExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Power(self):
            return self.getToken(JavaScriptParser.Power, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)


    class PreIncrementExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PlusPlus(self):
            return self.getToken(JavaScriptParser.PlusPlus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreIncrementExpression" ):
                listener.enterPreIncrementExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreIncrementExpression" ):
                listener.exitPreIncrementExpression(self)


    class ObjectLiteralExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.ObjectLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteralExpression" ):
                listener.enterObjectLiteralExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteralExpression" ):
                listener.exitObjectLiteralExpression(self)


    class MetaExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def New(self):
            return self.getToken(JavaScriptParser.New, 0)
        def Dot(self):
            return self.getToken(JavaScriptParser.Dot, 0)
        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaExpression" ):
                listener.enterMetaExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaExpression" ):
                listener.exitMetaExpression(self)


    class InExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def In(self):
            return self.getToken(JavaScriptParser.In, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInExpression" ):
                listener.enterInExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInExpression" ):
                listener.exitInExpression(self)


    class LogicalOrExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Or(self):
            return self.getToken(JavaScriptParser.Or, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOrExpression" ):
                listener.enterLogicalOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOrExpression" ):
                listener.exitLogicalOrExpression(self)


    class OptionalChainExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def QuestionMarkDot(self):
            return self.getToken(JavaScriptParser.QuestionMarkDot, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionalChainExpression" ):
                listener.enterOptionalChainExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionalChainExpression" ):
                listener.exitOptionalChainExpression(self)


    class NotExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Not(self):
            return self.getToken(JavaScriptParser.Not, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotExpression" ):
                listener.enterNotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotExpression" ):
                listener.exitNotExpression(self)


    class PreDecreaseExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MinusMinus(self):
            return self.getToken(JavaScriptParser.MinusMinus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreDecreaseExpression" ):
                listener.enterPreDecreaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreDecreaseExpression" ):
                listener.exitPreDecreaseExpression(self)


    class ArgumentsExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def arguments(self):
            return self.getTypedRuleContext(JavaScriptParser.ArgumentsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentsExpression" ):
                listener.enterArgumentsExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentsExpression" ):
                listener.exitArgumentsExpression(self)


    class AwaitExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Await(self):
            return self.getToken(JavaScriptParser.Await, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAwaitExpression" ):
                listener.enterAwaitExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAwaitExpression" ):
                listener.exitAwaitExpression(self)


    class ThisExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def This(self):
            return self.getToken(JavaScriptParser.This, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThisExpression" ):
                listener.enterThisExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThisExpression" ):
                listener.exitThisExpression(self)


    class FunctionExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def anonymousFunction(self):
            return self.getTypedRuleContext(JavaScriptParser.AnonymousFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionExpression" ):
                listener.enterFunctionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionExpression" ):
                listener.exitFunctionExpression(self)


    class UnaryMinusExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Minus(self):
            return self.getToken(JavaScriptParser.Minus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinusExpression" ):
                listener.enterUnaryMinusExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinusExpression" ):
                listener.exitUnaryMinusExpression(self)


    class AssignmentExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Assign(self):
            return self.getToken(JavaScriptParser.Assign, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentExpression" ):
                listener.enterAssignmentExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentExpression" ):
                listener.exitAssignmentExpression(self)


    class PostDecreaseExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def MinusMinus(self):
            return self.getToken(JavaScriptParser.MinusMinus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostDecreaseExpression" ):
                listener.enterPostDecreaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostDecreaseExpression" ):
                listener.exitPostDecreaseExpression(self)


    class TypeofExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Typeof(self):
            return self.getToken(JavaScriptParser.Typeof, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeofExpression" ):
                listener.enterTypeofExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeofExpression" ):
                listener.exitTypeofExpression(self)


    class InstanceofExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Instanceof(self):
            return self.getToken(JavaScriptParser.Instanceof, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstanceofExpression" ):
                listener.enterInstanceofExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstanceofExpression" ):
                listener.exitInstanceofExpression(self)


    class UnaryPlusExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Plus(self):
            return self.getToken(JavaScriptParser.Plus, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryPlusExpression" ):
                listener.enterUnaryPlusExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryPlusExpression" ):
                listener.exitUnaryPlusExpression(self)


    class DeleteExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Delete(self):
            return self.getToken(JavaScriptParser.Delete, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeleteExpression" ):
                listener.enterDeleteExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeleteExpression" ):
                listener.exitDeleteExpression(self)


    class ImportExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Import(self):
            return self.getToken(JavaScriptParser.Import, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportExpression" ):
                listener.enterImportExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportExpression" ):
                listener.exitImportExpression(self)


    class EqualityExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Equals_(self):
            return self.getToken(JavaScriptParser.Equals_, 0)
        def NotEquals(self):
            return self.getToken(JavaScriptParser.NotEquals, 0)
        def IdentityEquals(self):
            return self.getToken(JavaScriptParser.IdentityEquals, 0)
        def IdentityNotEquals(self):
            return self.getToken(JavaScriptParser.IdentityNotEquals, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEqualityExpression" ):
                listener.enterEqualityExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEqualityExpression" ):
                listener.exitEqualityExpression(self)


    class BitXOrExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def BitXOr(self):
            return self.getToken(JavaScriptParser.BitXOr, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitXOrExpression" ):
                listener.enterBitXOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitXOrExpression" ):
                listener.exitBitXOrExpression(self)


    class SuperExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Super(self):
            return self.getToken(JavaScriptParser.Super, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuperExpression" ):
                listener.enterSuperExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuperExpression" ):
                listener.exitSuperExpression(self)


    class MultiplicativeExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)
        def Divide(self):
            return self.getToken(JavaScriptParser.Divide, 0)
        def Modulus(self):
            return self.getToken(JavaScriptParser.Modulus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)


    class BitShiftExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def LeftShiftArithmetic(self):
            return self.getToken(JavaScriptParser.LeftShiftArithmetic, 0)
        def RightShiftArithmetic(self):
            return self.getToken(JavaScriptParser.RightShiftArithmetic, 0)
        def RightShiftLogical(self):
            return self.getToken(JavaScriptParser.RightShiftLogical, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitShiftExpression" ):
                listener.enterBitShiftExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitShiftExpression" ):
                listener.exitBitShiftExpression(self)


    class ParenthesizedExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)


    class AdditiveExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def Plus(self):
            return self.getToken(JavaScriptParser.Plus, 0)
        def Minus(self):
            return self.getToken(JavaScriptParser.Minus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)


    class RelationalExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def LessThan(self):
            return self.getToken(JavaScriptParser.LessThan, 0)
        def MoreThan(self):
            return self.getToken(JavaScriptParser.MoreThan, 0)
        def LessThanEquals(self):
            return self.getToken(JavaScriptParser.LessThanEquals, 0)
        def GreaterThanEquals(self):
            return self.getToken(JavaScriptParser.GreaterThanEquals, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationalExpression" ):
                listener.enterRelationalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationalExpression" ):
                listener.exitRelationalExpression(self)


    class PostIncrementExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def PlusPlus(self):
            return self.getToken(JavaScriptParser.PlusPlus, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostIncrementExpression" ):
                listener.enterPostIncrementExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostIncrementExpression" ):
                listener.exitPostIncrementExpression(self)


    class YieldExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def yieldStatement(self):
            return self.getTypedRuleContext(JavaScriptParser.YieldStatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldExpression" ):
                listener.enterYieldExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldExpression" ):
                listener.exitYieldExpression(self)


    class BitNotExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BitNot(self):
            return self.getToken(JavaScriptParser.BitNot, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitNotExpression" ):
                listener.enterBitNotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitNotExpression" ):
                listener.exitBitNotExpression(self)


    class NewExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def New(self):
            return self.getToken(JavaScriptParser.New, 0)
        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)

        def arguments(self):
            return self.getTypedRuleContext(JavaScriptParser.ArgumentsContext,0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNewExpression" ):
                listener.enterNewExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNewExpression" ):
                listener.exitNewExpression(self)


    class LiteralExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(JavaScriptParser.LiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteralExpression" ):
                listener.enterLiteralExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteralExpression" ):
                listener.exitLiteralExpression(self)


    class ArrayLiteralExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def arrayLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.ArrayLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayLiteralExpression" ):
                listener.enterArrayLiteralExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayLiteralExpression" ):
                listener.exitArrayLiteralExpression(self)


    class MemberDotExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def Dot(self):
            return self.getToken(JavaScriptParser.Dot, 0)
        def identifierName(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierNameContext,0)

        def QuestionMark(self):
            return self.getToken(JavaScriptParser.QuestionMark, 0)
        def Hashtag(self):
            return self.getToken(JavaScriptParser.Hashtag, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberDotExpression" ):
                listener.enterMemberDotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberDotExpression" ):
                listener.exitMemberDotExpression(self)


    class ClassExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Class(self):
            return self.getToken(JavaScriptParser.Class, 0)
        def classTail(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassTailContext,0)

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassExpression" ):
                listener.enterClassExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassExpression" ):
                listener.exitClassExpression(self)


    class MemberIndexExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)

        def OpenBracket(self):
            return self.getToken(JavaScriptParser.OpenBracket, 0)
        def expressionSequence(self):
            return self.getTypedRuleContext(JavaScriptParser.ExpressionSequenceContext,0)

        def CloseBracket(self):
            return self.getToken(JavaScriptParser.CloseBracket, 0)
        def QuestionMarkDot(self):
            return self.getToken(JavaScriptParser.QuestionMarkDot, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberIndexExpression" ):
                listener.enterMemberIndexExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberIndexExpression" ):
                listener.exitMemberIndexExpression(self)


    class IdentifierExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpression" ):
                listener.enterIdentifierExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpression" ):
                listener.exitIdentifierExpression(self)


    class BitAndExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def BitAnd(self):
            return self.getToken(JavaScriptParser.BitAnd, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitAndExpression" ):
                listener.enterBitAndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitAndExpression" ):
                listener.exitBitAndExpression(self)


    class BitOrExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def BitOr(self):
            return self.getToken(JavaScriptParser.BitOr, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitOrExpression" ):
                listener.enterBitOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitOrExpression" ):
                listener.exitBitOrExpression(self)


    class AssignmentOperatorExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def assignmentOperator(self):
            return self.getTypedRuleContext(JavaScriptParser.AssignmentOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentOperatorExpression" ):
                listener.enterAssignmentOperatorExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentOperatorExpression" ):
                listener.exitAssignmentOperatorExpression(self)


    class VoidExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Void(self):
            return self.getToken(JavaScriptParser.Void, 0)
        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoidExpression" ):
                listener.enterVoidExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoidExpression" ):
                listener.exitVoidExpression(self)


    class CoalesceExpressionContext(SingleExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.SingleExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def singleExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.SingleExpressionContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,i)

        def NullCoalesce(self):
            return self.getToken(JavaScriptParser.NullCoalesce, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoalesceExpression" ):
                listener.enterCoalesceExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoalesceExpression" ):
                listener.exitCoalesceExpression(self)



    def singleExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = JavaScriptParser.SingleExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 130
        self.enterRecursionRule(localctx, 130, self.RULE_singleExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 837
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.FunctionExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 782
                self.anonymousFunction()
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.ClassExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 783
                self.match(JavaScriptParser.Class)
                self.state = 785
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 4232199) != 0):
                    self.state = 784
                    self.identifier()


                self.state = 787
                self.classTail()
                pass

            elif la_ == 3:
                localctx = JavaScriptParser.NewExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 788
                self.match(JavaScriptParser.New)
                self.state = 789
                self.identifier()
                self.state = 790
                self.arguments()
                pass

            elif la_ == 4:
                localctx = JavaScriptParser.NewExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 792
                self.match(JavaScriptParser.New)
                self.state = 793
                self.singleExpression(0)
                self.state = 794
                self.arguments()
                pass

            elif la_ == 5:
                localctx = JavaScriptParser.NewExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 796
                self.match(JavaScriptParser.New)
                self.state = 797
                self.singleExpression(42)
                pass

            elif la_ == 6:
                localctx = JavaScriptParser.MetaExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 798
                self.match(JavaScriptParser.New)
                self.state = 799
                self.match(JavaScriptParser.Dot)
                self.state = 800
                self.identifier()
                pass

            elif la_ == 7:
                localctx = JavaScriptParser.DeleteExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 801
                self.match(JavaScriptParser.Delete)
                self.state = 802
                self.singleExpression(37)
                pass

            elif la_ == 8:
                localctx = JavaScriptParser.VoidExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 803
                self.match(JavaScriptParser.Void)
                self.state = 804
                self.singleExpression(36)
                pass

            elif la_ == 9:
                localctx = JavaScriptParser.TypeofExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 805
                self.match(JavaScriptParser.Typeof)
                self.state = 806
                self.singleExpression(35)
                pass

            elif la_ == 10:
                localctx = JavaScriptParser.PreIncrementExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 807
                self.match(JavaScriptParser.PlusPlus)
                self.state = 808
                self.singleExpression(34)
                pass

            elif la_ == 11:
                localctx = JavaScriptParser.PreDecreaseExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 809
                self.match(JavaScriptParser.MinusMinus)
                self.state = 810
                self.singleExpression(33)
                pass

            elif la_ == 12:
                localctx = JavaScriptParser.UnaryPlusExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 811
                self.match(JavaScriptParser.Plus)
                self.state = 812
                self.singleExpression(32)
                pass

            elif la_ == 13:
                localctx = JavaScriptParser.UnaryMinusExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 813
                self.match(JavaScriptParser.Minus)
                self.state = 814
                self.singleExpression(31)
                pass

            elif la_ == 14:
                localctx = JavaScriptParser.BitNotExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 815
                self.match(JavaScriptParser.BitNot)
                self.state = 816
                self.singleExpression(30)
                pass

            elif la_ == 15:
                localctx = JavaScriptParser.NotExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 817
                self.match(JavaScriptParser.Not)
                self.state = 818
                self.singleExpression(29)
                pass

            elif la_ == 16:
                localctx = JavaScriptParser.AwaitExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 819
                self.match(JavaScriptParser.Await)
                self.state = 820
                self.singleExpression(28)
                pass

            elif la_ == 17:
                localctx = JavaScriptParser.ImportExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 821
                self.match(JavaScriptParser.Import)
                self.state = 822
                self.match(JavaScriptParser.OpenParen)
                self.state = 823
                self.singleExpression(0)
                self.state = 824
                self.match(JavaScriptParser.CloseParen)
                pass

            elif la_ == 18:
                localctx = JavaScriptParser.YieldExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 826
                self.yieldStatement()
                pass

            elif la_ == 19:
                localctx = JavaScriptParser.ThisExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 827
                self.match(JavaScriptParser.This)
                pass

            elif la_ == 20:
                localctx = JavaScriptParser.IdentifierExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 828
                self.identifier()
                pass

            elif la_ == 21:
                localctx = JavaScriptParser.SuperExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 829
                self.match(JavaScriptParser.Super)
                pass

            elif la_ == 22:
                localctx = JavaScriptParser.LiteralExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 830
                self.literal()
                pass

            elif la_ == 23:
                localctx = JavaScriptParser.ArrayLiteralExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 831
                self.arrayLiteral()
                pass

            elif la_ == 24:
                localctx = JavaScriptParser.ObjectLiteralExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 832
                self.objectLiteral()
                pass

            elif la_ == 25:
                localctx = JavaScriptParser.ParenthesizedExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 833
                self.match(JavaScriptParser.OpenParen)
                self.state = 834
                self.expressionSequence()
                self.state = 835
                self.match(JavaScriptParser.CloseParen)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 926
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,99,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 924
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
                    if la_ == 1:
                        localctx = JavaScriptParser.OptionalChainExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 839
                        if not self.precpred(self._ctx, 47):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 47)")
                        self.state = 840
                        self.match(JavaScriptParser.QuestionMarkDot)
                        self.state = 841
                        self.singleExpression(48)
                        pass

                    elif la_ == 2:
                        localctx = JavaScriptParser.PowerExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 842
                        if not self.precpred(self._ctx, 27):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 27)")
                        self.state = 843
                        self.match(JavaScriptParser.Power)
                        self.state = 844
                        self.singleExpression(27)
                        pass

                    elif la_ == 3:
                        localctx = JavaScriptParser.MultiplicativeExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 845
                        if not self.precpred(self._ctx, 26):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 26)")
                        self.state = 846
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 469762048) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 847
                        self.singleExpression(27)
                        pass

                    elif la_ == 4:
                        localctx = JavaScriptParser.AdditiveExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 848
                        if not self.precpred(self._ctx, 25):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 25)")
                        self.state = 849
                        _la = self._input.LA(1)
                        if not(_la==22 or _la==23):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 850
                        self.singleExpression(26)
                        pass

                    elif la_ == 5:
                        localctx = JavaScriptParser.CoalesceExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 851
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 852
                        self.match(JavaScriptParser.NullCoalesce)
                        self.state = 853
                        self.singleExpression(25)
                        pass

                    elif la_ == 6:
                        localctx = JavaScriptParser.BitShiftExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 854
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 855
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 30064771072) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 856
                        self.singleExpression(24)
                        pass

                    elif la_ == 7:
                        localctx = JavaScriptParser.RelationalExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 857
                        if not self.precpred(self._ctx, 22):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 22)")
                        self.state = 858
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 515396075520) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 859
                        self.singleExpression(23)
                        pass

                    elif la_ == 8:
                        localctx = JavaScriptParser.InstanceofExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 860
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 861
                        self.match(JavaScriptParser.Instanceof)
                        self.state = 862
                        self.singleExpression(22)
                        pass

                    elif la_ == 9:
                        localctx = JavaScriptParser.InExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 863
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 864
                        self.match(JavaScriptParser.In)
                        self.state = 865
                        self.singleExpression(21)
                        pass

                    elif la_ == 10:
                        localctx = JavaScriptParser.EqualityExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 866
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 867
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8246337208320) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 868
                        self.singleExpression(20)
                        pass

                    elif la_ == 11:
                        localctx = JavaScriptParser.BitAndExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 869
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 870
                        self.match(JavaScriptParser.BitAnd)
                        self.state = 871
                        self.singleExpression(19)
                        pass

                    elif la_ == 12:
                        localctx = JavaScriptParser.BitXOrExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 872
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 873
                        self.match(JavaScriptParser.BitXOr)
                        self.state = 874
                        self.singleExpression(18)
                        pass

                    elif la_ == 13:
                        localctx = JavaScriptParser.BitOrExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 875
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 876
                        self.match(JavaScriptParser.BitOr)
                        self.state = 877
                        self.singleExpression(17)
                        pass

                    elif la_ == 14:
                        localctx = JavaScriptParser.LogicalAndExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 878
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 879
                        self.match(JavaScriptParser.And)
                        self.state = 880
                        self.singleExpression(16)
                        pass

                    elif la_ == 15:
                        localctx = JavaScriptParser.LogicalOrExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 881
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 882
                        self.match(JavaScriptParser.Or)
                        self.state = 883
                        self.singleExpression(15)
                        pass

                    elif la_ == 16:
                        localctx = JavaScriptParser.TernaryExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 884
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 885
                        self.match(JavaScriptParser.QuestionMark)
                        self.state = 886
                        self.singleExpression(0)
                        self.state = 887
                        self.match(JavaScriptParser.Colon)
                        self.state = 888
                        self.singleExpression(14)
                        pass

                    elif la_ == 17:
                        localctx = JavaScriptParser.AssignmentExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 890
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 891
                        self.match(JavaScriptParser.Assign)
                        self.state = 892
                        self.singleExpression(12)
                        pass

                    elif la_ == 18:
                        localctx = JavaScriptParser.AssignmentOperatorExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 893
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 894
                        self.assignmentOperator()
                        self.state = 895
                        self.singleExpression(11)
                        pass

                    elif la_ == 19:
                        localctx = JavaScriptParser.MemberIndexExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 897
                        if not self.precpred(self._ctx, 46):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 46)")
                        self.state = 899
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==16:
                            self.state = 898
                            self.match(JavaScriptParser.QuestionMarkDot)


                        self.state = 901
                        self.match(JavaScriptParser.OpenBracket)
                        self.state = 902
                        self.expressionSequence()
                        self.state = 903
                        self.match(JavaScriptParser.CloseBracket)
                        pass

                    elif la_ == 20:
                        localctx = JavaScriptParser.MemberDotExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 905
                        if not self.precpred(self._ctx, 45):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 45)")
                        self.state = 907
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==15:
                            self.state = 906
                            self.match(JavaScriptParser.QuestionMark)


                        self.state = 909
                        self.match(JavaScriptParser.Dot)
                        self.state = 911
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==31:
                            self.state = 910
                            self.match(JavaScriptParser.Hashtag)


                        self.state = 913
                        self.identifierName()
                        pass

                    elif la_ == 21:
                        localctx = JavaScriptParser.ArgumentsExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 914
                        if not self.precpred(self._ctx, 41):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 41)")
                        self.state = 915
                        self.arguments()
                        pass

                    elif la_ == 22:
                        localctx = JavaScriptParser.PostIncrementExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 916
                        if not self.precpred(self._ctx, 39):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 39)")
                        self.state = 917
                        if not self.notLineTerminator():
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.notLineTerminator()")
                        self.state = 918
                        self.match(JavaScriptParser.PlusPlus)
                        pass

                    elif la_ == 23:
                        localctx = JavaScriptParser.PostDecreaseExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 919
                        if not self.precpred(self._ctx, 38):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 38)")
                        self.state = 920
                        if not self.notLineTerminator():
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.notLineTerminator()")
                        self.state = 921
                        self.match(JavaScriptParser.MinusMinus)
                        pass

                    elif la_ == 24:
                        localctx = JavaScriptParser.TemplateStringExpressionContext(self, JavaScriptParser.SingleExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_singleExpression)
                        self.state = 922
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 923
                        self.templateStringLiteral()
                        pass

             
                self.state = 928
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,99,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class InitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Assign(self):
            return self.getToken(JavaScriptParser.Assign, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_initializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitializer" ):
                listener.enterInitializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitializer" ):
                listener.exitInitializer(self)




    def initializer(self):

        localctx = JavaScriptParser.InitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_initializer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 929
            self.match(JavaScriptParser.Assign)
            self.state = 930
            self.singleExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def arrayLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.ArrayLiteralContext,0)


        def objectLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.ObjectLiteralContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_assignable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignable" ):
                listener.enterAssignable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignable" ):
                listener.exitAssignable(self)




    def assignable(self):

        localctx = JavaScriptParser.AssignableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_assignable)
        try:
            self.state = 935
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [98, 99, 100, 108, 110, 113, 120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 932
                self.identifier()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 933
                self.arrayLiteral()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 3)
                self.state = 934
                self.objectLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OpenBrace(self):
            return self.getToken(JavaScriptParser.OpenBrace, 0)

        def CloseBrace(self):
            return self.getToken(JavaScriptParser.CloseBrace, 0)

        def propertyAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.PropertyAssignmentContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.PropertyAssignmentContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.Comma)
            else:
                return self.getToken(JavaScriptParser.Comma, i)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_objectLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteral" ):
                listener.enterObjectLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteral" ):
                listener.exitObjectLiteral(self)




    def objectLiteral(self):

        localctx = JavaScriptParser.ObjectLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_objectLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 937
            self.match(JavaScriptParser.OpenBrace)
            self.state = 949
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.state = 938
                self.propertyAssignment()
                self.state = 943
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,101,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 939
                        self.match(JavaScriptParser.Comma)
                        self.state = 940
                        self.propertyAssignment() 
                    self.state = 945
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,101,self._ctx)

                self.state = 947
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 946
                    self.match(JavaScriptParser.Comma)




            self.state = 951
            self.match(JavaScriptParser.CloseBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnonymousFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JavaScriptParser.RULE_anonymousFunction

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AnonymousFunctionDeclContext(AnonymousFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.AnonymousFunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Function_(self):
            return self.getToken(JavaScriptParser.Function_, 0)
        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)
        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)
        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)
        def Multiply(self):
            return self.getToken(JavaScriptParser.Multiply, 0)
        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnonymousFunctionDecl" ):
                listener.enterAnonymousFunctionDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnonymousFunctionDecl" ):
                listener.exitAnonymousFunctionDecl(self)


    class ArrowFunctionContext(AnonymousFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a JavaScriptParser.AnonymousFunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def arrowFunctionParameters(self):
            return self.getTypedRuleContext(JavaScriptParser.ArrowFunctionParametersContext,0)

        def ARROW(self):
            return self.getToken(JavaScriptParser.ARROW, 0)
        def arrowFunctionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.ArrowFunctionBodyContext,0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrowFunction" ):
                listener.enterArrowFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrowFunction" ):
                listener.exitArrowFunction(self)



    def anonymousFunction(self):

        localctx = JavaScriptParser.AnonymousFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_anonymousFunction)
        self._la = 0 # Token type
        try:
            self.state = 973
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                localctx = JavaScriptParser.AnonymousFunctionDeclContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 954
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==108:
                    self.state = 953
                    self.match(JavaScriptParser.Async)


                self.state = 956
                self.match(JavaScriptParser.Function_)
                self.state = 958
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 957
                    self.match(JavaScriptParser.Multiply)


                self.state = 960
                self.match(JavaScriptParser.OpenParen)
                self.state = 962
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 4232199) != 0):
                    self.state = 961
                    self.formalParameterList()


                self.state = 964
                self.match(JavaScriptParser.CloseParen)
                self.state = 965
                self.functionBody()
                pass

            elif la_ == 2:
                localctx = JavaScriptParser.ArrowFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 967
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
                if la_ == 1:
                    self.state = 966
                    self.match(JavaScriptParser.Async)


                self.state = 969
                self.arrowFunctionParameters()
                self.state = 970
                self.match(JavaScriptParser.ARROW)
                self.state = 971
                self.arrowFunctionBody()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrowFunctionParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def OpenParen(self):
            return self.getToken(JavaScriptParser.OpenParen, 0)

        def CloseParen(self):
            return self.getToken(JavaScriptParser.CloseParen, 0)

        def formalParameterList(self):
            return self.getTypedRuleContext(JavaScriptParser.FormalParameterListContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_arrowFunctionParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrowFunctionParameters" ):
                listener.enterArrowFunctionParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrowFunctionParameters" ):
                listener.exitArrowFunctionParameters(self)




    def arrowFunctionParameters(self):

        localctx = JavaScriptParser.ArrowFunctionParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_arrowFunctionParameters)
        self._la = 0 # Token type
        try:
            self.state = 981
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [98, 99, 100, 108, 110, 113, 120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 975
                self.identifier()
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 2)
                self.state = 976
                self.match(JavaScriptParser.OpenParen)
                self.state = 978
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 262688) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 4232199) != 0):
                    self.state = 977
                    self.formalParameterList()


                self.state = 980
                self.match(JavaScriptParser.CloseParen)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrowFunctionBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def functionBody(self):
            return self.getTypedRuleContext(JavaScriptParser.FunctionBodyContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_arrowFunctionBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrowFunctionBody" ):
                listener.enterArrowFunctionBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrowFunctionBody" ):
                listener.exitArrowFunctionBody(self)




    def arrowFunctionBody(self):

        localctx = JavaScriptParser.ArrowFunctionBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_arrowFunctionBody)
        try:
            self.state = 985
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 983
                self.singleExpression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 984
                self.functionBody()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MultiplyAssign(self):
            return self.getToken(JavaScriptParser.MultiplyAssign, 0)

        def DivideAssign(self):
            return self.getToken(JavaScriptParser.DivideAssign, 0)

        def ModulusAssign(self):
            return self.getToken(JavaScriptParser.ModulusAssign, 0)

        def PlusAssign(self):
            return self.getToken(JavaScriptParser.PlusAssign, 0)

        def MinusAssign(self):
            return self.getToken(JavaScriptParser.MinusAssign, 0)

        def LeftShiftArithmeticAssign(self):
            return self.getToken(JavaScriptParser.LeftShiftArithmeticAssign, 0)

        def RightShiftArithmeticAssign(self):
            return self.getToken(JavaScriptParser.RightShiftArithmeticAssign, 0)

        def RightShiftLogicalAssign(self):
            return self.getToken(JavaScriptParser.RightShiftLogicalAssign, 0)

        def BitAndAssign(self):
            return self.getToken(JavaScriptParser.BitAndAssign, 0)

        def BitXorAssign(self):
            return self.getToken(JavaScriptParser.BitXorAssign, 0)

        def BitOrAssign(self):
            return self.getToken(JavaScriptParser.BitOrAssign, 0)

        def PowerAssign(self):
            return self.getToken(JavaScriptParser.PowerAssign, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_assignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentOperator" ):
                listener.enterAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentOperator" ):
                listener.exitAssignmentOperator(self)




    def assignmentOperator(self):

        localctx = JavaScriptParser.AssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_assignmentOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 987
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1152640029630136320) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NullLiteral(self):
            return self.getToken(JavaScriptParser.NullLiteral, 0)

        def BooleanLiteral(self):
            return self.getToken(JavaScriptParser.BooleanLiteral, 0)

        def StringLiteral(self):
            return self.getToken(JavaScriptParser.StringLiteral, 0)

        def templateStringLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.TemplateStringLiteralContext,0)


        def RegularExpressionLiteral(self):
            return self.getToken(JavaScriptParser.RegularExpressionLiteral, 0)

        def numericLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.NumericLiteralContext,0)


        def bigintLiteral(self):
            return self.getTypedRuleContext(JavaScriptParser.BigintLiteralContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = JavaScriptParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_literal)
        try:
            self.state = 996
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [61]:
                self.enterOuterAlt(localctx, 1)
                self.state = 989
                self.match(JavaScriptParser.NullLiteral)
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 2)
                self.state = 990
                self.match(JavaScriptParser.BooleanLiteral)
                pass
            elif token in [121]:
                self.enterOuterAlt(localctx, 3)
                self.state = 991
                self.match(JavaScriptParser.StringLiteral)
                pass
            elif token in [122]:
                self.enterOuterAlt(localctx, 4)
                self.state = 992
                self.templateStringLiteral()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 5)
                self.state = 993
                self.match(JavaScriptParser.RegularExpressionLiteral)
                pass
            elif token in [63, 64, 65, 66, 67]:
                self.enterOuterAlt(localctx, 6)
                self.state = 994
                self.numericLiteral()
                pass
            elif token in [68, 69, 70, 71]:
                self.enterOuterAlt(localctx, 7)
                self.state = 995
                self.bigintLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemplateStringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BackTick(self, i:int=None):
            if i is None:
                return self.getTokens(JavaScriptParser.BackTick)
            else:
                return self.getToken(JavaScriptParser.BackTick, i)

        def templateStringAtom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaScriptParser.TemplateStringAtomContext)
            else:
                return self.getTypedRuleContext(JavaScriptParser.TemplateStringAtomContext,i)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_templateStringLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplateStringLiteral" ):
                listener.enterTemplateStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplateStringLiteral" ):
                listener.exitTemplateStringLiteral(self)




    def templateStringLiteral(self):

        localctx = JavaScriptParser.TemplateStringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_templateStringLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 998
            self.match(JavaScriptParser.BackTick)
            self.state = 1002
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==128 or _la==129:
                self.state = 999
                self.templateStringAtom()
                self.state = 1004
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1005
            self.match(JavaScriptParser.BackTick)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemplateStringAtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TemplateStringAtom(self):
            return self.getToken(JavaScriptParser.TemplateStringAtom, 0)

        def TemplateStringStartExpression(self):
            return self.getToken(JavaScriptParser.TemplateStringStartExpression, 0)

        def singleExpression(self):
            return self.getTypedRuleContext(JavaScriptParser.SingleExpressionContext,0)


        def TemplateCloseBrace(self):
            return self.getToken(JavaScriptParser.TemplateCloseBrace, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_templateStringAtom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplateStringAtom" ):
                listener.enterTemplateStringAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplateStringAtom" ):
                listener.exitTemplateStringAtom(self)




    def templateStringAtom(self):

        localctx = JavaScriptParser.TemplateStringAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_templateStringAtom)
        try:
            self.state = 1012
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [129]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1007
                self.match(JavaScriptParser.TemplateStringAtom)
                pass
            elif token in [128]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1008
                self.match(JavaScriptParser.TemplateStringStartExpression)
                self.state = 1009
                self.singleExpression(0)
                self.state = 1010
                self.match(JavaScriptParser.TemplateCloseBrace)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DecimalLiteral(self):
            return self.getToken(JavaScriptParser.DecimalLiteral, 0)

        def HexIntegerLiteral(self):
            return self.getToken(JavaScriptParser.HexIntegerLiteral, 0)

        def OctalIntegerLiteral(self):
            return self.getToken(JavaScriptParser.OctalIntegerLiteral, 0)

        def OctalIntegerLiteral2(self):
            return self.getToken(JavaScriptParser.OctalIntegerLiteral2, 0)

        def BinaryIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BinaryIntegerLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_numericLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericLiteral" ):
                listener.enterNumericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericLiteral" ):
                listener.exitNumericLiteral(self)




    def numericLiteral(self):

        localctx = JavaScriptParser.NumericLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_numericLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1014
            _la = self._input.LA(1)
            if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BigintLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BigDecimalIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BigDecimalIntegerLiteral, 0)

        def BigHexIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BigHexIntegerLiteral, 0)

        def BigOctalIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BigOctalIntegerLiteral, 0)

        def BigBinaryIntegerLiteral(self):
            return self.getToken(JavaScriptParser.BigBinaryIntegerLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_bigintLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBigintLiteral" ):
                listener.enterBigintLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBigintLiteral" ):
                listener.exitBigintLiteral(self)




    def bigintLiteral(self):

        localctx = JavaScriptParser.BigintLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_bigintLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1016
            _la = self._input.LA(1)
            if not(((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def classElementName(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassElementNameContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_getter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetter" ):
                listener.enterGetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetter" ):
                listener.exitGetter(self)




    def getter(self):

        localctx = JavaScriptParser.GetterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_getter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1018
            if not self.n("get"):
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.n(\"get\")")
            self.state = 1019
            self.identifier()
            self.state = 1020
            self.classElementName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def classElementName(self):
            return self.getTypedRuleContext(JavaScriptParser.ClassElementNameContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_setter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetter" ):
                listener.enterSetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetter" ):
                listener.exitSetter(self)




    def setter(self):

        localctx = JavaScriptParser.SetterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_setter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1022
            if not self.n("set"):
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "self.n(\"set\")")
            self.state = 1023
            self.identifier()
            self.state = 1024
            self.classElementName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaScriptParser.IdentifierContext,0)


        def reservedWord(self):
            return self.getTypedRuleContext(JavaScriptParser.ReservedWordContext,0)


        def getRuleIndex(self):
            return JavaScriptParser.RULE_identifierName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierName" ):
                listener.enterIdentifierName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierName" ):
                listener.exitIdentifierName(self)




    def identifierName(self):

        localctx = JavaScriptParser.IdentifierNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_identifierName)
        try:
            self.state = 1028
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1026
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1027
                self.reservedWord()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(JavaScriptParser.Identifier, 0)

        def NonStrictLet(self):
            return self.getToken(JavaScriptParser.NonStrictLet, 0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)

        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def From(self):
            return self.getToken(JavaScriptParser.From, 0)

        def Yield(self):
            return self.getToken(JavaScriptParser.Yield, 0)

        def Of(self):
            return self.getToken(JavaScriptParser.Of, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = JavaScriptParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1030
            _la = self._input.LA(1)
            if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 4232199) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReservedWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keyword(self):
            return self.getTypedRuleContext(JavaScriptParser.KeywordContext,0)


        def NullLiteral(self):
            return self.getToken(JavaScriptParser.NullLiteral, 0)

        def BooleanLiteral(self):
            return self.getToken(JavaScriptParser.BooleanLiteral, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_reservedWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReservedWord" ):
                listener.enterReservedWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReservedWord" ):
                listener.exitReservedWord(self)




    def reservedWord(self):

        localctx = JavaScriptParser.ReservedWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_reservedWord)
        try:
            self.state = 1035
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1032
                self.keyword()
                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1033
                self.match(JavaScriptParser.NullLiteral)
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1034
                self.match(JavaScriptParser.BooleanLiteral)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Break(self):
            return self.getToken(JavaScriptParser.Break, 0)

        def Do(self):
            return self.getToken(JavaScriptParser.Do, 0)

        def Instanceof(self):
            return self.getToken(JavaScriptParser.Instanceof, 0)

        def Typeof(self):
            return self.getToken(JavaScriptParser.Typeof, 0)

        def Case(self):
            return self.getToken(JavaScriptParser.Case, 0)

        def Else(self):
            return self.getToken(JavaScriptParser.Else, 0)

        def New(self):
            return self.getToken(JavaScriptParser.New, 0)

        def Var(self):
            return self.getToken(JavaScriptParser.Var, 0)

        def Catch(self):
            return self.getToken(JavaScriptParser.Catch, 0)

        def Finally(self):
            return self.getToken(JavaScriptParser.Finally, 0)

        def Return(self):
            return self.getToken(JavaScriptParser.Return, 0)

        def Void(self):
            return self.getToken(JavaScriptParser.Void, 0)

        def Continue(self):
            return self.getToken(JavaScriptParser.Continue, 0)

        def For(self):
            return self.getToken(JavaScriptParser.For, 0)

        def Switch(self):
            return self.getToken(JavaScriptParser.Switch, 0)

        def While(self):
            return self.getToken(JavaScriptParser.While, 0)

        def Debugger(self):
            return self.getToken(JavaScriptParser.Debugger, 0)

        def Function_(self):
            return self.getToken(JavaScriptParser.Function_, 0)

        def This(self):
            return self.getToken(JavaScriptParser.This, 0)

        def With(self):
            return self.getToken(JavaScriptParser.With, 0)

        def Default(self):
            return self.getToken(JavaScriptParser.Default, 0)

        def If(self):
            return self.getToken(JavaScriptParser.If, 0)

        def Throw(self):
            return self.getToken(JavaScriptParser.Throw, 0)

        def Delete(self):
            return self.getToken(JavaScriptParser.Delete, 0)

        def In(self):
            return self.getToken(JavaScriptParser.In, 0)

        def Try(self):
            return self.getToken(JavaScriptParser.Try, 0)

        def Class(self):
            return self.getToken(JavaScriptParser.Class, 0)

        def Enum(self):
            return self.getToken(JavaScriptParser.Enum, 0)

        def Extends(self):
            return self.getToken(JavaScriptParser.Extends, 0)

        def Super(self):
            return self.getToken(JavaScriptParser.Super, 0)

        def Const(self):
            return self.getToken(JavaScriptParser.Const, 0)

        def Export(self):
            return self.getToken(JavaScriptParser.Export, 0)

        def Import(self):
            return self.getToken(JavaScriptParser.Import, 0)

        def Implements(self):
            return self.getToken(JavaScriptParser.Implements, 0)

        def let_(self):
            return self.getTypedRuleContext(JavaScriptParser.Let_Context,0)


        def Private(self):
            return self.getToken(JavaScriptParser.Private, 0)

        def Public(self):
            return self.getToken(JavaScriptParser.Public, 0)

        def Interface(self):
            return self.getToken(JavaScriptParser.Interface, 0)

        def Package(self):
            return self.getToken(JavaScriptParser.Package, 0)

        def Protected(self):
            return self.getToken(JavaScriptParser.Protected, 0)

        def Static(self):
            return self.getToken(JavaScriptParser.Static, 0)

        def Yield(self):
            return self.getToken(JavaScriptParser.Yield, 0)

        def Async(self):
            return self.getToken(JavaScriptParser.Async, 0)

        def Await(self):
            return self.getToken(JavaScriptParser.Await, 0)

        def From(self):
            return self.getToken(JavaScriptParser.From, 0)

        def As(self):
            return self.getToken(JavaScriptParser.As, 0)

        def Of(self):
            return self.getToken(JavaScriptParser.Of, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)




    def keyword(self):

        localctx = JavaScriptParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_keyword)
        try:
            self.state = 1084
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [72]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1037
                self.match(JavaScriptParser.Break)
                pass
            elif token in [73]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1038
                self.match(JavaScriptParser.Do)
                pass
            elif token in [74]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1039
                self.match(JavaScriptParser.Instanceof)
                pass
            elif token in [75]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1040
                self.match(JavaScriptParser.Typeof)
                pass
            elif token in [76]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1041
                self.match(JavaScriptParser.Case)
                pass
            elif token in [77]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1042
                self.match(JavaScriptParser.Else)
                pass
            elif token in [78]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1043
                self.match(JavaScriptParser.New)
                pass
            elif token in [79]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1044
                self.match(JavaScriptParser.Var)
                pass
            elif token in [80]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1045
                self.match(JavaScriptParser.Catch)
                pass
            elif token in [81]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1046
                self.match(JavaScriptParser.Finally)
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 11)
                self.state = 1047
                self.match(JavaScriptParser.Return)
                pass
            elif token in [83]:
                self.enterOuterAlt(localctx, 12)
                self.state = 1048
                self.match(JavaScriptParser.Void)
                pass
            elif token in [84]:
                self.enterOuterAlt(localctx, 13)
                self.state = 1049
                self.match(JavaScriptParser.Continue)
                pass
            elif token in [85]:
                self.enterOuterAlt(localctx, 14)
                self.state = 1050
                self.match(JavaScriptParser.For)
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 15)
                self.state = 1051
                self.match(JavaScriptParser.Switch)
                pass
            elif token in [87]:
                self.enterOuterAlt(localctx, 16)
                self.state = 1052
                self.match(JavaScriptParser.While)
                pass
            elif token in [88]:
                self.enterOuterAlt(localctx, 17)
                self.state = 1053
                self.match(JavaScriptParser.Debugger)
                pass
            elif token in [89]:
                self.enterOuterAlt(localctx, 18)
                self.state = 1054
                self.match(JavaScriptParser.Function_)
                pass
            elif token in [90]:
                self.enterOuterAlt(localctx, 19)
                self.state = 1055
                self.match(JavaScriptParser.This)
                pass
            elif token in [91]:
                self.enterOuterAlt(localctx, 20)
                self.state = 1056
                self.match(JavaScriptParser.With)
                pass
            elif token in [92]:
                self.enterOuterAlt(localctx, 21)
                self.state = 1057
                self.match(JavaScriptParser.Default)
                pass
            elif token in [93]:
                self.enterOuterAlt(localctx, 22)
                self.state = 1058
                self.match(JavaScriptParser.If)
                pass
            elif token in [94]:
                self.enterOuterAlt(localctx, 23)
                self.state = 1059
                self.match(JavaScriptParser.Throw)
                pass
            elif token in [95]:
                self.enterOuterAlt(localctx, 24)
                self.state = 1060
                self.match(JavaScriptParser.Delete)
                pass
            elif token in [96]:
                self.enterOuterAlt(localctx, 25)
                self.state = 1061
                self.match(JavaScriptParser.In)
                pass
            elif token in [97]:
                self.enterOuterAlt(localctx, 26)
                self.state = 1062
                self.match(JavaScriptParser.Try)
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 27)
                self.state = 1063
                self.match(JavaScriptParser.Class)
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 28)
                self.state = 1064
                self.match(JavaScriptParser.Enum)
                pass
            elif token in [103]:
                self.enterOuterAlt(localctx, 29)
                self.state = 1065
                self.match(JavaScriptParser.Extends)
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 30)
                self.state = 1066
                self.match(JavaScriptParser.Super)
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 31)
                self.state = 1067
                self.match(JavaScriptParser.Const)
                pass
            elif token in [106]:
                self.enterOuterAlt(localctx, 32)
                self.state = 1068
                self.match(JavaScriptParser.Export)
                pass
            elif token in [107]:
                self.enterOuterAlt(localctx, 33)
                self.state = 1069
                self.match(JavaScriptParser.Import)
                pass
            elif token in [111]:
                self.enterOuterAlt(localctx, 34)
                self.state = 1070
                self.match(JavaScriptParser.Implements)
                pass
            elif token in [112, 113]:
                self.enterOuterAlt(localctx, 35)
                self.state = 1071
                self.let_()
                pass
            elif token in [114]:
                self.enterOuterAlt(localctx, 36)
                self.state = 1072
                self.match(JavaScriptParser.Private)
                pass
            elif token in [115]:
                self.enterOuterAlt(localctx, 37)
                self.state = 1073
                self.match(JavaScriptParser.Public)
                pass
            elif token in [116]:
                self.enterOuterAlt(localctx, 38)
                self.state = 1074
                self.match(JavaScriptParser.Interface)
                pass
            elif token in [117]:
                self.enterOuterAlt(localctx, 39)
                self.state = 1075
                self.match(JavaScriptParser.Package)
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 40)
                self.state = 1076
                self.match(JavaScriptParser.Protected)
                pass
            elif token in [119]:
                self.enterOuterAlt(localctx, 41)
                self.state = 1077
                self.match(JavaScriptParser.Static)
                pass
            elif token in [110]:
                self.enterOuterAlt(localctx, 42)
                self.state = 1078
                self.match(JavaScriptParser.Yield)
                pass
            elif token in [108]:
                self.enterOuterAlt(localctx, 43)
                self.state = 1079
                self.match(JavaScriptParser.Async)
                pass
            elif token in [109]:
                self.enterOuterAlt(localctx, 44)
                self.state = 1080
                self.match(JavaScriptParser.Await)
                pass
            elif token in [99]:
                self.enterOuterAlt(localctx, 45)
                self.state = 1081
                self.match(JavaScriptParser.From)
                pass
            elif token in [98]:
                self.enterOuterAlt(localctx, 46)
                self.state = 1082
                self.match(JavaScriptParser.As)
                pass
            elif token in [100]:
                self.enterOuterAlt(localctx, 47)
                self.state = 1083
                self.match(JavaScriptParser.Of)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Let_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NonStrictLet(self):
            return self.getToken(JavaScriptParser.NonStrictLet, 0)

        def StrictLet(self):
            return self.getToken(JavaScriptParser.StrictLet, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_let_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLet_" ):
                listener.enterLet_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLet_" ):
                listener.exitLet_(self)




    def let_(self):

        localctx = JavaScriptParser.Let_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_let_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1086
            _la = self._input.LA(1)
            if not(_la==112 or _la==113):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EosContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SemiColon(self):
            return self.getToken(JavaScriptParser.SemiColon, 0)

        def EOF(self):
            return self.getToken(JavaScriptParser.EOF, 0)

        def getRuleIndex(self):
            return JavaScriptParser.RULE_eos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEos" ):
                listener.enterEos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEos" ):
                listener.exitEos(self)




    def eos(self):

        localctx = JavaScriptParser.EosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_eos)
        try:
            self.state = 1092
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1088
                self.match(JavaScriptParser.SemiColon)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1089
                self.match(JavaScriptParser.EOF)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1090
                if not self.lineTerminatorAhead():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.lineTerminatorAhead()")
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1091
                if not self.closeBrace():
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.closeBrace()")
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[24] = self.expressionStatement_sempred
        self._predicates[28] = self.continueStatement_sempred
        self._predicates[29] = self.breakStatement_sempred
        self._predicates[30] = self.returnStatement_sempred
        self._predicates[31] = self.yieldStatement_sempred
        self._predicates[39] = self.throwStatement_sempred
        self._predicates[47] = self.classElement_sempred
        self._predicates[48] = self.methodDefinition_sempred
        self._predicates[65] = self.singleExpression_sempred
        self._predicates[78] = self.getter_sempred
        self._predicates[79] = self.setter_sempred
        self._predicates[85] = self.eos_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expressionStatement_sempred(self, localctx:ExpressionStatementContext, predIndex:int):
            if predIndex == 0:
                return self.notOpenBraceAndNotFunction()
         

    def continueStatement_sempred(self, localctx:ContinueStatementContext, predIndex:int):
            if predIndex == 1:
                return self.notLineTerminator()
         

    def breakStatement_sempred(self, localctx:BreakStatementContext, predIndex:int):
            if predIndex == 2:
                return self.notLineTerminator()
         

    def returnStatement_sempred(self, localctx:ReturnStatementContext, predIndex:int):
            if predIndex == 3:
                return self.notLineTerminator()
         

    def yieldStatement_sempred(self, localctx:YieldStatementContext, predIndex:int):
            if predIndex == 4:
                return self.notLineTerminator()
         

    def throwStatement_sempred(self, localctx:ThrowStatementContext, predIndex:int):
            if predIndex == 5:
                return self.notLineTerminator()
         

    def classElement_sempred(self, localctx:ClassElementContext, predIndex:int):
            if predIndex == 6:
                return self.n("static")
         

            if predIndex == 7:
                return self.n("static")
         

            if predIndex == 8:
                return self.n("static")
         

    def methodDefinition_sempred(self, localctx:MethodDefinitionContext, predIndex:int):
            if predIndex == 9:
                return self.notLineTerminator()
         

    def singleExpression_sempred(self, localctx:SingleExpressionContext, predIndex:int):
            if predIndex == 10:
                return self.precpred(self._ctx, 47)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 27)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 26)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 25)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 24)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 23)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 22)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 20:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 21:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 22:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 23:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 24:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 25:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 26:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 27:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 28:
                return self.precpred(self._ctx, 46)
         

            if predIndex == 29:
                return self.precpred(self._ctx, 45)
         

            if predIndex == 30:
                return self.precpred(self._ctx, 41)
         

            if predIndex == 31:
                return self.precpred(self._ctx, 39)
         

            if predIndex == 32:
                return self.notLineTerminator()
         

            if predIndex == 33:
                return self.precpred(self._ctx, 38)
         

            if predIndex == 34:
                return self.notLineTerminator()
         

            if predIndex == 35:
                return self.precpred(self._ctx, 9)
         

    def getter_sempred(self, localctx:GetterContext, predIndex:int):
            if predIndex == 36:
                return self.n("get")
         

    def setter_sempred(self, localctx:SetterContext, predIndex:int):
            if predIndex == 37:
                return self.n("set")
         

    def eos_sempred(self, localctx:EosContext, predIndex:int):
            if predIndex == 38:
                return self.lineTerminatorAhead()
         

            if predIndex == 39:
                return self.closeBrace()
         




